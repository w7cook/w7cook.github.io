<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="William R. Cook" />
  <title>Anatomy of Programming Languages</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="cc/commentCloud.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">MathJax.Hub.Queue(["Typeset",MathJax.Hub]);</script>
<script src=cc/parse.js></script><script src=cc/commentCloud.js></script></head>
<body onLoad="CommentSetup('g7Ukr5GXnqtS6jqM5gUkSwfY4eyWHxERMkrhurR0','qK1pZ7VXZv8eNtULnMcIzcLy2pIBgvIG9YyO9pu7','Anatomy')">
<div id="header">
<h1 class="title">Anatomy of Programming Languages</h1>
<h2 class="author">William R. Cook</h2>
<h3 class="date">Copyright (C) 2013</h3>
</div>
<div id="TOC">
<ul><li><a href="#preliminaries"><span class="toc-section-number">1</span> Preliminaries</a><ul><li><a href="#preface"><span class="toc-section-number">1.1</span> Preface</a><ul><li><a href="#what"><span class="toc-section-number">1.1.1</span> What?</a></li><li><a href="#why"><span class="toc-section-number">1.1.2</span> Why?</a></li><li><a href="#who"><span class="toc-section-number">1.1.3</span> Who?</a></li></ul></li><li><a href="#introduction"><span class="toc-section-number">1.2</span> Introduction</a></li></ul></li><li><a href="#Chapter1"><span class="toc-section-number">2</span> Expressions, Syntax, and Evaluation</a><ul><li><a href="#simple-language-of-arithmetic"><span class="toc-section-number">2.1</span> Simple Language of Arithmetic</a></li><li><a href="#syntax"><span class="toc-section-number">2.2</span> Syntax</a><ul><li><a href="#abstract-syntax-in-haskell"><span class="toc-section-number">2.2.1</span> Abstract Syntax in Haskell</a></li><li><a href="#concrete-syntax-and-grammars"><span class="toc-section-number">2.2.2</span> Concrete Syntax and Grammars</a></li></ul></li><li><a href="#evaluating-arithmetic-expressions"><span class="toc-section-number">2.3</span> Evaluating Arithmetic Expressions</a><ul><li><a href="#errors"><span class="toc-section-number">2.3.1</span> Errors</a></li></ul></li></ul></li><li><a href="#variables"><span class="toc-section-number">3</span> Variables</a><ul><li><a href="#variable-discussion"><span class="toc-section-number">3.0.1</span> Variable Discussion</a></li><li><a href="#substitution"><span class="toc-section-number">3.1</span> Substitution</a><ul><li><a href="#multiple-substitution-using-environments"><span class="toc-section-number">3.1.1</span> Multiple Substitution using Environments</a></li><li><a href="#local-variables"><span class="toc-section-number">3.1.2</span> Local Variables</a></li><li><a href="#scope"><span class="toc-section-number">3.1.3</span> Scope</a></li><li><a href="#BasicSubst"><span class="toc-section-number">3.1.4</span> Substituting into <code>Let</code> Expressions</a></li><li><a href="#evaluating-let-expressions-using-substitution"><span class="toc-section-number">3.1.5</span> Evaluating <code>Let</code> Expressions using Substitution</a></li><li><a href="#undefined-variable-errors"><span class="toc-section-number">3.1.6</span> Undefined Variable Errors</a></li><li><a href="#summary"><span class="toc-section-number">3.1.7</span> Summary</a></li></ul></li><li><a href="#BasicEvalEnv"><span class="toc-section-number">3.2</span> Evaluation using Environments</a></li><li><a href="#more-kinds-of-data-booleans-and-conditionals"><span class="toc-section-number">3.3</span> More Kinds of Data: Booleans and Conditionals</a><ul><li><a href="#type-errors"><span class="toc-section-number">3.3.1</span> Type Errors</a></li></ul></li></ul></li><li><a href="#functions"><span class="toc-section-number">4</span> Functions</a><ul><li><a href="#top-level-function-definitions"><span class="toc-section-number">4.1</span> Top-Level Function Definitions</a><ul><li><a href="#EvalTopLevel"><span class="toc-section-number">4.1.1</span> Evaluating Top-Level Functions</a></li><li><a href="#stack-diagrams"><span class="toc-section-number">4.1.2</span> Stack Diagrams</a></li><li><a href="#summary-1"><span class="toc-section-number">4.1.3</span> Summary</a></li></ul></li><li><a href="#first-class-functions"><span class="toc-section-number">4.2</span> First-Class Functions</a></li><li><a href="#lambda-notation"><span class="toc-section-number">4.3</span> Lambda Notation</a><ul><li><a href="#LambdaDefinition"><span class="toc-section-number">4.3.1</span> Using Lambdas in Haskell</a></li><li><a href="#function-calls"><span class="toc-section-number">4.3.2</span> Function Calls</a></li></ul></li><li><a href="#FirstClassExamples"><span class="toc-section-number">4.4</span> Examples of First-Class Functions</a><ul><li><a href="#Compose"><span class="toc-section-number">4.4.1</span> Function Composition</a></li><li><a href="#Map"><span class="toc-section-number">4.4.2</span> Mapping</a></li><li><a href="#EnvAsFun"><span class="toc-section-number">4.4.3</span> Representing Environments as Functions</a></li><li><a href="#Curry"><span class="toc-section-number">4.4.4</span> Multiple Arguments and Currying</a></li><li><a href="#church-encodings"><span class="toc-section-number">4.4.5</span> Church Encodings</a></li><li><a href="#relationship-between-let-and-functions"><span class="toc-section-number">4.4.6</span> Relationship between Let and Functions</a></li></ul></li><li><a href="#evaluating-first-class-functions-using-environments"><span class="toc-section-number">4.5</span> Evaluating First-Class Functions using Environments</a><ul><li><a href="#a-non-solution-function-expressions-as-values"><span class="toc-section-number">4.5.1</span> A Non-Solution: Function Expressions as Values</a></li><li><a href="#Closures"><span class="toc-section-number">4.5.2</span> A Correct Solution: Closures</a></li></ul></li><li><a href="#environmentclosure-diagrams"><span class="toc-section-number">4.6</span> Environment/Closure Diagrams</a><ul><li><a href="#example-1"><span class="toc-section-number">4.6.1</span> Example 1</a></li><li><a href="#example-2"><span class="toc-section-number">4.6.2</span> Example 2</a></li><li><a href="#example-3"><span class="toc-section-number">4.6.3</span> Example 3</a></li></ul></li><li><a href="#summary-of-first-class-functions"><span class="toc-section-number">4.7</span> Summary of First-Class Functions</a></li></ul></li><li><a href="#recursive-definitions"><span class="toc-section-number">5</span> Recursive Definitions</a><ul><li><a href="#semantics-of-recursion"><span class="toc-section-number">5.1</span> Semantics of Recursion</a><ul><li><a href="#three-analyses-of-recursion"><span class="toc-section-number">5.1.1</span> Three Analyses of Recursion</a></li></ul></li><li><a href="#Cyclic"><span class="toc-section-number">5.2</span> Understanding Recursion using Haskell Recursion</a><ul><li><a href="#using-results-of-functions-as-arguments"><span class="toc-section-number">5.2.1</span> Using Results of Functions as Arguments</a></li><li><a href="#implementing-recursive-let-with-haskell"><span class="toc-section-number">5.2.2</span> Implementing Recursive <code>Let</code> with Haskell</a></li></ul></li><li><a href="#understanding-recursion-with-fixed-points"><span class="toc-section-number">5.3</span> Understanding Recursion with Fixed Points</a><ul><li><a href="#fixed-points-of-numeric-functions"><span class="toc-section-number">5.3.1</span> Fixed Points of Numeric Functions</a></li><li><a href="#fixed-points-by-iterative-application"><span class="toc-section-number">5.3.2</span> Fixed Points by Iterative Application</a></li><li><a href="#fixed-points-for-recursive-structures"><span class="toc-section-number">5.3.3</span> Fixed Points for Recursive Structures</a></li><li><a href="#fixed-points-of-higher-order-functions"><span class="toc-section-number">5.3.4</span> Fixed Points of Higher-Order Functions</a></li><li><a href="#a-recursive-definition-of-fix"><span class="toc-section-number">5.3.5</span> A Recursive Definition of <code>fix</code></a></li><li><a href="#a-non-recursive-definition-of-fix"><span class="toc-section-number">5.3.6</span> A Non-Recursive Definition of <code>fix</code></a></li></ul></li><li><a href="#understanding-recursion-with-self-application"><span class="toc-section-number">5.4</span> Understanding Recursion with Self-Application</a></li></ul></li><li><a href="#Monads"><span class="toc-section-number">6</span> Computational Strategies</a><ul><li><a href="#error-checking"><span class="toc-section-number">6.1</span> Error Checking</a><ul><li><a href="#error-checking-in-basic-expressions"><span class="toc-section-number">6.1.1</span> Error Checking in Basic Expressions</a></li><li><a href="#error-checking-in-multiple-sub-expressions"><span class="toc-section-number">6.1.2</span> Error Checking in Multiple Sub-expressions</a></li><li><a href="#examples-of-errors"><span class="toc-section-number">6.1.3</span> Examples of Errors</a></li></ul></li><li><a href="#mutable-state"><span class="toc-section-number">6.2</span> Mutable State</a><ul><li><a href="#addresses"><span class="toc-section-number">6.2.1</span> Addresses</a></li><li><a href="#pure-functional-operations-on-memory"><span class="toc-section-number">6.2.2</span> Pure Functional Operations on Memory</a></li><li><a href="#Stateful"><span class="toc-section-number">6.2.3</span> Stateful Computations</a></li><li><a href="#semantics-of-a-language-with-mutation"><span class="toc-section-number">6.2.4</span> Semantics of a Language with Mutation</a></li><li><a href="#summary-of-mutable-state"><span class="toc-section-number">6.2.5</span> Summary of Mutable State</a></li></ul></li><li><a href="#monads-abstract-computational-strategies"><span class="toc-section-number">6.3</span> Monads: Abstract Computational Strategies</a><ul><li><a href="#abstracting-simple-computations"><span class="toc-section-number">6.3.1</span> Abstracting Simple Computations</a></li><li><a href="#abstracting-computation-composition"><span class="toc-section-number">6.3.2</span> Abstracting Computation Composition</a></li><li><a href="#monads-defined"><span class="toc-section-number">6.3.3</span> Monads Defined</a></li></ul></li><li><a href="#monads-in-haskell"><span class="toc-section-number">6.4</span> Monads in Haskell</a><ul><li><a href="#the-monad-type-class"><span class="toc-section-number">6.4.1</span> The Monad Type Class</a></li><li><a href="#haskell-do-notation"><span class="toc-section-number">6.4.2</span> Haskell <code>do</code> Notation</a></li></ul></li><li><a href="#using-haskell-monads"><span class="toc-section-number">6.5</span> Using Haskell Monads</a><ul><li><a href="#monadic-error-checking"><span class="toc-section-number">6.5.1</span> Monadic Error Checking</a></li><li><a href="#monadic-mutable-state"><span class="toc-section-number">6.5.2</span> Monadic Mutable State</a></li></ul></li></ul></li><li><a href="#more-chapters-on-the-way"><span class="toc-section-number">7</span> More Chapters on the way…</a><ul><li><a href="#abstract-interpretation-and-types"><span class="toc-section-number">7.1</span> Abstract Interpretation and Types</a></li><li><a href="#data-abstraction-objects-and-abstract-data-types"><span class="toc-section-number">7.2</span> Data Abstraction: Objects and Abstract Data Types</a></li><li><a href="#algebra-and-coalgebra"><span class="toc-section-number">7.3</span> Algebra and Coalgebra</a></li><li><a href="#partial-evaluation"><span class="toc-section-number">7.4</span> Partial Evaluation</a></li><li><a href="#memory-management"><span class="toc-section-number">7.5</span> Memory Management</a></li></ul></li></ul>
</div>
<h1 id="preliminaries"><a href="#preliminaries"><span class="header-section-number">1</span> Preliminaries</a></h1><h2 id="preface"><a href="#preface"><span class="header-section-number">1.1</span> Preface</a></h2><h3 id="what"><a href="#what"><span class="header-section-number">1.1.1</span> What?</a></h3><p>This document is a series of notes about programming languages, originally written for students of the undergraduate programming languages course at UT. <a href='' id='Comment:What2' ></a></p><h3 id="why"><a href="#why"><span class="header-section-number">1.1.2</span> Why?</a></h3><p>I’m writing these notes because I want to teach the theory of programming languages with a practical focus, but I don’t want to use Scheme (or ML) as the host language. Thus many excellent books do not fit my needs, including <a href="http://cs.brown.edu/~sk/Publications/Books/ProgLangs"><em>Programming Languages: Application and Interpretation</em></a> <span class="citation">(Krishnamurthi 2012)</span>, <a href="http://www.cs.indiana.edu/eopl"><em>Essentials of Programming Languages</em></a> <span class="citation">(Friedman and Wand 2008)</span> or <a href="http://theory.stanford.edu/~jcm/books.html"><em>Concepts in Programming Languages</em></a> <span class="citation">(Mitchell and Apt 2001)</span>. <a href='' id='Comment:Why2' ></a></p><p>This book uses Haskell, a pure functional language. Phil Wadler <span class="citation">(Wadler 1987)</span> gives some good reasons why to prefer Haskell over Scheme in his review of Structure and Interpretation of Computer Programs <span class="citation">(Abelson and Sussman 1996)</span>. I agree with most but not all of his points. For example, I do not care much for the fact that Haskell is lazy. None of the examples in this book rely upon this feature. <a href='' id='Comment:Why3' ></a></p><p>I believe Haskell is particularly well suited to writing interpreters. But one must be careful to read Haskell code as one would read poetry, not the way one would read a romance novel. Ponder each line and extract its deep meaning. Don’t skim unless you are pretty sure what you are doing. <a href='' id='Comment:Why4' ></a></p><p>The title of this book is derived from one of my favorite books, <a href="http://www.amazon.com/Anatomy-Lisp-McGraw-Hill-computer-science/dp/007001115X"><em>The Anatomy of Lisp</em></a> <span class="citation">(Allen 1978)</span>. <a href='' id='Comment:Why5' ></a></p><h3 id="who"><a href="#who"><span class="header-section-number">1.1.3</span> Who?</a></h3><p>These notes assume knowledge of programming, and in particular assume basic knowledge of programming in Haskell. When I teach the course I give a few hours of lectures to introduce Haskell. I teach the built-in data types including lists, the basic syntax for conditionals, function definitions, function calls, list comprehensions, and how to print out strings. I also spend a day on <code>data</code> definitions (algebraic data types) and pattern matching. Finally, I give a quick introduction to type classes so student will understand how <code>Eq</code> and <code>Show</code> work. During the course I teach more advanced topics, including first-class functions and monads. As background resources, I point students to the many excellent tutorials on Haskell. <a href="https://www.google.com/search?q=Haskell+Tutorial">Search Google for “Haskell Tutorial” to find one</a>. I recommend <a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good!</a> or the <a href="http://www.haskell.org/tutorial/">Gentle Introduction To Haskell</a>. <a href='' id='Comment:Who2' ></a></p><h4 id="acknowledgments"><a href="#acknowledgments"><span class="header-section-number">1.1.3.1</span> Acknowledgments</a></h4><p>I thank the students in the spring 2013 semester of CS 345 <em>Programming Languages</em> at the University of Texas at Austin, who helped out while I was writing the book. Special thanks to Jeremy Siek, Chris Roberts and Guy Hawkins for corrections and Aiden Song and Monty Zukowski for careful proofreading. Tyler Allman Young captured notes in class. Chris Cotter improved the makefile and wrote the initial text for some sections. <a href='' id='Comment:Ackn2' ></a></p><h2 id="introduction"><a href="#introduction"><span class="header-section-number">1.2</span> Introduction</a></h2><p>In order to understand programming languages, it is useful to spend some time thinking about <em>languages</em> in general. Usually we treat language like the air we breathe: it is everywhere but it is invisible. I say that language is invisible because we are usually more focused on the message, or the content, that is being conveyed than on the structure and mechanisms of the language itself. Even when we focus on our use of language, for example in writing a paper or a poem, we are still mostly focused on the message we want to convey, while working with (or struggling with) the rules and vocabulary of the language as a given set of constraints. The goal is to work around and avoid problems. A good language is invisible, allowing us to speak and write our intent clearly and creatively. <a href='' id='Comment:Intr2' ></a></p><p>The same is true for programming. Usually we have some important goal in mind when writing a program, and the programming language is a vehicle to achieve the goal. In some cases the language may fail us, by acting as an impediment or obstacle rather than an enabler. The normal reaction in such situations is to work around the problem and move on. <a href='' id='Comment:Intr5' ></a></p><p>The study of language, including the study of programming languages, requires a different focus. We must examine the language itself, as an artifact. What are its rules? What is the vocabulary? How do different parts of the language work together to convey meaning? A user of a language has an implicit understanding of answers to these questions. But to really study language we must create an explicit description of the answers to these questions. <a href='' id='Comment:Intr4' ></a></p><p>The concepts of structure and meaning have technical names. The structure of a language is called its <em>syntax</em>. The rules that defined the meaning of a language are called <em>semantics</em>. Syntax is a particular way to structure information, while semantics can be viewed as a mapping from syntax to its meaning, or interpretation. The meaning of a program is usually some form of behavior, because programs <em>do</em> things. Fortunately, as programmers we are adept at describing the structure of information, and at creating mappings between different kinds of information and behaviors. This is what data structures and functions/procedures are for. <a href='' id='Comment:Intr6' ></a></p><p>Thus the primary technique in these notes is to use programming to study programming languages. In other words, we will write programs to represent and manipulate programs. One general term for this activity is <em>metaprogramming</em>. A metaprogram is any program whose input or output is a program. Familiar examples of metaprograms include compilers, interpreters, virtual machines. In this course we will read, write and discuss many metaprograms. <a href='' id='Comment:Intr7' ></a></p><h1 id="Chapter1"><a href="#Chapter1"><span class="header-section-number">2</span> Expressions, Syntax, and Evaluation</a></h1><p>TODO:introduction to these concepts!! <a href='' id='Comment:Expr1' ></a></p><h2 id="simple-language-of-arithmetic"><a href="#simple-language-of-arithmetic"><span class="header-section-number">2.1</span> Simple Language of Arithmetic</a></h2><p>A good place to start is analyzing the language of arithmetic, which is familiar to every grade-school child. <a href='' id='Comment:Simp2' ></a></p><pre class="sourceCode Java"><code class="sourceCode java"><span class="dv">4</span>
-<span class="dv">5+6</span>
<span class="dv">3</span>--<span class="dv">2</span>--<span class="dv">7</span>
<span class="dv">3</span>*(<span class="dv">8+5</span>)
<span class="dv">1</span>+(<span class="dv">8</span>*<span class="dv">2</span>)
<span class="dv">1+8</span>*<span class="dv">2</span>
<a href='' id='Comment:Simp3' ></a></code></pre><p>These are examples of arithmetic <em>expressions</em>. The rules for understanding such expressions are surprisingly complex. For example, in the third expression the first and third minus signs (<span class="math">\(-\)</span>) mean subtraction, while the second and fourth mean that the following number is negative. The last two examples mean the same thing, because of the rule that multiplication must be performed before addition. The third expression is potentially confusing, even given knowledge of the rules for operations. It means <span class="math">\((3 - (-2)) - (-7)\)</span> not <span class="math">\(3 - ((-2) - (-7))\)</span> because subtraction operations are performed left to right. <a href='' id='Comment:Simp4' ></a></p><p>Part of the problem here is that there is a big difference between our conceptual view of what is going on in arithmetic and our conventions for expressing arithmetic expressions in written form. In other words, there isn’t any confusion about what negative number are or what subtraction or exponentiation do, but there is room for confusion about how to write them down. <a href='' id='Comment:Simp5' ></a></p><p>The conceptual structure of a given expression can be defined much more clearly using pictures. For example, the following pictures make a clear description of the underlying arithmetic operations specified in the expressions given above: <a href='' id='Comment:Simp6' ></a></p><p><embed src="figures/abstract_syntax.png" /> <a href='' id='Comment:Simp7' ></a></p><p>These pictures are similar to <em>sentence diagramming</em> that is taught in grade school to explain the structure of English. <a href='' id='Comment:Simp1' ></a></p><p>The last picture represents the last two expressions in the previous example. This is because the pictures do not need parentheses, since the grouping structure is explicit. <a href='' id='Comment:Simp8' ></a></p><h2 id="syntax"><a href="#syntax"><span class="header-section-number">2.2</span> Syntax</a></h2><p>The conceptual structure (illustrated by the pictures) is called the <em>abstract syntax</em> of the language. The particular details and rules for writing expressions as strings of characters is called the <em>concrete syntax</em>. The abstract syntax for arithmetic expressions is very simple, while the concrete syntax is quite complex. To make these concepts more precise, we show how to represent abstract syntax as a data structure, and how to define a <em>parser</em>, which converts from the concrete written form to the abstract syntax. <a href='' id='Comment:Simp9' ></a></p><h3 id="abstract-syntax-in-haskell"><a href="#abstract-syntax-in-haskell"><span class="header-section-number">2.2.1</span> Abstract Syntax in Haskell</a></h3><p>This section describes how to represent abstract syntax using Haskell. The code for this section is found in the <a href="./code/Simple.hs.htm">Simple</a> file. Arithmetic expressions can be represented in Haskell with the following data type: <a href='' id='Comment:Abst2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Number</span>     <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">Add</span>        <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Subtract</span>   <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Multiply</span>   <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Divide</span>     <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="co">-- <a href='' id='Comment:Abst3' ></a></span></code></pre><p>This data type defines five representational variants, one for numbers, and four for the the binary operators of addition, subtraction, multiplication, and division. The symbols <code>Number</code>, <code>Add</code>, <code>Subtract</code> etc are the <em>constructors</em> of the data type. The types that follow the constructors are the components of the data type. Thus a <code>Number</code> expression has an integer component, while the other constructors all have two expression compoents. A number that appears in a program is called a <em>literal</em>. <a href='' id='Comment:Abst4' ></a></p><p>The five examples given above can be written as values of type <code>Exp</code> to create five test cases: <a href='' id='Comment:Abst5' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- 4</span>
t1 <span class="fu">=</span> <span class="dt">Number</span> <span class="dv">4</span>
<span class="co">-- <a href='' id='Comment:Abst1' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- -5 + 6</span>
t2 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">Number</span> (<span class="fu">-</span><span class="dv">5</span>)) (<span class="dt">Number</span> <span class="dv">6</span>)
<span class="co">-- <a href='' id='Comment:Abst6' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- 3 - -2 - -7</span>
t3 <span class="fu">=</span> <span class="dt">Subtract</span> (<span class="dt">Subtract</span> (<span class="dt">Number</span> <span class="dv">3</span>) (<span class="dt">Number</span> (<span class="fu">-</span><span class="dv">2</span>))) (<span class="dt">Number</span> (<span class="fu">-</span><span class="dv">7</span>))
<span class="co">-- <a href='' id='Comment:Abst15' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- 3 * (8 + 5)</span>
t4 <span class="fu">=</span> <span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">3</span>) (<span class="dt">Add</span> (<span class="dt">Number</span> <span class="dv">8</span>) (<span class="dt">Number</span> <span class="dv">5</span>))
<span class="co">-- <a href='' id='Comment:Abst16' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- 1 + 8 * 2</span>
t5 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">Number</span> <span class="dv">1</span>) (<span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">8</span>) (<span class="dt">Number</span> <span class="dv">2</span>))
<span class="co">-- <a href='' id='Comment:Abst17' ></a></span></code></pre><p>Each test case is preceded by a comment giving the concise notation for the corresponding expression. NOTE: It is not legal to write <code>Add (-4) 6</code> because <code>-4</code> and <code>6</code> are of type <code>Int</code> not <code>Exp</code>. Also, Haskell requires parentheses around negative numbers, for some reason. <a href='' id='Comment:Abst7' ></a></p><p>Writing abstract syntax directly in Haskell is certainly very ugly. There is approximately a 10-fold expansion in the number of characters needed to represent a concept: a 5-character mathematical expression <code>1 + 8 * 2</code> uses 47 characters to create the corresponding Haskell data structure. This is not a defect of Haskell, it is merely because we haven’t developed a way to convert concrete syntax into abstract syntax. <a href='' id='Comment:Abst8' ></a></p><h3 id="concrete-syntax-and-grammars"><a href="#concrete-syntax-and-grammars"><span class="header-section-number">2.2.2</span> Concrete Syntax and Grammars</a></h3><p>The concrete syntax of a language describes how the abstract concepts in the language are represented as text. For example, lets consider how to convert the string “3+81*2” into the abstract syntax <code>Add (Number 3) (Multiply (Number 81) (Number 2))</code>. The first step is to break a text up into <em>tokens</em>. <a href='' id='Comment:Conc1' ></a></p><h4 id="tokens"><a href="#tokens"><span class="header-section-number">2.2.2.1</span> Tokens</a></h4><p>Tokens are the basic units of a language. In English, for example, words are tokens. But English also uses many symbol tokens, including “.”, “!”, “?”, “(” and “)”. In the example “3 + 81 * 2” the tokens are 3, “+”, 81, “*”, and 2. It is also important to classify tokens by their kind. The tokens 3, 81 and 2 are sequences of digits. The tokens “+” and “*” are <em>symbol</em> tokens. Tokens are typically as simple as possible, and they must be recognizable without considering any context. This means that the integer “-23” might not be a good token, because it contains the symbol “-”, which is also used in other contexts. <a href='' id='Comment:Toke2' ></a></p><p>More complex languages may have other kinds of tokens (other common kinds of token are <em>keyword</em> and <em>identifer</em> tokens, which are discussed later in the book). <a href='' id='Comment:Toke1' ></a> Token kinds are similar to the kinds of words in English, where some words are <em>verbs</em> and other words are <em>nouns</em>. <a href='' id='Comment:Toke3' ></a></p><p>The following data structure is useful for representing basic tokens. <a href='' id='Comment:Toke4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Token</span> <span class="fu">=</span> <span class="dt">Digits</span> <span class="dt">Int</span>
           <span class="fu">|</span> <span class="dt">Symbol</span> <span class="dt">String</span>
<span class="co">-- <a href='' id='Comment:BasicToken' ></a></span></code></pre><p>A <code>Token</code> is either an integer token or a symbol token with a string. For example, the tokens from the string “3 + 81 * 2” are: <a href='' id='Comment:Toke6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Digits</span> <span class="dv">3</span>
<span class="dt">Symbol</span> <span class="st">&quot;+&quot;</span>
<span class="dt">Digits</span> <span class="dv">81</span>
<span class="dt">Symbol</span> <span class="st">&quot;*&quot;</span>
<span class="dt">Digits</span> <span class="dv">2</span>
<span class="co">-- <a href='' id='Comment:Toke7' ></a></span></code></pre><p>The <a href="./code/Lexer.hs.htm">Lexer</a> file contains the code for a simple lexer that creates tokens in this form. It defines a function <code>lexer</code> that transforms a string (i.e. a list of characters) into a list of tokens.</p><p>The section describes how to create simple grammars using the <a href="http://www.haskell.org/happy/">Happy Parser Generator</a>. <a href='' id='Comment:Pars1' ></a></p><h4 id="grammars"><a href="#grammars"><span class="header-section-number">2.2.2.2</span> Grammars</a></h4><p>A <em>grammar</em> is a set of rules that specify how tokens can be placed together to form valid expressions of a language. To create a grammar, it is essential to identify and <em>name</em> the different parts of the language. For example, in English there are many different parts, including <em>verb</em>, <em>noun</em>, <em>gerund</em>, <em>prepositional phrase</em>, <em>declarative sentence</em>, etc. Technically, the parts of a language are called <em>syntactic categories</em>.</p><p>It is certainly possible to be a fluent English speaker without any explicit awareness of the rules of English or the names of the syntactic categories. How many people can identify a gerund? But understanding syntactic categories is useful for studying a language. Creating a complete syntax of English is quite difficult, and irrelevant to the purpose of this book. But defining a grammar for a (very) small fragment of English is useful to illustrate how grammars work. <a href='' id='Comment:Gram1' ></a> Here is a simple grammar:</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Sentence</span> <span class="fu">:</span> <span class="dt">Noun</span> <span class="dt">Verb</span> <span class="fu">|</span> <span class="dt">Sentence</span> <span class="dt">PrepositionalPhase</span>
<span class="dt">PrepositionalPhase</span> <span class="fu">:</span> <span class="dt">Prep</span> <span class="dt">Noun</span>
<span class="dt">Noun</span> <span class="fu">:</span> <span class="ch">&#39;Dick&#39;</span> <span class="fu">|</span> <span class="ch">&#39;Jane&#39;</span> <span class="fu">|</span> <span class="ch">&#39;Spot&#39;</span>
<span class="dt">Verb</span> <span class="fu">:</span> <span class="ch">&#39;runs&#39;</span> <span class="fu">|</span> <span class="ch">&#39;talks&#39;</span>
<span class="dt">Preposition</span> <span class="fu">:</span> <span class="ch">&#39;to&#39;</span> <span class="fu">|</span> <span class="ch">&#39;with&#39;</span></code></pre><p>The names <code>Sentence</code>, <code>PrepositionalPhase</code>, <code>Noun</code>, <code>Verb</code>, and <code>Preposition</code> are the syntactic categories of this grammar. Each line of the grammar is a <em>rule</em> that specifies a syntactic category, followed by a colon (:) and then sequence of alternative forms for that syntactic category. The words in quotes, including <code>Dick</code>, <code>Jane</code>, and <code>Runs</code> are the tokens of the language.</p><p>Here is a translation of the grammar into English:</p><ul><li>a <em>sentence</em> is either:<ul><li>a <em>noun</em> followed by a <em>verb</em>, or</li><li>a <em>sentence</em> followed by a <em>prepositional phase</em></li></ul></li><li>a <em>prepositional phase</em> is a <em>preposition</em> followed by a <em>noun</em></li><li>a <em>noun</em> is one of “Dick”, “Jane”, or “Spot”</li><li>a <em>verb</em> is either “tuns” or “talks”</li><li>a <em>preposition</em> is either “to” or “with”</li></ul><p>Some sentences in the language defined by this grammar are:</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Dick</span> talks
<span class="dt">Jane</span> runs
<span class="dt">Dick</span> runs with <span class="dt">Spot</span>
<span class="dt">Dick</span> runs to <span class="dt">Jane</span> with <span class="dt">Spot</span>
<span class="dt">Spot</span> runs to <span class="dt">Jane</span> to <span class="dt">Dick</span> to <span class="dt">Jane</span> to <span class="dt">Dick</span></code></pre><p>There are also some sentences that don’t make much sense:</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Dick</span> talks with <span class="dt">Dick</span>
<span class="dt">Jane</span> runs to <span class="dt">Jane</span> to <span class="dt">Jane</span> to <span class="dt">Jane</span> to <span class="dt">Jane</span></code></pre><p>These sentences are <em>syntactically correct</em> because they follow the pattern specified by the grammar, but that doesn’t ensure that they are meaningful.</p><p>Note: computer science literature, ‘syntactic categories’ are often called <em>nonterminals</em> while tokens are called <em>terminals</em>. This comes from the idea that a grammar can be viewed as generating sentences by replacing the left side with the right side. As long as the resulting sentence still has syntactic categories that haven’t been replaced by real words, the process is not done (not terminated).</p><h4 id="grammar-actions-and-construction-of-abstract-syntax"><a href="#grammar-actions-and-construction-of-abstract-syntax"><span class="header-section-number">2.2.2.3</span> Grammar Actions and Construction of Abstract Syntax</a></h4><p>In addition to specifying the set of legal sentences, a grammar can also specify the meaning of those sentences. Rather than try to specify a meaning for English, here is a simple grammar for arithmetic expressions, which has been annotated to specify the meaning that should be associated with each pattern in the grammar:</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Exp</span> <span class="fu">:</span> digits        { <span class="dt">Number</span> <span class="fu">$</span><span class="dv">1</span> }
    <span class="fu">|</span> <span class="ch">&#39;-&#39;</span> digits    { <span class="dt">Number</span> (<span class="fu">-</span> <span class="fu">$</span><span class="dv">2</span>) }
    <span class="fu">|</span> <span class="dt">Exp</span> <span class="ch">&#39;+&#39;</span> <span class="dt">Exp</span>   { <span class="dt">Add</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
    <span class="fu">|</span> <span class="dt">Exp</span> <span class="ch">&#39;-&#39;</span> <span class="dt">Exp</span>   { <span class="dt">Subtract</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
    <span class="fu">|</span> <span class="dt">Exp</span> <span class="ch">&#39;*&#39;</span> <span class="dt">Exp</span>   { <span class="dt">Multiply</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
    <span class="fu">|</span> <span class="dt">Exp</span> <span class="ch">&#39;/&#39;</span> <span class="dt">Exp</span>   { <span class="dt">Divide</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
    <span class="fu">|</span> <span class="ch">&#39;(&#39;</span> <span class="dt">Exp</span> <span class="ch">&#39;)&#39;</span>   { <span class="fu">$</span><span class="dv">2</span> }
<span class="co">-- <a href='' id='Comment:Gram5' ></a></span></code></pre><p>This grammar is similar to the one given above for English, but each rule includes an <em>action</em> enclosed in curly braces <code>{...}</code>. The action says what should happen when that rule is recognized. In this case, the action is some Haskell code with calls to <em>constructors</em> to create the abstract syntax that corresponds to the concrete syntax of the rule. The special syntax <code>$n</code> in an action means that the value of the <code>n</code><em>th</em> item in the grammar rule should be used in the action. For example, in the last rule the <code>$2</code> refers to the second item in the parenthesis rule, which is <code>Exp</code>.</p><p>Written out explicitly, this grammar means:</p><ul><li>An <em>expression</em> Exp is either<ul><li>a digit token<ul><li>which creates a <code>Number</code> with the integer value of the digits</li></ul></li><li>a minus sign followed by a digits token<ul><li>which creates a <code>Number</code> with the negative of the integer value of the digits</li></ul></li><li>an expression followed by a <code>+</code> followed by an expression<ul><li>which creates an <code>Add</code> node containing the value of the expressions</li></ul></li><li>an expression followed by a <code>-</code> followed by an expression<ul><li>which creates a <code>Subtract</code> node containing the value of the expressions</li></ul></li><li>an expression followed by a <code>*</code> followed by an expression<ul><li>which creates a <code>Multiply</code> node containing the value of the expressions</li></ul></li><li>an expression followed by a <code>/</code> followed by an expression<ul><li>which creates a <code>Divide</code> node containing the value of the expressions</li></ul></li></ul></li></ul><p>Given this lengthy and verbose explanation, I hope you can see the value of using a more concise notation!</p><p>Just like other kinds of software, there are many design decisions that must be made in creating a grammar. Some grammars work better than others, depending on the situation.</p><h4 id="ambiguity-precedence-and-associativity"><a href="#ambiguity-precedence-and-associativity"><span class="header-section-number">2.2.2.4</span> Ambiguity, Precedence and Associativity</a></h4><p>One problem with the straightforward grammar is allows for <em>ambiguity</em>. A sentence is ambiguous if there is more than one that it can be derived by a grammar. For example, the expression <code>1-2-3</code> is ambiguous because it can be parsed in two ways to create two different abstract syntax trees [TODO: define “parse”]:</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Subtract</span> (<span class="dt">Number</span> <span class="dv">1</span>) (<span class="dt">Subtract</span> (<span class="dt">Number</span> <span class="dv">2</span>) (<span class="dt">Number</span> <span class="dv">3</span>))
<span class="dt">Subtract</span> (<span class="dt">Subtract</span> (<span class="dt">Number</span> <span class="dv">1</span>) (<span class="dt">Number</span> <span class="dv">2</span>)) (<span class="dt">Number</span> <span class="dv">3</span>)</code></pre><p>TODO: show the parse trees? define “parse tree”</p><p>The same abstract syntax can be generated by parsing <code>1-(2-3)</code> and <code>(1-2)-3</code>. We know from our training that the first one is the “correct” version, because subtraction operatations are perfomed left to write. The technical term for this is that subtraction is <em>left associative</em>. (note that this use of the associative is not the same as the mathematical concept of associativity.) But the grammar as its written doesn’t contain any information associativity, so it is ambiguous.</p><p>Similarly, the expression <code>1-2*3</code> can be parsed in two ways:</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Subtract</span> (<span class="dt">Number</span> <span class="dv">1</span>) (<span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">2</span>) (<span class="dt">Number</span> <span class="dv">2</span>))
<span class="dt">Multiply</span> (<span class="dt">Subtract</span> (<span class="dt">Number</span> <span class="dv">1</span>) (<span class="dt">Number</span> <span class="dv">2</span>)) (<span class="dt">Number</span> <span class="dv">2</span>)</code></pre><p>The same abstract syntax can be generated by parsing <code>1-(2*3)</code> and <code>(1-2)*3</code>. Again we know that the first version is the correct one, because multiplication should be performed before subtraction. Technically, we say that multiplication has higher <em>precedence</em> than subtraction.</p><p>The grammar can be ajusted to express the precedence and associativity of the operators. Here is an example:</p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Term</span> <span class="fu">:</span> <span class="dt">Term</span> <span class="ch">&#39;+&#39;</span> <span class="dt">Factor</span>    { <span class="dt">Add</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
     <span class="fu">|</span> <span class="dt">Term</span> <span class="ch">&#39;-&#39;</span> <span class="dt">Factor</span>    { <span class="dt">Subtract</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
     <span class="fu">|</span> <span class="dt">Factor</span>             { <span class="fu">$</span><span class="dv">1</span> }

<span class="dt">Factor</span> <span class="fu">:</span> <span class="dt">Factor</span> <span class="ch">&#39;*&#39;</span> <span class="dt">Primary</span>    { <span class="dt">Multiply</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
       <span class="fu">|</span> <span class="dt">Factor</span> <span class="ch">&#39;/&#39;</span> <span class="dt">Primary</span>    { <span class="dt">Divide</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
       <span class="fu">|</span> <span class="dt">Primary</span>               { <span class="fu">$</span><span class="dv">1</span> }

<span class="dt">Primary</span> <span class="fu">:</span> digits         { <span class="dt">Number</span> <span class="fu">$</span><span class="dv">1</span> }
        <span class="fu">|</span> <span class="ch">&#39;-&#39;</span> digits     { <span class="dt">Number</span> (<span class="fu">-</span> <span class="fu">$</span><span class="dv">2</span>) }
        <span class="fu">|</span> <span class="ch">&#39;(&#39;</span> <span class="dt">Term</span> <span class="ch">&#39;)&#39;</span>   { <span class="fu">$</span><span class="dv">2</span> }
<span class="co">-- <a href='' id='Comment:SimpleGrammar' ></a></span></code></pre><p>TODO: talk about meta language: language of study versus language of implementation. Better words? <a href='' id='Comment:Abst10' ></a></p><h2 id="evaluating-arithmetic-expressions"><a href="#evaluating-arithmetic-expressions"><span class="header-section-number">2.3</span> Evaluating Arithmetic Expressions</a></h2><p>The normal meaning assigned to arithmetic expressions is the evaluation of the arithmetic operators to compute a final answer. This evaluation process is defined by cases in Haskell: <a href='' id='Comment:Eval2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
evaluate (<span class="dt">Number</span> i)      <span class="fu">=</span> i
evaluate (<span class="dt">Add</span> a b)       <span class="fu">=</span> evaluate a <span class="fu">+</span> evaluate b
evaluate (<span class="dt">Subtract</span> a b)  <span class="fu">=</span> evaluate a <span class="fu">-</span> evaluate b
evaluate (<span class="dt">Multiply</span> a b)  <span class="fu">=</span> evaluate a <span class="fu">*</span> evaluate b
evaluate (<span class="dt">Divide</span> a b)    <span class="fu">=</span> evaluate a <span class="ot">`div`</span> evaluate b
<span class="co">-- <a href='' id='Comment:Eval3' ></a></span></code></pre><p>In Haskell, the two-argument function <code>div</code> can be used as an infix operator by surrounding it in back-quotes. Here is a main program that tests evaluation: <a href='' id='Comment:Eval4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Evaluating the following expression:&quot;</span>
  putStr <span class="st">&quot;  &quot;</span>
  print t3
  putStrLn <span class="st">&quot;Produces the following result:&quot;</span>
  putStr <span class="st">&quot;  &quot;</span>
  print (evaluate t3)
<span class="co">-- <a href='' id='Comment:Eval5' ></a></span></code></pre><p>The output is <a href='' id='Comment:Eval6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- <a href='' id='Comment:Eval7' ></a></span></code></pre><p>This looks pretty good, except that that it prints out the abstract syntax rather than the more attractive concrete syntax. <a href='' id='Comment:Eval8' ></a></p><p>FOO: Explain Show <a href='' id='Comment:Test1' ></a></p><p>To test many different kinds of functions, it is useful to define a generalized test function. <a href='' id='Comment:Form5' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">test msg fun input <span class="fu">=</span> <span class="kw">do</span> 
    putStrLn (msg <span class="fu">++</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> groom input <span class="fu">++</span> <span class="st">&quot;)&quot;</span>)
    putStr <span class="st">&quot; ==&gt; &quot;</span>
    putStrLn (groom (fun input)) <span class="ot">`catch`</span> showError
    putStrLn <span class="st">&quot;&quot;</span>
<span class="co">-- <a href='' id='Comment:Form6' ></a></span></code></pre><p>The <code>test</code> function takes a function and an input as arguments. It prints the input and then prints the result of applying the function to the input. The following main program invokes <code>test</code> to evaluate each of the five sample expressions defined above: <a href='' id='Comment:Form7' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  test <span class="st">&quot;evaluate&quot;</span> evaluate t1
  test <span class="st">&quot;evaluate&quot;</span> evaluate t2
  test <span class="st">&quot;evaluate&quot;</span> evaluate t3
  test <span class="st">&quot;evaluate&quot;</span> evaluate t4
  test <span class="st">&quot;evaluate&quot;</span> evaluate t5
<span class="co">-- <a href='' id='Comment:Form8' ></a></span></code></pre><p>Running this main program produces the following results: <a href='' id='Comment:Form9' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- <a href='' id='Comment:Form12' ></a></span></code></pre><h3 id="errors"><a href="#errors"><span class="header-section-number">2.3.1</span> Errors</a></h3><p>There are many things that can go wrong when evaluating an expression. In our current, very simple language, the only error that can arise is attempting to divide by zero. These examples are given in the <a href="./code/SimpleTest.hs.htm">Simple Examples</a> file. For example, consider this small expression: <a href='' id='Comment:Erro2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Divide</span> (<span class="dt">Number</span> <span class="dv">8</span>) (<span class="dt">Number</span> <span class="dv">0</span>))
<span class="co">-- <a href='' id='Comment:Erro3' ></a></span></code></pre><p>In this case, the <code>div</code> operator in Haskell throws a low-level error, which terminates execution of the program and prints an error message: <a href='' id='Comment:Erro4' ></a></p><pre><code>*** Exception: divide by zero
<a href='' id='Comment:Erro5' ></a></code></pre><p>As our language becomes more complex, there will be many more kinds of errors that can arise. For now, we will rely on Haskell to terminate the program when these situations arise, but in <a href="#Monads">Chapter 5</a> we will investigate how to manage errors within our evaluator. <a href='' id='Comment:Erro6' ></a></p><h1 id="variables"><a href="#variables"><span class="header-section-number">3</span> Variables</a></h1><p>Arithmetic expressions often contain variables in addition to constants. In grade school the first introduction to variables is usually to evaluate an expression where a variable has a specific value. For example, young students learn to evaluate <span class="math">\(x+2\)</span> where <span class="math">\(x=5\)</span>. The rule is to substitute every occurrence of <span class="math">\(x\)</span> with the value <span class="math">\(5\)</span> and the perform the required arithmetic computations. <a href='' id='Comment:Vari2' ></a></p><p>To program this in Haskell, the first thing needed is to extend the abstract syntax of expressions to include variables. Since the name of a variable “x” can be represented as a string of characters, it is easy to represent variables as an additional kind of expression. The code for the section is given in the <a href="./code/Substitute.hs.htm">Substitute</a> file. The following data definition modifies <code>Exp</code> to include a <code>Variable</code> case. <a href='' id='Comment:Vari3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Number</span>   <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">Add</span>      <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Subtract</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Multiply</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Divide</span>   <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Variable</span> <span class="dt">String</span>        <span class="co">-- added</span>
   <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)
<span class="co">-- <a href='' id='Comment:Vari99' ></a></span></code></pre><p>An association of a variable <span class="math">\(x\)</span> with a value <span class="math">\(v\)</span> is called a <em>binding</em>, which can be written <span class="math">\(x \mapsto v\)</span>. Bindings can be represented in Haskell as a pair. For example, the binding of <span class="math">\(x \mapsto 5\)</span> can be represented as <code>(&quot;x&quot;, 5)</code>. <a href='' id='Comment:Vari5' ></a></p><h3 id="variable-discussion"><a href="#variable-discussion"><span class="header-section-number">3.0.1</span> Variable Discussion</a></h3><p>We are used to calling <span class="math">\(x\)</span> and <span class="math">\(y\)</span> “variables” without really thinking much about what it means to be a “variable”. Intuitively a variable is something that varies. But what does it mean for a name <span class="math">\(x\)</span> to vary? My view on this is that we call them variables because they can have different values in different contexts. For example, the equation <span class="math">\(\pi r^2\)</span> defines a relationship between several variables, but in the context of a particular word problem, the radius <span class="math">\(r\)</span> has a particular value. In any particular context, a variable does <em>not</em> vary or change. It has exactly one value that is fixed and constant within that context. A variable can be bound to different values in different contexts, but in a given context the binding of a variable is fixed. In the examples above, the context is indicated by the phrase “where <span class="math">\(x=5\)</span>”. The same expression, <span class="math">\(x+2\)</span> can be evaluated in different contexts, for example, where <span class="math">\(x=7\)</span>. <a href='' id='Comment:Vari1' ></a></p><p>This interplay between being constant and being variable can be quite confusing, especially since variables in most programming languages <em>can change</em> over time. The process of actually changing a variable’s value over time, within a single context, is called <em>mutation</em>. This seems to be a major difference between programming language variables and mathematical variables. However, if you think about things in a slightly different way then it is possible to unify these two apparently conflicting meanings for “variable”. As a preview, we will keep the idea of variables having a fixed binding, but introduce the concept of a <em>mutable container</em> that can change over time. The variable will then be bound to the container. The variable’s binding will not change (it will remain bound to the same container), but the contents of the container will change. <a href='' id='Comment:Vari6' ></a></p><p>Mutable variables are discussed in detail later (TODO: reference). For now, just remember that a variable has a fixed binding to a value in a given context. <a href='' id='Comment:Vari7' ></a></p><p>Note that another common use for variables is to define <em>equations</em> or <em>constraints</em>. In this case, it is normal to use algebraic operations to simplify or <em>solve</em> the equation to find a value for the variable that satisfies the equation. While equation solving and constraints are fascinating topics, we will not discuss them directly in these notes. For our purposes, we will assume that we already know the value of the variable, and that the problem is to compute a result using that value. <a href='' id='Comment:Vari8' ></a></p><h2 id="substitution"><a href="#substitution"><span class="header-section-number">3.1</span> Substitution</a></h2><p>Substitution replaces a variable with a value in an expression. Here are some examples of substitution: <a href='' id='Comment:Subs2' ></a></p><ul><li>substitute <span class="math">\(x \mapsto 5\)</span> in <span class="math">\(x + 2\)</span> <span class="math">\(\longrightarrow\)</span> <span class="math">\(5 + 2\)</span> <a href='' id='Comment:Subs3' ></a></li><li>substitute <span class="math">\(x \mapsto 5\)</span> in <span class="math">\(2\)</span> <span class="math">\(\longrightarrow\)</span> <span class="math">\(2\)</span> <a href='' id='Comment:Subs4' ></a></li><li>substitute <span class="math">\(x \mapsto 5\)</span> in <span class="math">\(x\)</span> <span class="math">\(\longrightarrow\)</span> <span class="math">\(5\)</span> <a href='' id='Comment:Subs5' ></a></li><li>substitute <span class="math">\(x \mapsto 5\)</span> in <span class="math">\(x * x + x\)</span> <span class="math">\(\longrightarrow\)</span> <span class="math">\(5 * 5 + 5\)</span> <a href='' id='Comment:Subs6' ></a></li><li>substitute <span class="math">\(x \mapsto 5\)</span> in <span class="math">\(x + y\)</span> <span class="math">\(\longrightarrow\)</span> <span class="math">\(5 + y\)</span> <a href='' id='Comment:Subs7' ></a></li></ul><p>Note that if the variable names don’t match, they are left alone. Given these data types, the process of <em>substitution</em> can be defined by cases. The following Haskell function implements this behavior: <a href='' id='Comment:Subs8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">substitute1::</span> (<span class="dt">String</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
substitute1 (var, val) exp <span class="fu">=</span> subst exp <span class="kw">where</span>
  subst (<span class="dt">Number</span> i)      <span class="fu">=</span> <span class="dt">Number</span> i
  subst (<span class="dt">Add</span> a b)       <span class="fu">=</span> <span class="dt">Add</span> (subst a) (subst b)
  subst (<span class="dt">Subtract</span> a b)  <span class="fu">=</span> <span class="dt">Subtract</span> (subst a) (subst b)
  subst (<span class="dt">Multiply</span> a b)  <span class="fu">=</span> <span class="dt">Multiply</span> (subst a) (subst b)
  subst (<span class="dt">Divide</span> a b)    <span class="fu">=</span> <span class="dt">Divide</span> (subst a) (subst b)
  subst (<span class="dt">Variable</span> name) <span class="fu">=</span> <span class="kw">if</span> var <span class="fu">==</span> name
                          <span class="kw">then</span> <span class="dt">Number</span> val
                          <span class="kw">else</span> <span class="dt">Variable</span> name
<span class="co">-- <a href='' id='Comment:Subs9' ></a></span></code></pre><p>The <code>subst</code> helper function is introduced avoid repeating the <code>var</code> and <code>val</code> parameters for each of the specific cases of substitution. The <code>var</code> and <code>val</code> parameters are the same for all substitutions within an expression. <a href='' id='Comment:Subs19' ></a></p><p>The first case says that substituting a variable for a value in a literal expression leaves the literal unchanged. The next three cases define substitution on binary operators as recursively substituting into the sub-expressions of the operator. The final case is the only interesting one. It defines substitution into a <code>Variable</code> expression as a choice: if the variable in the expression (<code>name</code>) is the <em>same</em> as the variable being substituted (<code>var</code>) then the value is <a href='' id='Comment:Subs10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>
y <span class="fu">=</span> <span class="dt">Variable</span> <span class="st">&quot;y&quot;</span>
main <span class="fu">=</span> <span class="kw">do</span>
  test <span class="st">&quot;substitute (\&quot;x\&quot;, 5)&quot;</span> (substitute1 (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>)) (<span class="dt">Add</span> x (<span class="dt">Number</span> <span class="dv">2</span>))
  test <span class="st">&quot;substitute (\&quot;x\&quot;, 5)&quot;</span> (substitute1 (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>)) (<span class="dt">Number</span> <span class="dv">2</span>)
  test <span class="st">&quot;substitute (\&quot;x\&quot;, 5)&quot;</span> (substitute1 (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>)) x
  test <span class="st">&quot;substitute (\&quot;x\&quot;, 5)&quot;</span> (substitute1 (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>)) (<span class="dt">Add</span> (<span class="dt">Multiply</span> x x) x)
  test <span class="st">&quot;substitute (\&quot;x\&quot;, 5)&quot;</span> (substitute1 (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>)) (<span class="dt">Add</span> x y)
<span class="co">-- <a href='' id='Comment:Subs11' ></a></span></code></pre><p>Running these tests produces the following results: <a href='' id='Comment:Subs12' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">substitute (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>) (<span class="dt">Add</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Number</span> <span class="dv">2</span>))
 <span class="fu">==&gt;</span> <span class="dt">Add</span> (<span class="dt">Number</span> <span class="dv">5</span>) (<span class="dt">Number</span> <span class="dv">2</span>)

substitute (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>) (<span class="dt">Number</span> <span class="dv">2</span>)
 <span class="fu">==&gt;</span> <span class="dt">Number</span> <span class="dv">2</span>

substitute (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>) (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)
 <span class="fu">==&gt;</span> <span class="dt">Number</span> <span class="dv">5</span>

substitute (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>) (<span class="dt">Add</span> (<span class="dt">Multiply</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>))
 <span class="fu">==&gt;</span> <span class="dt">Add</span> (<span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">5</span>) (<span class="dt">Number</span> <span class="dv">5</span>)) (<span class="dt">Number</span> <span class="dv">5</span>)

substitute (<span class="st">&quot;x&quot;</span>, <span class="dv">5</span>) (<span class="dt">Add</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Variable</span> <span class="st">&quot;y&quot;</span>))
 <span class="fu">==&gt;</span> <span class="dt">Add</span> (<span class="dt">Number</span> <span class="dv">5</span>) (<span class="dt">Variable</span> <span class="st">&quot;y&quot;</span>)

<span class="co">-- <a href='' id='Comment:Subs13' ></a></span></code></pre><p>It is important to keep in mind that there are now two stages for evaluating an expression containing a variable. The first stage is to <em>substitute</em> the variable for its value, then the second stage is to <em>evaluate</em> the resulting arithmetic expression. <a href='' id='Comment:Subs14' ></a></p><p>TODO: talk about <em>renaming</em> variables, or substituting one variable for another <a href='' id='Comment:Subs15' ></a></p><h3 id="multiple-substitution-using-environments"><a href="#multiple-substitution-using-environments"><span class="header-section-number">3.1.1</span> Multiple Substitution using Environments</a></h3><p>There can be multiple variables in a single expression. For example, evaluating <span class="math">\(2 * x + y\)</span> where <span class="math">\(x=3\)</span> and <span class="math">\(y=-2\)</span>. A collection of bindings is called an <em>environment</em>. <a href='' id='Comment:Mult2' ></a></p><p>Since a binding is represented as a pair, an environment can be represented as a list of pairs. The environment mentioned above would be <a href='' id='Comment:Mult3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">e1 <span class="fu">=</span> [ (<span class="st">&quot;x&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;y&quot;</span>, <span class="fu">-</span><span class="dv">1</span>) ]
<span class="co">-- <a href='' id='Comment:Mult4' ></a></span></code></pre><p>The corresponding type is <a href='' id='Comment:Mult5' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Int</span>)]
<span class="co">-- <a href='' id='Comment:Mult6' ></a></span></code></pre><p>The substitution function is easily modified to work with environments rather than single bindings: <a href='' id='Comment:Mult7' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">substitute ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
substitute env exp <span class="fu">=</span> subst exp <span class="kw">where</span>
  subst (<span class="dt">Number</span> i)      <span class="fu">=</span> <span class="dt">Number</span> i
  subst (<span class="dt">Add</span> a b)       <span class="fu">=</span> <span class="dt">Add</span> (subst a) (subst b)
  subst (<span class="dt">Subtract</span> a b)  <span class="fu">=</span> <span class="dt">Subtract</span> (subst a) (subst b)
  subst (<span class="dt">Multiply</span> a b)  <span class="fu">=</span> <span class="dt">Multiply</span> (subst a) (subst b)
  subst (<span class="dt">Divide</span> a b)    <span class="fu">=</span> <span class="dt">Divide</span> (subst a) (subst b)
  subst (<span class="dt">Variable</span> name) <span class="fu">=</span>
    <span class="kw">case</span> lookup name env <span class="kw">of</span>
      <span class="dt">Just</span> val <span class="ot">-&gt;</span> <span class="dt">Number</span> val
      <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> <span class="dt">Variable</span> name
<span class="co">-- <a href='' id='Comment:Mult8' ></a></span></code></pre><p>The last case is the only one that is different from the previous definition of substitution for a single binding. It uses the <code>lookup</code> function to search the list of bindings to find the corresponding value (<code>Just val</code>) or <code>Nothing</code> if the variable is not found. For the <code>Nothing</code> case, the substitute function leaves the variable alone. <a href='' id='Comment:Mult9' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">z <span class="fu">=</span> <span class="dt">Variable</span> <span class="st">&quot;z&quot;</span>
main <span class="fu">=</span> <span class="kw">do</span>
  test <span class="st">&quot;substitute e1&quot;</span> (substitute e1) (<span class="dt">Add</span> x y)
  test <span class="st">&quot;substitute e1&quot;</span> (substitute e1) (<span class="dt">Number</span> <span class="dv">2</span>)
  test <span class="st">&quot;substitute e1&quot;</span> (substitute e1) x
  test <span class="st">&quot;substitute e1&quot;</span> (substitute e1) (<span class="dt">Add</span> (<span class="dt">Multiply</span> x x) x)
  test <span class="st">&quot;substitute e1&quot;</span> (substitute e1) (<span class="dt">Add</span> x (<span class="dt">Add</span> (<span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">2</span>) y) z))
<span class="co">-- <a href='' id='Comment:Mult10' ></a></span></code></pre><p>The test results show that multiple variables are substituted with values, but that unknown variables are left intact: <a href='' id='Comment:Mult11' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">substitute e1 (<span class="dt">Add</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Variable</span> <span class="st">&quot;y&quot;</span>))
 <span class="fu">==&gt;</span> <span class="dt">Add</span> (<span class="dt">Number</span> <span class="dv">3</span>) (<span class="dt">Number</span> (<span class="fu">-</span><span class="dv">1</span>))

substitute e1 (<span class="dt">Number</span> <span class="dv">2</span>)
 <span class="fu">==&gt;</span> <span class="dt">Number</span> <span class="dv">2</span>

substitute e1 (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)
 <span class="fu">==&gt;</span> <span class="dt">Number</span> <span class="dv">3</span>

substitute e1 (<span class="dt">Add</span> (<span class="dt">Multiply</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>))
 <span class="fu">==&gt;</span> <span class="dt">Add</span> (<span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">3</span>) (<span class="dt">Number</span> <span class="dv">3</span>)) (<span class="dt">Number</span> <span class="dv">3</span>)

substitute e1 (<span class="dt">Add</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)
  (<span class="dt">Add</span> (<span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">2</span>) (<span class="dt">Variable</span> <span class="st">&quot;y&quot;</span>)) (<span class="dt">Variable</span> <span class="st">&quot;z&quot;</span>)))
 <span class="fu">==&gt;</span> <span class="dt">Add</span> (<span class="dt">Number</span> <span class="dv">3</span>)
  (<span class="dt">Add</span> (<span class="dt">Multiply</span> (<span class="dt">Number</span> <span class="dv">2</span>) (<span class="dt">Number</span> (<span class="fu">-</span><span class="dv">1</span>))) (<span class="dt">Variable</span> <span class="st">&quot;z&quot;</span>))

<span class="co">-- <a href='' id='Comment:Mult11' ></a></span></code></pre><p>Note that it is also possible to substitute multiple variables one at a time: <a href='' id='Comment:Mult13' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">substitute1R env exp <span class="fu">=</span> foldr substitute1 exp env
<span class="co">-- <a href='' id='Comment:Mult14' ></a></span></code></pre><p>The <code>foldr fun init list</code> function applies a given function to each item in a list, starting with a given initial value. <a href='' id='Comment:Mult15' ></a></p><h3 id="local-variables"><a href="#local-variables"><span class="header-section-number">3.1.2</span> Local Variables</a></h3><p>So far all variables have been defined <em>outside</em> the expression itself. It is also useful to allow variables to be defined <em>within</em> an expression. Most programming languages support this capability by allowing definition of <em>local variables</em>. <a href='' id='Comment:Loca2' ></a></p><p>In C or Java one can define local variables in a declaration: <a href='' id='Comment:Loca3' ></a></p><pre class="sourceCode C"><code class="sourceCode c"><span class="dt">int</span> x = <span class="dv">3</span>;
<span class="kw">return</span> <span class="dv">2</span> * x + <span class="dv">5</span>;
<a href='' id='Comment:Loca4' ></a></code></pre><p>JavaScript is similar but does not specify the type of the variable: <a href='' id='Comment:Loca5' ></a></p><pre class="sourceCode C"><code class="sourceCode c">var x = <span class="dv">3</span>;
<span class="kw">return</span> <span class="dv">2</span> * x + <span class="dv">5</span>;
<a href='' id='Comment:Loca6' ></a></code></pre><p>Haskell defines local variables with a <code>let</code> expression: <a href='' id='Comment:Loca7' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">3</span> <span class="kw">in</span> <span class="dv">2</span><span class="fu">*</span>x <span class="fu">+</span> <span class="dv">5</span>
<span class="co">-- <a href='' id='Comment:Loca8' ></a></span></code></pre><p>In Haskell <code>let</code> is an expression, because it can be used inside other expressions: <a href='' id='Comment:Loca9' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dv">2</span> <span class="fu">*</span> (<span class="kw">let</span> x <span class="fu">=</span> <span class="dv">3</span> <span class="kw">in</span> x <span class="fu">+</span> <span class="dv">5</span>)
<span class="co">-- <a href='' id='Comment:Loca10' ></a></span></code></pre><p>TODO: note that <code>where</code> in Haskell is similar to <code>let</code>. <a href='' id='Comment:Loca11' ></a></p><p>It is also possible to define multiple local variables in Java or C: <a href='' id='Comment:Loca12' ></a></p><pre class="sourceCode Java"><code class="sourceCode java"><span class="dt">int</span> x = <span class="dv">3</span>;
<span class="dt">int</span> y = x * <span class="dv">2</span>;
<span class="kw">return</span> x + y;
<a href='' id='Comment:Loca13' ></a></code></pre><p>and in Haskell <a href='' id='Comment:Loca14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">3</span> <span class="kw">in</span> <span class="kw">let</span> y <span class="fu">=</span> x<span class="fu">*</span><span class="dv">2</span> <span class="kw">in</span> x <span class="fu">+</span> y
<span class="co">-- <a href='' id='Comment:Loca15' ></a></span></code></pre><p>which is equivalent to <a href='' id='Comment:Loca16' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">3</span> <span class="kw">in</span> (<span class="kw">let</span> y <span class="fu">=</span> x<span class="fu">*</span><span class="dv">2</span> <span class="kw">in</span> x <span class="fu">+</span> y)
<span class="co">-- <a href='' id='Comment:Loca17' ></a></span></code></pre><p>In general a <code>let</code> expression has the following concrete syntax: <a href='' id='Comment:Loca18' ></a></p><p><code>let</code> <em>variable</em> <code>=</code> <em>bound-expression</em> <code>in</code> <em>body</em> <a href='' id='Comment:Loca19' ></a></p><p>The meaning of a <code>let</code> expression is to evaluate the bound expression, then bind the local variable to the resulting value, and then evaluate the body of the expression <a href='' id='Comment:Loca20' ></a></p><p>In Haskell, a <code>let</code> expression can be represented by adding another case to the definition of expressions: <a href='' id='Comment:Loca21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">...</span>
         <span class="fu">|</span> <span class="dt">Let</span> <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="co">-- <a href='' id='Comment:Loca22' ></a></span></code></pre><p>where the string is the variable name, the first Exp is the bound expression and the second expression is the body. <a href='' id='Comment:Loca23' ></a></p><h3 id="scope"><a href="#scope"><span class="header-section-number">3.1.3</span> Scope</a></h3><p>The <em>scope</em> of a variable is the portion of the text of a program in which a variable is defined. Normally the scope of a local variable is all of the body of the let in which the variable is defined. However, it is possible for a variable to be redefined, which creates a hole in the scope of the outer variable: <a href='' id='Comment:Scop2' ></a></p><p><embed src="figures/scopes.png" /> <a href='' id='Comment:Scop3' ></a></p><p>In this example (Figure 2.2) there are two variables named <code>x</code>. Even though two variables have the same name, they are not the same variable. <a href='' id='Comment:Scop4' ></a></p><p>TODO: talk about <em>free</em> versus <em>bound</em> variables <a href='' id='Comment:Scop5' ></a></p><p>TODO: talk about renaming <a href='' id='Comment:Scop6' ></a></p><h3 id="BasicSubst"><a href="#BasicSubst"><span class="header-section-number">3.1.4</span> Substituting into <code>Let</code> Expressions</a></h3><p>When substituting a variable into an expression, care must be taken to correctly deal with holes in the variable’s scope. In particular, when substituting for <em>x</em> in an expression, if the expression is of the form <code>let</code> <em>x</em> <code>=</code> <em>e</em> <code>in</code> <em>body</em> then <em>x</em> should be substituted within <em>e</em> but not in <em>body</em>. Because <em>x</em> is redefined, the <em>body</em> is a hole in the scope of <em>x</em>. <a href='' id='Comment:Subs1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">substitute1 (var, val) exp <span class="fu">=</span> subst exp
  <span class="fu">...</span>
  subst (<span class="dt">Let</span> x exp body)  <span class="fu">=</span> <span class="dt">Let</span> x (subst exp) body&#39;
    <span class="kw">where</span> body&#39; <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> var
                  <span class="kw">then</span> body
                  <span class="kw">else</span> subst body
<span class="co">-- <a href='' id='Comment:Subs17' ></a></span></code></pre><p>In the <code>Let</code> case for <code>subst</code>, the variable is always substituted into the bound expression <code>e</code>. But the substitution is only performed on the body <code>b</code> if the variable <code>var</code> being substituted is <em>not</em> the same as the variable <code>x</code> defined in the let expression. <a href='' id='Comment:Subs16' ></a></p><p>TODO: need some test cases here <a href='' id='Comment:Subs18' ></a></p><h3 id="evaluating-let-expressions-using-substitution"><a href="#evaluating-let-expressions-using-substitution"><span class="header-section-number">3.1.5</span> Evaluating <code>Let</code> Expressions using Substitution</a></h3><p>The evaluation of a let expression is based on substitution. To evaluate <code>let</code> <em>x</em> <code>=</code> <em>e</em> <code>in</code> <em>b</em>, first evaluate the bound expression <em>e</em>, then substitute its value for variable <em>x</em> in the body <em>b</em>. Finally, the result of substitution is evaluated. <a href='' id='Comment:Eval1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Let</span> x exp body) <span class="fu">=</span> evaluate (substitute1 (x, evaluate exp) body)
<span class="co">-- <a href='' id='Comment:Eval28' ></a></span></code></pre><p>There is no rule for evaluating a variable because all variables are substituted away before evaluation begins. <a href='' id='Comment:Eval27' ></a></p><p>TODO: need some test cases here <a href='' id='Comment:Eval29' ></a></p><h3 id="undefined-variable-errors"><a href="#undefined-variable-errors"><span class="header-section-number">3.1.6</span> Undefined Variable Errors</a></h3><p>With the introduction of variables into our language, a new kind of error can arise: attempting to evaluate an expression containing a variable that does not have a value. For example, these expressions all contain undefined variables: <a href='' id='Comment:Unde2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">x <span class="fu">+</span> <span class="dv">3</span>
<span class="kw">let</span> x <span class="fu">=</span> <span class="dv">2</span> <span class="kw">in</span> x <span class="fu">*</span> y
(<span class="kw">let</span> x <span class="fu">=</span> <span class="dv">3</span> <span class="kw">in</span> x) <span class="fu">*</span> x
<span class="co">-- <a href='' id='Comment:Unde5' ></a></span></code></pre><p>What will happen when these expressions are evaluated? The definition of <code>evaluate</code> does not include a case for evaluating a variable. This is because all variables should be substituted for values before evaluation takes place. If a variable is not substituted then it is undefined. Since no case is defined for <code>evaluate</code> of a <code>Variable</code>, Haskell terminates the program and prints this error message: <a href='' id='Comment:Unde4' ></a></p><pre><code>*** Exception: anatomy.lhs: Non-exhaustive patterns in function evaluate
<a href='' id='Comment:Unde19' ></a></code></pre><p>The fact that a variable is undefined is a <em>static</em> property of the program: whether a variable is undefined depends only on the text of the program, not upon the particular data that the program is manipulating. (TODO: accurate example of static versus dynamic?) This is different from the divide by zero error, which depends upon the particular data that the program is manipulating. As a result, divide by zero is a <em>dynamic</em> error. Of course, it might be possible to identify, just from examining the text of a program, that it will always divide by zero. Alternatively, it may be the case that the code containing an undefined variable is never executed at runtime. Thus the boundary between static and dynamic errors is not absolute. The issue of static versus dynamic properties of programs is discussed in more detail later (TODO: reference to chapter on Types). <a href='' id='Comment:Unde6' ></a></p><h3 id="summary"><a href="#summary"><span class="header-section-number">3.1.7</span> Summary</a></h3><p>Here is the full code evaluation using substitution of a language with local variables. <a href='' id='Comment:Summ2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Number</span>     <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">Add</span>        <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Subtract</span>   <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Multiply</span>   <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Divide</span>     <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Variable</span>   <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">Let</span>        <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="co">-- <a href='' id='Comment:Summ3' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell">substitute1 (var, val) exp <span class="fu">=</span> subst exp <span class="kw">where</span>
  subst (<span class="dt">Number</span> i)      <span class="fu">=</span> <span class="dt">Number</span> i
  subst (<span class="dt">Add</span> a b)       <span class="fu">=</span> <span class="dt">Add</span> (subst a) (subst b)
  subst (<span class="dt">Subtract</span> a b)  <span class="fu">=</span> <span class="dt">Subtract</span> (subst a) (subst b)
  subst (<span class="dt">Multiply</span> a b)  <span class="fu">=</span> <span class="dt">Multiply</span> (subst a) (subst b)
  subst (<span class="dt">Divide</span> a b)    <span class="fu">=</span> <span class="dt">Divide</span> (subst a) (subst b)
  subst (<span class="dt">Variable</span> name) <span class="fu">=</span> <span class="kw">if</span> var <span class="fu">==</span> name
                          <span class="kw">then</span> <span class="dt">Number</span> val
                          <span class="kw">else</span> <span class="dt">Variable</span> name
  subst (<span class="dt">Let</span> x exp body)  <span class="fu">=</span> <span class="dt">Let</span> x (subst exp) body&#39;
    <span class="kw">where</span> body&#39; <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> var
                  <span class="kw">then</span> body
                  <span class="kw">else</span> subst body
<span class="co">-- <a href='' id='Comment:Summ19' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
evaluate (<span class="dt">Number</span> i)       <span class="fu">=</span> i
evaluate (<span class="dt">Add</span> a b)        <span class="fu">=</span> evaluate a <span class="fu">+</span> evaluate b
evaluate (<span class="dt">Subtract</span> a b)   <span class="fu">=</span> evaluate a <span class="fu">-</span> evaluate b
evaluate (<span class="dt">Multiply</span> a b)   <span class="fu">=</span> evaluate a <span class="fu">*</span> evaluate b
evaluate (<span class="dt">Divide</span> a b)     <span class="fu">=</span> evaluate a <span class="ot">`div`</span> evaluate b
evaluate (<span class="dt">Let</span> x exp body) <span class="fu">=</span> evaluate (substitute1 (x, evaluate exp) body)
<span class="co">-- <a href='' id='Comment:Summ4' ></a></span></code></pre><h2 id="BasicEvalEnv"><a href="#BasicEvalEnv"><span class="header-section-number">3.2</span> Evaluation using Environments</a></h2><p>For the basic evaluator substitution and evaluation were completely separate, but the evaluation rule for <code>let</code> expressions involves substitution. <a href='' id='Comment:Eval30' ></a></p><p>One consequence of this rule is that the body of every let expression is copied, because substitution creates a copy of the expression with variables substituted. When let expressions are <em>nested</em>, the body of the inner let expression is copied multiple times. In the following example, the expression <code>x * y * z</code> is copied three times: <a href='' id='Comment:Eval32' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">2</span> <span class="kw">in</span>
  <span class="kw">let</span> y <span class="fu">=</span> x<span class="fu">+</span><span class="dv">1</span> <span class="kw">in</span>
    <span class="kw">let</span> z <span class="fu">=</span> y<span class="fu">+</span><span class="dv">2</span> <span class="kw">in</span>
      x<span class="fu">*</span>y<span class="fu">*</span>z
<span class="co">-- <a href='' id='Comment:Eval33' ></a></span></code></pre><p>The steps are as follows: <a href='' id='Comment:Eval34' ></a></p><table><thead><tr class="header"><th align="left">Step</th><th align="left">Result</th></tr></thead><tbody><tr class="odd"><td align="left">initial expression</td><td align="left"><code>let x = 2 in</code></td></tr><tr class="even"><td align="left"></td><td align="left">    <code>let y = x + 1 in</code></td></tr><tr class="odd"><td align="left"></td><td align="left">        <code>let z = y + 2 in x * y * z</code></td></tr><tr class="even"><td align="left">evaluate bound expression</td><td align="left"><code>2</code> <span class="math">\(\Rightarrow\)</span> <code>2</code></td></tr><tr class="odd"><td align="left">substitute x <span class="math">\(\mapsto\)</span> 2 in body</td><td align="left"><code>let y = 2+1 in (let z = y + 2 in 2 * y * z)</code></td></tr><tr class="even"><td align="left">evaluate bound expression</td><td align="left"><code>2 + 1</code> <span class="math">\(\Rightarrow\)</span> <code>3</code></td></tr><tr class="odd"><td align="left">substitute y <span class="math">\(\mapsto\)</span> 3 in body</td><td align="left"><code>let z = 3 + 2 in 2 * 3 * z</code></td></tr><tr class="even"><td align="left">evaluate bound expression</td><td align="left"><code>3 + 2</code> <span class="math">\(\Rightarrow\)</span> <code>5</code></td></tr><tr class="odd"><td align="left">substitute z <span class="math">\(\mapsto\)</span> 5 in body</td><td align="left"><code>2 * 3 * 5</code></td></tr><tr class="even"><td align="left">evaluate body</td><td align="left"><code>2 * 3 * 5</code> <span class="math">\(\Rightarrow\)</span> <code>30</code> <a href='' id='Comment:Eval35' ></a></td></tr></tbody></table><p>While this is a reasonable approach it is not efficient. We have already seen that multiple variables can be substituted at the same time. Rather than performing the substitution fully for each <code>let</code> expression, instead the <code>let</code> expression can add another binding to the list of substitutions being performed. <a href='' id='Comment:Eval36' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Evaluate an expression in an environment</span>
<span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
evaluate (<span class="dt">Number</span> i) env     <span class="fu">=</span> i
evaluate (<span class="dt">Add</span> a b) env       <span class="fu">=</span> evaluate a env <span class="fu">+</span> evaluate b env
evaluate (<span class="dt">Subtract</span> a b) env  <span class="fu">=</span> evaluate a env <span class="fu">-</span> evaluate b env
evaluate (<span class="dt">Multiply</span> a b) env  <span class="fu">=</span> evaluate a env <span class="fu">*</span> evaluate b env
evaluate (<span class="dt">Divide</span> a b) env    <span class="fu">=</span> evaluate a env <span class="ot">`div`</span> evaluate b env
evaluate (<span class="dt">Variable</span> x) env    <span class="fu">=</span> fromJust (lookup x env)
evaluate (<span class="dt">Let</span> x exp body) env <span class="fu">=</span> evaluate body newEnv
  <span class="kw">where</span> newEnv <span class="fu">=</span> (x, evaluate exp env) <span class="fu">:</span> env
<span class="co">-- <a href='' id='Comment:Eval38' ></a></span></code></pre><p>In most cases the environment argument is simply passed unchanged to all recursive calls to <code>evaluate</code>. But in the final case, for <code>Let</code>, the environment <em>does</em> change. <a href='' id='Comment:Eval10' ></a></p><p>The case for <code>Let</code> first evaluates the bound expression in the current environment <code>env</code>, then it creates a new environment <code>newEnv</code> that binds <code>x</code> to the value of the bound expressions. It then evaluates the body <code>b</code> in the new environment <code>newEnv</code>. <a href='' id='Comment:Eval11' ></a></p><p>The steps in evaluation with environments do not copy the expression: <a href='' id='Comment:Eval12' ></a></p><table><thead><tr class="header"><th align="left">Environment</th><th align="left">Evaluation</th></tr></thead><tbody><tr class="odd"><td align="left"><span class="math">\(\emptyset\)</span></td><td align="left"><code>let x = 2 in</code></td></tr><tr class="even"><td align="left"></td><td align="left">    <code>let y = x + 1 in</code></td></tr><tr class="odd"><td align="left"></td><td align="left">        <code>let z = y + 2 in x * y * z</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ evaluate bound expression <code>2</code>}</td></tr><tr class="odd"><td align="left"><span class="math">\(\emptyset\)</span></td><td align="left"><code>2</code> <span class="math">\(\Rightarrow\)</span> <code>2</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ add new binding for <code>x</code> and evaluate body of let }</td></tr><tr class="odd"><td align="left"><code>x</code> <span class="math">\(\mapsto\)</span> 2</td><td align="left"><code>let y = x + 1 in (let z = y + 2 in x * y * z)</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ evaluate bound expression <code>x + 1</code> }</td></tr><tr class="odd"><td align="left"><code>x</code> <span class="math">\(\mapsto\)</span> 2</td><td align="left"><code>x + 1</code> <span class="math">\(\Rightarrow\)</span> <code>3</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ add new binding for <code>y</code> and evaluate body of let }</td></tr><tr class="odd"><td align="left"><code>y</code> <span class="math">\(\mapsto\)</span> 3, <code>x</code> <span class="math">\(\mapsto\)</span> 2</td><td align="left"><code>let z = y + 2 in x * y * z</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ evaluate bound expression <code>y + 2</code> }</td></tr><tr class="odd"><td align="left"><code>y</code> <span class="math">\(\mapsto\)</span> 3, <code>x</code> <span class="math">\(\mapsto\)</span> 2</td><td align="left"><code>y + 2</code> <span class="math">\(\Rightarrow\)</span> <code>5</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ add new binding for <code>z</code> and evaluate body of let }</td></tr><tr class="odd"><td align="left"><code>z</code> <span class="math">\(\mapsto\)</span> 5, <code>y</code> <span class="math">\(\mapsto\)</span> 3, <code>x</code> <span class="math">\(\mapsto\)</span> 2</td><td align="left"><code>x * y * z</code> <span class="math">\(\Rightarrow\)</span> <code>70</code> <a href='' id='Comment:Eval13' ></a></td></tr></tbody></table><p>In the <code>Let</code> case of <code>evaluate</code>, a new environment <code>newEnv</code> is created and used as the environment for evaluation of the body <code>b</code>. <a href='' id='Comment:Eval14' ></a></p><p>The new environments add the additional bindings to the <em>front</em> of the list of environments. Since <code>lookup</code> searches an environment list from left to right, it will find the most recent enclosing binding for a variable, and ignore any additional bindings. For example, consider the evaluation of this expression: <a href='' id='Comment:Eval15' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">9</span> <span class="kw">in</span> (<span class="kw">let</span> x <span class="fu">=</span> x<span class="fu">*</span>x <span class="kw">in</span> x<span class="fu">+</span>x)
<span class="co">-- <a href='' id='Comment:Eval16' ></a></span></code></pre><table><thead><tr class="header"><th align="left">Environment</th><th align="left">Evaluation</th></tr></thead><tbody><tr class="odd"><td align="left"><span class="math">\(\emptyset\)</span></td><td align="left"><code>let x = 9 in (let x = x * x in x + x)</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ evaluate bound expression <code>9</code> }</td></tr><tr class="odd"><td align="left"><span class="math">\(\emptyset\)</span></td><td align="left"><code>9</code> <span class="math">\(\Rightarrow\)</span> <code>9</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ add new binding for <code>x</code> and evaluate body of let }</td></tr><tr class="odd"><td align="left"><code>x</code> <span class="math">\(\mapsto\)</span> 9</td><td align="left"><code>let x = x * x in x + x</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ evaluate bound expression <code>x * x</code> }</td></tr><tr class="odd"><td align="left"><code>x</code> <span class="math">\(\mapsto\)</span> 9</td><td align="left"><code>x * x</code> <span class="math">\(\Rightarrow\)</span> <code>81</code></td></tr><tr class="even"><td align="left"></td><td align="left">{ add new binding for <code>x</code> and evaluate body of let }</td></tr><tr class="odd"><td align="left"><code>x</code> <span class="math">\(\mapsto\)</span> 81, <code>x</code> <span class="math">\(\mapsto\)</span> 9</td><td align="left"><code>x + x</code> <span class="math">\(\Rightarrow\)</span> <code>162</code> <a href='' id='Comment:Eval17' ></a></td></tr></tbody></table><p>Note that the environment contains two bindings for <code>x</code>, but only the first one is used. Having multiple bindings for the same name implements the concept of ‘holes’ in the scope of a variable: when a new binding for the same variable is added to the environment, the original binding is no longer accessible. <a href='' id='Comment:Eval18' ></a></p><p>The old environment is not changed, so there is no need to reset or restore the previous environment. For example, evaluating the following expression creates to extensions of the base environment <a href='' id='Comment:Eval19' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">3</span> <span class="kw">in</span>
  (<span class="kw">let</span> y <span class="fu">=</span> <span class="dv">3</span><span class="fu">*</span>x <span class="kw">in</span> <span class="dv">2</span><span class="fu">+</span>y) <span class="fu">+</span> (<span class="kw">let</span> z <span class="fu">=</span> <span class="dv">7</span><span class="fu">*</span>x <span class="kw">in</span> <span class="dv">1</span><span class="fu">+</span>z)
<span class="co">-- <a href='' id='Comment:Eval20' ></a></span></code></pre><p>The first <code>let</code> expressions creates an environment <code>x</code> <span class="math">\(\mapsto\)</span> 3 with a single binding. The next two let expressions create environments <a href='' id='Comment:Eval21' ></a></p><p><code>y</code> <span class="math">\(\mapsto\)</span> 9, <code>x</code> <span class="math">\(\mapsto\)</span> 3 <a href='' id='Comment:Eval22' ></a></p><p><code>z</code> <span class="math">\(\mapsto\)</span> 21, <code>x</code> <span class="math">\(\mapsto\)</span> 3 <a href='' id='Comment:Eval23' ></a></p><p>Internally Haskell allows these two environments to share the definition of the original environment <code>x</code> <span class="math">\(\mapsto\)</span> 3. <a href='' id='Comment:Eval24' ></a></p><p>The Haskell function <code>fromJust</code> raises an exception if its argument is <code>Nothing</code>, which occurs when the variable named by <code>x</code> is not found in the environment <code>env</code>. This is where undefined variable errors arise in this evaluator. <a href='' id='Comment:Eval25' ></a></p><p>TODO: define <em>exception</em>? <a href='' id='Comment:Eval26' ></a></p><h4 id="exercise-2.1-multi-variable-let-expressions"><a href="#exercise-2.1-multi-variable-let-expressions"><span class="header-section-number">3.2.0.1</span> Exercise 2.1: Multi-variable <code>let</code> expressions</a></h4><p>Modify the <code>let</code> expression to take a list of bindings, rather than a single one. Modify the <code>evaluate</code> function to handle evaluation of multi-variable <code>let</code> expressions. <a href='' id='Comment:Exer2' ></a></p><h2 id="more-kinds-of-data-booleans-and-conditionals"><a href="#more-kinds-of-data-booleans-and-conditionals"><span class="header-section-number">3.3</span> More Kinds of Data: Booleans and Conditionals</a></h2><p>In addition to arithmetic computations, it is useful for expressions to include conditions and also return different kinds of values. Until now our expressions have always returned <code>Int</code> results, because they have only performed arithmetic computations. The code for this section is given in the <a href="./code/IntBool.hs.htm">Int Bool</a> file. The type <code>Value</code> is defined to support multiple different kinds of values: <a href='' id='Comment:More2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">IntV</span>  <span class="dt">Int</span>
           <span class="fu">|</span> <span class="dt">BoolV</span> <span class="dt">Bool</span>
 <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="co">-- <a href='' id='Comment:More3' ></a></span></code></pre><p>Some example values are <code>BoolV True</code> and <code>IntV 3</code>. We will define additional kinds of values, including functions and lists, later. The names <code>IntV</code> and <code>BoolV</code> in this type definition are the <em>labels</em> for data variants, while <code>Int</code> and <code>Bool</code> uses are <em>types</em> that specify what kind of data are associated with that data variant. <a href='' id='Comment:More5' ></a></p><p>The abstract syntax of expressions can now be expanded to include operations involving booleans. Some examples are <span class="math">\(4 &lt; 10\)</span> and <span class="math">\(3 * 10 = 7\)</span>. Once booleans are included in the language, it is possible to define a <em>conditional</em> expression, with the following concrete syntax: <a href='' id='Comment:More6' ></a></p><p><code>if</code> <em>test</em> <code>then</code> <em>true-part</em> <code>else</code> <em>false-part</em> <a href='' id='Comment:More7' ></a></p><p>A conditional expression allows selection of one of two different values based on whether a boolean is true or false. Note that a conditional <em>expression</em> is expected to produce a value. This is different from the conditional <em>statement</em> found in many languages (most notably C and Java), which executes one of two blocks but does not produce a value. In these languages, conditional expressions are written <em>test</em> <code>?</code> <em>true-part</em> <code>:</code> <em>false-part</em>. Haskell, however, only has conditional expressions of the kind discussed here. <a href='' id='Comment:More8' ></a></p><p>Given a full set of arithmetic operators, some comparison operators (equality <code>EQ</code>, less than <code>LT</code>, greater than <code>GT</code>, less than or equal <code>LE</code>), plus <code>and</code>, <code>or</code> and <code>not</code> for booleans, it is useful to generalize the abstract syntax to support a general notation for binary and unary operators. When an expression includes a value it is called a <em>literal</em> value. Literals generalize the case of <code>Number</code> used above to include constants in an arithmetic expression. The conditional expression is sometimes called a <em>ternary</em> operator because it has three arguments. But since there is only one ternary operator, and also because a conditional expression is fairly special, it is included directly as <code>If</code> expression. These changes are implemented in the following definition for the abstract syntax <code>Exp</code>: <a href='' id='Comment:More9' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinaryOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Sub</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span> <span class="fu">|</span> <span class="dt">And</span> <span class="fu">|</span> <span class="dt">Or</span>
              <span class="fu">|</span> <span class="dt">GT</span> <span class="fu">|</span> <span class="dt">LT</span> <span class="fu">|</span> <span class="dt">LE</span> <span class="fu">|</span> <span class="dt">GE</span> <span class="fu">|</span> <span class="dt">EQ</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">data</span> <span class="dt">UnaryOp</span> <span class="fu">=</span> <span class="dt">Neg</span> <span class="fu">|</span> <span class="dt">Not</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Literal</span>   <span class="dt">Value</span>
         <span class="fu">|</span> <span class="dt">Unary</span>     <span class="dt">UnaryOp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Binary</span>    <span class="dt">BinaryOp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">If</span>        <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Variable</span>  <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">Let</span>       <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)
<span class="co">-- <a href='' id='Comment:More99' ></a></span></code></pre><p>Evaluation is then defined by cases as before. Two helper functions, <code>binary</code> and <code>unary</code> (defined below), perform the actual computations for binary and unary operations, respectively. <a href='' id='Comment:More11' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Value</span>)]

<span class="co">-- Evaluate an expression in an environment</span>
<span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env      <span class="fu">=</span> v
evaluate (<span class="dt">Unary</span> op a) env     <span class="fu">=</span> unary op (evaluate a env)
evaluate (<span class="dt">Binary</span> op a b) env  <span class="fu">=</span> binary op (evaluate a env) (evaluate b env)
evaluate (<span class="dt">Variable</span> x) env     <span class="fu">=</span> fromJust (lookup x env)
evaluate (<span class="dt">Let</span> x exp body) env <span class="fu">=</span> evaluate body newEnv
  <span class="kw">where</span> newEnv <span class="fu">=</span> (x, evaluate exp env) <span class="fu">:</span> env
<span class="co">-- <a href='' id='Comment:More12' ></a></span></code></pre><p>The conditional expression first evaluates the condition, forces it to be a boolean, and then evaluates either the <em>then</em> or <em>else</em> expression. <a href='' id='Comment:More13' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">If</span> a b c) env <span class="fu">=</span>
  <span class="kw">let</span> <span class="dt">BoolV</span> test <span class="fu">=</span> evaluate a env <span class="kw">in</span>
    <span class="kw">if</span> test <span class="kw">then</span> evaluate b env
            <span class="kw">else</span> evaluate c env

execute exp <span class="fu">=</span> evaluate exp []
<span class="co">-- <a href='' id='Comment:More14' ></a></span></code></pre><p>The binary and unary helper functions perform case analysis on the operator and the arguments to compute the result of basic operations. <a href='' id='Comment:More15' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">unary <span class="dt">Not</span> (<span class="dt">BoolV</span> b) <span class="fu">=</span> <span class="dt">BoolV</span> (not b)
unary <span class="dt">Neg</span> (<span class="dt">IntV</span> i)  <span class="fu">=</span> <span class="dt">IntV</span> (<span class="fu">-</span>i)

binary <span class="dt">Add</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">IntV</span> (a <span class="fu">+</span> b)
binary <span class="dt">Sub</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">IntV</span> (a <span class="fu">-</span> b)
binary <span class="dt">Mul</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">IntV</span> (a <span class="fu">*</span> b)
binary <span class="dt">Div</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">IntV</span> (a <span class="ot">`div`</span> b)
binary <span class="dt">And</span> (<span class="dt">BoolV</span> a) (<span class="dt">BoolV</span> b) <span class="fu">=</span> <span class="dt">BoolV</span> (a <span class="fu">&amp;&amp;</span> b)
binary <span class="dt">Or</span>  (<span class="dt">BoolV</span> a) (<span class="dt">BoolV</span> b) <span class="fu">=</span> <span class="dt">BoolV</span> (a <span class="fu">||</span> b)
binary <span class="dt">LT</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">BoolV</span> (a <span class="fu">&lt;</span> b)
binary <span class="dt">LE</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">BoolV</span> (a <span class="fu">&lt;=</span> b)
binary <span class="dt">GE</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">BoolV</span> (a <span class="fu">&gt;=</span> b)
binary <span class="dt">GT</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">BoolV</span> (a <span class="fu">&gt;</span> b)
binary <span class="dt">EQ</span>  a         b         <span class="fu">=</span> <span class="dt">BoolV</span> (a <span class="fu">==</span> b)
<span class="co">-- <a href='' id='Comment:More16' ></a></span></code></pre><p>TODO: talk about strictness! <a href='' id='Comment:More17' ></a></p><p>Using the new format, here are the expressions for the test cases given above: <a href='' id='Comment:More18' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- 4</span>
t1 <span class="fu">=</span> <span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">4</span>)
<span class="co">-- -4 - 6</span>
t2 <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Sub</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">4</span>))) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">6</span>))
<span class="co">-- 3 - -2 - -7</span>
t3 <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Sub</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
                (<span class="dt">Binary</span> <span class="dt">Sub</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">2</span>))) (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">7</span>))))
<span class="co">-- 3*(8 + 5)</span>
t4 <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Mul</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
                (<span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">8</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">5</span>)))
<span class="co">-- 3 + 8 * 2</span>
t5 <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
                (<span class="dt">Binary</span> <span class="dt">Mul</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">8</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">2</span>)))
<span class="co">-- <a href='' id='Comment:More19' ></a></span></code></pre><p>In addition, new expressions can be defined to represent conditional expressions: <a href='' id='Comment:More20' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- if 3 &gt; 3*(8 + 5) then 1 else 0</span>
t6 <span class="fu">=</span> <span class="dt">If</span> (<span class="dt">Binary</span> <span class="dt">GT</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) t4)
        (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">1</span>))
        (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">0</span>))
<span class="co">-- 2 + (if 3 &lt;= 0 then 9 else -5)</span>
t7 <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">2</span>))
                (<span class="dt">If</span> (<span class="dt">Binary</span> <span class="dt">LE</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
                                        (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">0</span>)))
                    (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">9</span>))
                    (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">5</span>))))
<span class="co">-- <a href='' id='Comment:More98' ></a></span></code></pre><p>Running these test cases with the <code>test</code> function defined above yields these results: <a href='' id='Comment:More22' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">execute (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">4</span>))
 <span class="fu">==&gt;</span> <span class="dt">IntV</span> <span class="dv">4</span>

execute (<span class="dt">Binary</span> <span class="dt">Sub</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">4</span>))) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">6</span>)))
 <span class="fu">==&gt;</span> <span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">10</span>)

execute (<span class="dt">Binary</span> <span class="dt">Sub</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
  (<span class="dt">Binary</span> <span class="dt">Sub</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">2</span>))) (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">7</span>)))))
 <span class="fu">==&gt;</span> <span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">2</span>)

execute (<span class="dt">Binary</span> <span class="dt">Mul</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
  (<span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">8</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">5</span>))))
 <span class="fu">==&gt;</span> <span class="dt">IntV</span> <span class="dv">39</span>

execute (<span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
  (<span class="dt">Binary</span> <span class="dt">Mul</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">8</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">2</span>))))
 <span class="fu">==&gt;</span> <span class="dt">IntV</span> <span class="dv">19</span>

execute (<span class="dt">If</span>
  (<span class="dt">Binary</span> <span class="dt">GT</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
     (<span class="dt">Binary</span> <span class="dt">Mul</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>))
        (<span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">8</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">5</span>)))))
  (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">1</span>))
  (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">0</span>)))
 <span class="fu">==&gt;</span> <span class="dt">IntV</span> <span class="dv">0</span>

execute (<span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">2</span>))
  (<span class="dt">If</span> (<span class="dt">Binary</span> <span class="dt">LE</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">0</span>)))
     (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">9</span>))
     (<span class="dt">Literal</span> (<span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">5</span>)))))
 <span class="fu">==&gt;</span> <span class="dt">IntV</span> (<span class="fu">-</span><span class="dv">3</span>)

<span class="co">-- <a href='' id='Comment:More23' ></a></span></code></pre><h3 id="type-errors"><a href="#type-errors"><span class="header-section-number">3.3.1</span> Type Errors</a></h3><p>Now that our language supports two kinds of values, it is possible for an expression to get <em>type errors</em>. A type error occurs when evaluation of an expression attempts to perform an operation but one or more of the values involved are not of the right type. For example, attempting to add an integer and a boolean value, as in <code>3 + True</code>, leads to a type error. <a href='' id='Comment:Type2' ></a></p><p>In our Haskell program, type errors exhibit themselves in the <code>binary</code> and <code>unary</code> functions, which match certain legal patterns of operations, but leave illegal combinations of operations and arguments undefined. Attempting to evaluate <code>3 + True</code> results in a call to <code>binary Add (IntV 3) (BoolV True)</code>, which is not one of the patterns handled by the <code>binary</code> function. As a result, Haskell generates a <em>Non-exhaustive pattern</em> error: <a href='' id='Comment:Type3' ></a></p><pre><code>Main&gt; evaluate [] (Binary Add (Literal (IntV 3)) (Literal (BoolV True)))
*** Exception: Non-exhaustive patterns in function binary <a href='' id='Comment:Type4' ></a></code></pre><p>Here are some examples of expression that generate type errors: <a href='' id='Comment:Type5' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- if 3 then 5 else 8</span>
err1 <span class="fu">=</span> <span class="dt">If</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">5</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">8</span>))
<span class="co">-- 3 + True</span>
err2 <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">BoolV</span> <span class="dt">True</span>))
<span class="co">-- 3 || True</span>
err3 <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Or</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">BoolV</span> <span class="dt">True</span>))
<span class="co">-- -True</span>
err4 <span class="fu">=</span> <span class="dt">Unary</span> <span class="dt">Neg</span> (<span class="dt">Literal</span> (<span class="dt">BoolV</span> <span class="dt">True</span>))
<span class="co">-- <a href='' id='Comment:Type6' ></a></span></code></pre><p>Running these tests produce error messages, but the errors are not very descriptive of the problem that actually took place. <a href='' id='Comment:Type1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">execute (<span class="dt">If</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">5</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">8</span>)))
 <span class="fu">==&gt;</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Irrefutable</span> pattern failed for pattern <span class="dt">IntBool.BoolV</span> test

execute (<span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">BoolV</span> <span class="dt">True</span>)))
 <span class="fu">==&gt;</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Non</span><span class="fu">-</span>exhaustive patterns <span class="kw">in</span> function binary

execute (<span class="dt">Binary</span> <span class="dt">Or</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">BoolV</span> <span class="dt">True</span>)))
 <span class="fu">==&gt;</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Non</span><span class="fu">-</span>exhaustive patterns <span class="kw">in</span> function binary

execute (<span class="dt">Unary</span> <span class="dt">Neg</span> (<span class="dt">Literal</span> (<span class="dt">BoolV</span> <span class="dt">True</span>)))
 <span class="fu">==&gt;</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Non</span><span class="fu">-</span>exhaustive patterns <span class="kw">in</span> function unary

<span class="co">-- <a href='' id='Comment:Type6run' ></a></span></code></pre><p>We will discuss techniques for preventing type errors later, but for now it is important to realize that programs may fail at runtime. <a href='' id='Comment:Type7' ></a></p><h1 id="functions"><a href="#functions"><span class="header-section-number">4</span> Functions</a></h1><p>Functions are familiar to any student of mathematics. The first hint of a function in grade school may be some of the standard operators that are introduced early in the curriculum. Examples include absolute value <span class="math">\(\mid x \mid\)</span> and square root <span class="math">\(\sqrt{x}\)</span>. The concept of a function is also implicit in the standard equation for a line <span class="math">\(y = mx + b\)</span>. Trigonometry introduces the standard functions <em>sin(a)</em> and <em>cos(a)</em> to support computation on angles. While these operators use more traditional function syntax, they are still considered predefined computations, much like absolute value or square root. However, the concept of a function as an explicit object of study is not usually introduced until calculus. <a href='' id='Comment:Func2' ></a></p><p>Programming languages all support some form of function definition. A function allows a computation to be written down once and reused many times. <a href='' id='Comment:Func3' ></a></p><p>So while you might already have a good grasp of what functions do, there’s a good chance that the more abstract question of what functions <em>are</em> remains unanswered. In order to help you answer this question, first we will implement the ability to evaluate a restricted subset of functions called Top-Level Functions in our developing language. Then, to help you actually answer the question of what a function is, we will explore the idea of functions as first-class values in a programming language. <a href='' id='Comment:Func4' ></a></p><h2 id="top-level-function-definitions"><a href="#top-level-function-definitions"><span class="header-section-number">4.1</span> Top-Level Function Definitions</a></h2><p>Some programming languages, including C and ACL2, allow functions to be defined only at the top level of the program. The “top level” means outside of any expression. In this case, the program itself is a list of function definitions followed by a main expression. The main expression in a C program is an implicit call to a function named <code>main</code>. Even if a programming language does support more flexible definition of functions, top-level functions are quite common. The code for this section is given in the <a href="./code/TopLevelFunctions.hs.htm">Top Level Functions</a> file. Here is an example of some top-level functions, written in JavaScript: <a href='' id='Comment:Top2' ></a></p><pre class="sourceCode Java"><code class="sourceCode java"><span class="co">// compute n raised to the m-th power</span>
function <span class="fu">power</span>(n, m) {
  <span class="kw">if</span> (m == <span class="dv">0</span>)
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">else</span>
    <span class="kw">return</span> n * <span class="fu">power</span>(n, m - <span class="dv">1</span>);
} <a href='' id='Comment:Top3' ></a>

function <span class="fu">main</span>() {
  <span class="kw">return</span> <span class="fu">power</span>(<span class="dv">3</span>, <span class="dv">4</span>);
}
<a href='' id='Comment:Top4' ></a></code></pre><p>This code is written in JavaScript. It resembles C or Java, but without types. Our expression language does not need <code>return</code> statements, because every expression automatically returns a value. A similar program can be written in Haskell, also without return statements: <a href='' id='Comment:Top6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">power(n, m) <span class="fu">=</span>
  <span class="kw">if</span> (m <span class="fu">==</span> <span class="dv">0</span>) <span class="kw">then</span>
    <span class="dv">1</span>
  <span class="kw">else</span>
    n <span class="fu">*</span> power(n, m <span class="fu">-</span> <span class="dv">1</span>)
<span class="co">-- <a href='' id='Comment:Top1' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell">main <span class="fu">=</span>         <span class="co">-- not really a valid Haskell main function</span>
  power(<span class="dv">3</span>, <span class="dv">4</span>)
<span class="co">-- <a href='' id='Comment:Top8' ></a></span></code></pre><p>These examples provides an outline for the basic concrete syntax of a function: <a href='' id='Comment:Top9' ></a></p><p><code>function</code> <em>function-name</em> <code>(</code> <em>parameter-name</em>, …, <em>parameter-name</em> <code>)</code> <em>body-expression</em> <a href='' id='Comment:Top10' ></a></p><p>The exact syntax varies from language to language. Some languages begin with a keyword <code>function</code> or <code>def</code>. Other languages require brackets <code>{</code> … <code>}</code> around the body of the function. These functions are less powerful than Haskell, because they take a simple parameter list rather than a full pattern. But this simple form of function defined above captures the essence of function definition in many languages. <a href='' id='Comment:Top11' ></a></p><p>A call to a function is an expression that has the following concrete syntax: <a href='' id='Comment:Top12' ></a></p><p><em>function-name</em> <code>(</code> <em>expression</em>, …, <em>expression</em> <code>)</code> <a href='' id='Comment:Top13' ></a></p><p>Again, there are some variations on this theme. For example, in Haskell the parentheses are optional. The program has a series of named functions, each of which has a list of parameter names and a body expression. The following data type definitions provide a means to represent such programs: <a href='' id='Comment:Top14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">FunEnv</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Function</span>)]
<span class="kw">data</span> <span class="dt">Function</span> <span class="fu">=</span> <span class="dt">Function</span> [<span class="dt">String</span>] <span class="dt">Exp</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="co">-- <a href='' id='Comment:Top15' ></a></span></code></pre><p>A list of function definitions is a <em>function environment</em>. This list represents a list of bindings of function names to function definitions. <a href='' id='Comment:Top16' ></a></p><p>A program is then a function environment together with a main expression: <a href='' id='Comment:Top17' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Program</span> <span class="fu">=</span> <span class="dt">Program</span> <span class="dt">FunEnv</span> <span class="dt">Exp</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="co">-- <a href='' id='Comment:Top18' ></a></span></code></pre><p>Any of the expressions can contain calls to the top-level functions. A call has a function name and a list of actual argument expressions: <a href='' id='Comment:Top19' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">...</span>
         <span class="fu">|</span> <span class="dt">Call</span>      <span class="dt">String</span> [<span class="dt">Exp</span>]
<span class="co">-- <a href='' id='Comment:Top20' ></a></span></code></pre><p>As an example, here is an encoding of the example program: <a href='' id='Comment:Top21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">f1 <span class="fu">=</span> <span class="dt">Function</span> [<span class="st">&quot;n&quot;</span>, <span class="st">&quot;m&quot;</span>]
      (<span class="dt">If</span> (<span class="dt">Binary</span> <span class="dt">EQ</span> (<span class="dt">Variable</span> <span class="st">&quot;m&quot;</span>) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">0</span>)))
          (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">1</span>))
          (<span class="dt">Binary</span> <span class="dt">Mul</span>
            (<span class="dt">Variable</span> <span class="st">&quot;n&quot;</span>)
            (<span class="dt">Call</span> <span class="st">&quot;power&quot;</span> [<span class="dt">Variable</span>  <span class="st">&quot;n&quot;</span>,
                           <span class="dt">Binary</span>  <span class="dt">Sub</span> (<span class="dt">Variable</span>  <span class="st">&quot;m&quot;</span>)
                                         (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">1</span>))])))

p1 <span class="fu">=</span> <span class="dt">Program</span> [(<span class="st">&quot;power&quot;</span>, f1)]
             (<span class="dt">Call</span> <span class="st">&quot;power&quot;</span> [<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>),
                            <span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">4</span>)])
<span class="co">-- <a href='' id='Comment:Top22' ></a></span></code></pre><h3 id="EvalTopLevel"><a href="#EvalTopLevel"><span class="header-section-number">4.1.1</span> Evaluating Top-Level Functions</a></h3><p>A new function, <code>execute</code>, runs a program. It does so by evaluating the main expression in the context of the programs’ function environment and an empty variable environment: <a href='' id='Comment:Eval39' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">execute ::</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
execute (<span class="dt">Program</span> funEnv main) <span class="fu">=</span> evaluate main [] funEnv
<span class="co">-- <a href='' id='Comment:Eval41' ></a></span></code></pre><p>The evaluator is extended to take a function environment <code>funEnv</code> as a additional argument. <a href='' id='Comment:Eval43' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">FunEnv</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
<span class="co">-- <a href='' id='Comment:Eval59' ></a></span></code></pre><p>All the cases of evaluation are the same as before, except for the new case for calling a function: <a href='' id='Comment:Eval61' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Call</span> fun args) env funEnv   <span class="fu">=</span> evaluate body newEnv funEnv
  <span class="kw">where</span> <span class="dt">Function</span> xs body <span class="fu">=</span> fromJust (lookup fun funEnv)
        newEnv <span class="fu">=</span> zip xs [evaluate a env funEnv <span class="fu">|</span> a <span class="ot">&lt;-</span> args]
<span class="co">-- <a href='' id='Comment:Eval31' ></a></span></code></pre><p>Evaluation of a call expression performs the following steps: <a href='' id='Comment:Eval44' ></a></p><ol style="list-style-type: decimal"><li>Look up the function definition by name <code>lookup fun funEnv</code>, to get the function’s parameter list <code>xs</code> and <code>body</code>. <a href='' id='Comment:Eval45' ></a></li><li>Evaluate the actual arguments <code>[evaluate a env funEnv BAR a &lt;- args]</code> to get a list of values <a href='' id='Comment:Eval46' ></a></li><li>Create a new environment <code>newEnv</code> by zipping together the parameter names with the actual argument values. <a href='' id='Comment:Eval47' ></a></li><li>Evaluate the function <code>body</code> in the new environment <code>newEnv</code> <a href='' id='Comment:Eval60' ></a></li></ol><p>TODO: work out an example to illustrate evaluation of functions? <a href='' id='Comment:Eval48' ></a></p><p>The only variables that can be used in a function body are the parameters of the function. As a result, the only environment needed to evaluate the function body is the new environment created by zipping together the parameters and the actual arguments. <a href='' id='Comment:Eval49' ></a></p><p>The evaluator now takes two environments as input: one for functions and one for normal variables. A given name is always looked up in one or the other of these two environments, and there is never any confusion about which place to look. The certainty about where to look up a name comes from the the fact that the names appear in completely different places in the abstract syntax: <a href='' id='Comment:Eval50' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">...</span>
     <span class="fu">|</span> <span class="dt">Variable</span>  <span class="dt">String</span>         <span class="co">-- variable name</span>
     <span class="fu">|</span> <span class="dt">Call</span>      <span class="dt">String</span> [<span class="dt">Exp</span>]   <span class="co">-- function name</span>
<span class="co">-- <a href='' id='Comment:Eval37' ></a></span></code></pre><p>A variable name is tagged as a <code>Variable</code> and a function name appears in a <code>Call</code> expression. <a href='' id='Comment:Eval51' ></a></p><p>Because the names of function and the names of variables are completely distinct, they are said to be in different <em>namespaces</em>. The separation of the variable and function namespace is clear in the following (silly) example: <a href='' id='Comment:Eval52' ></a></p><pre class="sourceCode Java"><code class="sourceCode java">    function <span class="fu">pow</span>(pow)
      <span class="kw">if</span> pow &lt;= <span class="dv">0</span> then
        <span class="dv">2</span>
      <span class="kw">else</span>
        let pow = <span class="fu">pow</span>(pow - <span class="dv">1</span>) in
          pow * <span class="fu">pow</span>(pow - <span class="dv">2</span>)
<a href='' id='Comment:Eval40' ></a></code></pre><p>This is the same as the following function, in which variables are renamed to be less confusing: <a href='' id='Comment:Eval53' ></a></p><pre class="sourceCode Java"><code class="sourceCode java">    function <span class="fu">pow</span>(a)
      <span class="kw">if</span> a &lt;= <span class="dv">0</span> then
        <span class="dv">2</span>
      <span class="kw">else</span>
        let b = <span class="fu">pow</span>(a - <span class="dv">1</span>) in
          b * <span class="fu">pow</span>(b - <span class="dv">2</span>)
<a href='' id='Comment:Eval42' ></a></code></pre><p>When renaming variables, the <em>functions</em> are <em>not</em> renamed. This is because functions and variables are in separate namespaces. <a href='' id='Comment:Eval54' ></a></p><p>Another consequence of the separation between variable and function namespaces is that functions can not be passed as arguments to other functions, or returned as values from functions. In the expression <code>pow(pow)</code> the two uses of <code>pow</code> are completely distinct. This is analogous to the concept of a <a href="http://en.wikipedia.org/wiki/Homonym"><em>homonym</em></a> in natural languages. The exact same word has two completely different meanings, which are distinguished only by context. English has many homonyms, including ‘stalk’ and ‘left’. In our expression language, the first <code>pow</code> must mean the function because it appears in front of a parenthesis where a function name is expected, while the second <code>pow</code> must be a variable because it appears where an expression is expected. <a href='' id='Comment:Eval55' ></a></p><p>In this language functions are <em>not</em> values. When something is treated specially in a programming language, so that it cannot be used where a any value is allowed, it is called <em>second class</em>. <a href='' id='Comment:Eval56' ></a></p><p>It is worth noting that many of the example functions presented above, including <code>power</code> and <code>pow</code>, are <em>recursive</em>. Recursion is possible because the function definitions can be used in any expression, including in the body of the functions themselves. This means that all functions have <em>global scope</em>. <a href='' id='Comment:Eval57' ></a></p><h3 id="stack-diagrams"><a href="#stack-diagrams"><span class="header-section-number">4.1.2</span> Stack Diagrams</a></h3><p>TODO: illustrate how stacks work in languages that don’t have first-class functions <a href='' id='Comment:Stac2' ></a></p><h3 id="summary-1"><a href="#summary-1"><span class="header-section-number">4.1.3</span> Summary</a></h3><p>Here is the full code for the evaluator supporting top-level functions definitions. <a href='' id='Comment:Summ1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Literal</span>   <span class="dt">Value</span>
         <span class="fu">|</span> <span class="dt">Unary</span>     <span class="dt">UnaryOp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Binary</span>    <span class="dt">BinaryOp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">If</span>        <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Variable</span>  <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">Let</span>       <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Call</span>      <span class="dt">String</span> [<span class="dt">Exp</span>]
  <span class="kw">deriving</span> <span class="dt">Show</span>
      
<span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">FunEnv</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env funEnv      <span class="fu">=</span> v

evaluate (<span class="dt">Unary</span> op a) env funEnv     <span class="fu">=</span> 
  unary op (evaluate a env funEnv)

evaluate (<span class="dt">Binary</span> op a b) env funEnv  <span class="fu">=</span> 
  binary op (evaluate a env funEnv) (evaluate b env funEnv)

evaluate (<span class="dt">If</span> a b c) env funEnv       <span class="fu">=</span> 
  <span class="kw">let</span> <span class="dt">BoolV</span> test <span class="fu">=</span> evaluate a env funEnv <span class="kw">in</span>
    <span class="kw">if</span> test <span class="kw">then</span> evaluate b env funEnv
            <span class="kw">else</span> evaluate c env funEnv

evaluate (<span class="dt">Variable</span> x) env funEnv     <span class="fu">=</span> fromJust (lookup x env)

evaluate (<span class="dt">Let</span> x exp body) env funEnv <span class="fu">=</span> evaluate body newEnv funEnv
  <span class="kw">where</span> newEnv <span class="fu">=</span> (x, evaluate exp env funEnv) <span class="fu">:</span> env

evaluate (<span class="dt">Call</span> fun args) env funEnv   <span class="fu">=</span> evaluate body newEnv funEnv
  <span class="kw">where</span> <span class="dt">Function</span> xs body <span class="fu">=</span> fromJust (lookup fun funEnv)
        newEnv <span class="fu">=</span> zip xs [evaluate a env funEnv <span class="fu">|</span> a <span class="ot">&lt;-</span> args]
<span class="co">-- <a href='' id='Comment:Summ12' ></a></span></code></pre><h4 id="exercise-3.1-stack-based-evaluation"><a href="#exercise-3.1-stack-based-evaluation"><span class="header-section-number">4.1.3.1</span> Exercise 3.1: Stack-based evaluation</a></h4><p>Modify the evaluator for top-level functions to use a stack with a list of values, rather than an environment. Use a function to look up the position of a variable in an argument list, then access the corresponding position from the top of the stack. <a href='' id='Comment:Exer3' ></a></p><h2 id="first-class-functions"><a href="#first-class-functions"><span class="header-section-number">4.2</span> First-Class Functions</a></h2><p>In the <a href="#TopLevel">Section on Top-Level Functions</a>, function definitions were defined using special syntax and only at the top of a program. The function names and the variable names are in different namespaces. One consequence of this is that all the expressive power we have built into our language, for local variables, conditionals and even functions, does not work for creating function themselves. If you believe that functions are useful for writing reusable computations, as suggested above, then it should be useful to use functions to create and operate on functions. In this section we rework the concept of functions presented above to integrate them into the language, so that functions are <em>first-class</em> values. <a href='' id='Comment:Firs2' ></a></p><p>Consider the following function definition: <a href='' id='Comment:Firs3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">f(x) <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">2</span>
<span class="co">-- <a href='' id='Comment:Firs4' ></a></span></code></pre><p>The intent here is to define <code>f</code>, but it doesn’t really say what <code>f</code> is, it only says what <code>f</code> does when applied to an argument. A true definition for <code>f</code> would have the form <code>f = ...</code>. <a href='' id='Comment:Firs5' ></a></p><p>Finding a value for <code>f</code> is related the idea of solving equations in basic algebra. For example, consider this equation: <a href='' id='Comment:Firs6' ></a></p><p><span class="math">\(x^2 = 5\)</span> <a href='' id='Comment:Firs7' ></a></p><p>This means that <span class="math">\(x\)</span> is value that when squared equals <span class="math">\(5\)</span>. We can solve this equation to compute the value of <span class="math">\(x\)</span>: <a href='' id='Comment:Firs8' ></a></p><p><span class="math">\(x = \sqrt{5}\)</span> <a href='' id='Comment:Firs9' ></a></p><p>But this involved creating a new concept, the <em>square root</em> of a number. We know we have a solution for a variable when the variable appears by itself on the left side of an equation. <a href='' id='Comment:Firs10' ></a></p><p>The function definition <code>f(x) = x * 2</code> is similar. It means that <code>f</code> is a function that when applied to an argument <code>x</code> computes the value <code>x * 2</code>. <em>But we don’t have a solution for</em> <code>f</code>, because <code>f</code> does not appear on the left side of an equation by itself. To ‘solve for <code>f</code>’ we need some new notation, just the way that the square root symbol <span class="math">\(\sqrt{x}\)</span> was introduced to represent a new operation. <a href='' id='Comment:Firs11' ></a></p><h2 id="lambda-notation"><a href="#lambda-notation"><span class="header-section-number">4.3</span> Lambda Notation</a></h2><p>The standard solution is to use a <em>lambda expression</em>, or <em>function expression</em>, which is a special notation for representing a function. Here is a solution for <code>f</code> using a lambda: <a href='' id='Comment:Lamb2' ></a></p><p><code>f =</code> <span class="math">\(\lambda\)</span><code>x</code>. <code>x * 2</code> <a href='' id='Comment:Lamb3' ></a></p><p>The symbol <span class="math">\(\lambda\)</span> is the greek letter <em>lambda</em>. Just like the symbol <span class="math">\(\sqrt{x}\)</span>, <span class="math">\(\lambda\)</span> has no inherent meaning, but is assigned a meaning for our purposes. The general form of a function expression is: <a href='' id='Comment:Lamb4' ></a></p><p><span class="math">\(\lambda\)</span><em>var</em>. <em>body</em> <a href='' id='Comment:Lamb5' ></a></p><p>This represents a function with parameter <em>var</em> that computes a result defined by the <em>body</em> expression. The <em>var</em> may of course be used within the <em>body</em>. In other words, <em>var</em> may be free in <em>body</em>, but <em>var</em> is bound (not free) in <span class="math">\(\lambda\)</span><em>var</em>. <em>body</em>. A function expression is sometimes called an <em>abstraction</em> or a <em>function abstraction</em> (TODO: discuss this more later). <a href='' id='Comment:Lamb6' ></a></p><p>Thus <code>f =</code> <span class="math">\(\lambda\)</span><code>x</code>. <code>x * 2</code> means that <code>f</code> is defined to be a function of one parameter <code>x</code> that computes the result <code>x * 2</code> when applied to an argument. One benefit of function expressions is that we don’t need special syntax to name functions, which was needed in dealing with <a href="#TopLevel">top-level functions</a>. Instead, we can use the existing <code>let</code> expression to name functions, because functions are just another kind of value. <a href='' id='Comment:Lamb7' ></a></p><p>Lambda notation was invented in 1930s by <a href="http://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>, who was investigating the foundations of functions. Lambda notation is just one part of the <a href="http://en.wikipedia.org/wiki/Lambda_calculus"><em>lambda calculus</em></a>, which is an extremely elegant analysis of functions. Lambda calculus has had huge influence on programming languages. We will study the lambda calculus in more detail in a later section, but the basic concepts are introduced here. <a href='' id='Comment:Lamb8' ></a></p><h3 id="LambdaDefinition"><a href="#LambdaDefinition"><span class="header-section-number">4.3.1</span> Using Lambdas in Haskell</a></h3><p>Haskell is based directly on the lambda calculus. In fact, the example illustrating how to “solve” for the function <code>f</code> can be written in Haskell. The <a href="./code/Examples.hs.htm">Examples</a> file contains the code for the simples examples in this section, while the <a href="./code/FunExamples.hs.htm">Function Examples</a> file contains the more complex examples given in the subsections below. The following definitions are all equivalent in Haskell: <a href='' id='Comment:Usin2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">f(x) <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">2</span>
f x  <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">2</span>
f <span class="fu">=</span> \x <span class="ot">-&gt;</span> x <span class="fu">*</span> <span class="dv">2</span>
<span class="co">-- <a href='' id='Comment:Usin3' ></a></span></code></pre><p>The last example uses Haskell’s notation for writing a lambda expression. Because <span class="math">\(\lambda\)</span> is not a standard character on most keyboards (and it is not part of ASCII), Haskell uses an <em>ASCII art</em> rendition of <span class="math">\(\lambda\)</span> as a backslash <code>\\</code>. The dot used in a traditional lambda expression is replaced by ASCII art <code>-&gt;</code> for an arrow. The idea is that the function maps from <code>x</code> to its result, so an arrow makes some sense. <a href='' id='Comment:Usin4' ></a></p><p>The concept illustrated above is an important general rule, which we will call the <em>Rule of Function Arguments</em>: <a href='' id='Comment:Usin5' ></a></p><p>    <code>name var = body</code>      <span class="math">\(\equiv\)</span>      <code>name = \var -&gt; body</code> <a href='' id='Comment:Usin6' ></a></p><p>A parameter can always be moved from the left of an equality sign to the right. Haskell programmers prefer to write them on the left of the equals if possible, thus avoiding explicit use (and somewhat ugly ASCII encoding) of lambdas. Technically in Haskell the <code>var</code> can be any pattern, but for now we will focus on the case where the pattern is just a single variable. (TODO: see later chapter?) Since every function definition in Haskell is implicitly a lambda expression, you have already been using lambdas without realizing it. As the old dishwashing soap commercial said “You are soaking in it.” <a href='' id='Comment:Usin7' ></a></p><h3 id="function-calls"><a href="#function-calls"><span class="header-section-number">4.3.2</span> Function Calls</a></h3><p>A function call in Haskell is represented by placing one expression next to another expression. Placing two expressions next to each other is sometimes called <em>juxtaposition</em>. It is useful to think of juxtaposition as an operator much like <code>+</code>. The only difference is that juxtaposition is the <em>invisible</em> operator. In other words, just as <code>n+m</code> means addition, <code>f n</code> means function call. This is not to say that the space character is an operator, because the space is only needed to separate the two characters, which otherwise would be a single symbol <code>fn</code>. It is legal to add parenthesis, yielding the more traditional function call syntax, <code>f(n)</code>, just as it is legal (but useless) to add parentheses to <code>n+(m)</code>. A function call in Haskell can also be written as <code>(f)n</code> or <code>(f)(n)</code>. There are no spaces in these examples, but they do exhibit juxtaposition of two expressions.<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> <a href='' id='Comment:Func1' ></a></p><p>Haskell has the property that definitions really are equations, so that it is legal to substitute <code>f</code> for <code>\x -&gt; x * 2</code> anywhere that <code>f</code> occurs. For example, we normally perform a function call <code>f(3)</code> by looking up the definition of <code>f</code> and then evaluating the body of the function in the normal way. However, it is also legal to substitute <code>f</code> for its definition. <a href='' id='Comment:Func14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- version A</span>
f(<span class="dv">3</span>)
<span class="co">-- <a href='' id='Comment:Func16' ></a></span></code></pre><p>In this form, the function <code>f</code> is <em>applied</em> to the argument <code>3</code>. The expression <code>f(3)</code> is called a function <em>application</em>. In this book I use “function call” and “function application” interchangeably. <a href='' id='Comment:Func6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- version B</span>
(\x <span class="ot">-&gt;</span> x <span class="fu">*</span> <span class="dv">2</span>)(<span class="dv">3</span>)
<span class="co">-- <a href='' id='Comment:Func7' ></a></span></code></pre><p>The A and B versions of this expression are equivalent. The latter is a juxtaposition of a function expression <code>\x-&gt;x * 2</code> with its argument, <code>3</code>. When a function expression is used on its own, without giving it a name, it is called an <em>anonymous function</em>. <a href='' id='Comment:Func8' ></a></p><p>The <em>Rule of Function Invocation</em> says that applying a function expression to an argument is evaluated by substituting the argument in place of the function’s bound variable everywhere it occurs in the body of the function expression. <a href='' id='Comment:Func9' ></a></p><p><strong>Rule of Function Invocation</strong> (informal): <a href='' id='Comment:Func10' ></a></p><p>(<span class="math">\(\lambda\)</span><em>var</em>. <em>body</em>)arg    <strong>evaluates to</strong>     <em>body</em> with <em>arg</em> substituted for <em>var</em> <a href='' id='Comment:Func11' ></a></p><p>For now this is an informal definition. We will make it more precise when we write an evaluator that handles function expressions correctly. <a href='' id='Comment:Func12' ></a></p><h2 id="FirstClassExamples"><a href="#FirstClassExamples"><span class="header-section-number">4.4</span> Examples of First-Class Functions</a></h2><p>Before we begin a full analysis of the semantics of first-class functions, and subsequently implementing them in Haskell, it is useful to explore some examples of first-class functions. Even if you have used first-class functions before, you might find these examples interesting. <a href='' id='Comment:Exam2' ></a></p><h3 id="Compose"><a href="#Compose"><span class="header-section-number">4.4.1</span> Function Composition</a></h3><p>One of the simplest examples of a using functions as values is defining a general operator for <em>function composition</em>. The composition <span class="math">\(f \circ g\)</span> of two functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span> is a new function that first performs <span class="math">\(g\)</span> on an input, then performs <span class="math">\(f\)</span> on the result. Composition can be defined in Haskell as: <a href='' id='Comment:Func15' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">compose f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f(g x)
<span class="co">-- <a href='' id='Comment:Func17' ></a></span></code></pre><p>The two arguments are both functions, and the result of composition is also a function. The type of <code>compose</code> is <a href='' id='Comment:Func18' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)
<span class="co">-- <a href='' id='Comment:Func5' ></a></span></code></pre><p>As an example of function composition, consider two functions that operate on numbers: <a href='' id='Comment:Func19' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">square n <span class="fu">=</span> n <span class="fu">*</span> n
mulPi m <span class="fu">=</span> pi <span class="fu">*</span> m
<span class="co">-- <a href='' id='Comment:Func20' ></a></span></code></pre><p>Now using composition we can define a function for computing the area of a circle, given the radius: <a href='' id='Comment:Func21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">areaR <span class="fu">=</span> compose mulPi square
<span class="co">-- <a href='' id='Comment:Func22' ></a></span></code></pre><p>To compute the area given the diameter, we can compose this function with a function that divides by two: <a href='' id='Comment:Func23' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">areaD <span class="fu">=</span> compose areaR (\x <span class="ot">-&gt;</span> x <span class="fu">/</span> <span class="dv">2</span>)
<span class="co">-- <a href='' id='Comment:Func24' ></a></span></code></pre><h3 id="Map"><a href="#Map"><span class="header-section-number">4.4.2</span> Mapping</a></h3><p>One of the earliest and widely cited examples of first class functions is in the definition of a <code>map</code> function, which applies a function to every element of a list, creating a new list with the results. <a href='' id='Comment:Mapp2' ></a></p><p>For example, given the standard Haskell function <code>negate</code> that inverts the sign of a number, it is easy to quickly negate a list of numbers: <a href='' id='Comment:Mapp3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">map negate [<span class="dv">1</span>, <span class="dv">3</span>, <span class="fu">-</span><span class="dv">7</span>, <span class="dv">0</span>, <span class="dv">12</span>]   
<span class="co">-- returns [-1, -3, 7, 0, -12]</span>
<span class="co">-- <a href='' id='Comment:Mapp4' ></a></span></code></pre><p>The <code>map</code> function takes a function as an argument. You can see that <code>map</code> takes a function argument by looking at its type: <a href='' id='Comment:Mapp5' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
<span class="co">-- <a href='' id='Comment:Mapp6' ></a></span></code></pre><p>The first argument <code>a -&gt; b</code> is a function from <code>a</code> to <code>b</code> where <code>a</code> and <code>b</code> are arbitrary types. <a href='' id='Comment:Mapp7' ></a></p><p>Personally, I tend to use list comprehensions rather than <code>map</code>, because list comprehensions give a nice name to the items of the list. Here is an equivalent example using comprehensions: <a href='' id='Comment:Mapp8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">[ negate n <span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="fu">-</span><span class="dv">7</span>, <span class="dv">0</span>, <span class="dv">12</span>] ]   
<span class="co">-- returns [-1, -3, 7, 0, -12]</span>
<span class="co">-- <a href='' id='Comment:Mapp9' ></a></span></code></pre><p>A function that takes another function as an input is called a <em>higher-order function</em>. Higher-order functions are quite useful, but what I find even more interesting are functions that <em>return</em> functions as results. <a href='' id='Comment:Mapp10' ></a></p><p>The comprehensions used earlier in this document could be replace by invocations of <code>map</code>: <a href='' id='Comment:Mapp11' ></a></p><p><code>[evaluate a env BAR a &lt;- args]</code>      <span class="math">\(\equiv\)</span>      <code>map (\a-&gt; evaluate a env) args</code> <a href='' id='Comment:Mapp12' ></a></p><p>TODO: make a comment about point-free style? <a href='' id='Comment:Mapp13' ></a></p><p>TODO: is a function that returns a function also called higher order? <a href='' id='Comment:Mapp14' ></a></p><h3 id="EnvAsFun"><a href="#EnvAsFun"><span class="header-section-number">4.4.3</span> Representing Environments as Functions</a></h3><p>In <a href="#Chapter1">Chapter 1</a>, an environment was defined as a list of bindings. However, it is often useful to consider the <em>behavior</em> of a concept rather than its concrete <em>representation</em>. The purpose of a environment is to map variable names to values. A map is just another name for a function. Thus it is very reasonable to think of an environment as a <em>function</em> from names to values. Consider the environment <a href='' id='Comment:Repr2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EnvL</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Value</span>)]
envL1 <span class="fu">=</span> [(<span class="st">&quot;x&quot;</span>, <span class="dt">IntV</span> <span class="dv">3</span>), (<span class="st">&quot;y&quot;</span>, <span class="dt">IntV</span> <span class="dv">4</span>), (<span class="st">&quot;size&quot;</span>, <span class="dt">IntV</span> <span class="dv">10</span>)]
<span class="co">-- <a href='' id='Comment:Repr3' ></a></span></code></pre><p>Since environments always have a finite number of bindings, it is more precise to say that an environment is a <em>partial function</em> from names to values. A partial function is one that produces a result for only some of its inputs. One common way to implement partial functions in Haskell is by using the <code>Maybe</code> type, which allows a function to return a value (tagged by <code>Just</code>) or <code>Nothing</code>. Here is an implementation of the same environment as a function: <a href='' id='Comment:Repr4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EnvF</span> <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span>
<span class="co">-- <a href='' id='Comment:Repl801' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell">envF1 <span class="st">&quot;x&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">IntV</span> <span class="dv">3</span>)
envF1 <span class="st">&quot;y&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">IntV</span> <span class="dv">4</span>)
envF1 <span class="st">&quot;size&quot;</span> <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">IntV</span> <span class="dv">10</span>)
envF1 _      <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="co">-- <a href='' id='Comment:Repr5' ></a></span></code></pre><p>Looking up the value of a variable in either of these environments is quite different: <a href='' id='Comment:Repr6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">x1 <span class="fu">=</span> lookup <span class="st">&quot;x&quot;</span> envL1
x2 <span class="fu">=</span> envF1 <span class="st">&quot;x&quot;</span>
<span class="co">-- <a href='' id='Comment:Repr7' ></a></span></code></pre><p>The <code>lookup</code> function searches a list environment <code>envL1</code> for an appropriate binding. An functional environment <code>envF1</code> is applied to the name to get the result. One benefit of the function environment is that we don’t need to know how the bindings are represented. All we need to do is call it to get the desired answer.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> There is no need to use a <code>lookup</code> function, because the functional environment <em>is</em> the lookup function. <a href='' id='Comment:Repr8' ></a></p><p>The only other thing that is done with an environment is to extend it with additional bindings. Let’s define bind functions that add a binding to an environment, represented as lists or functions. For lists, the <code>bindL</code> function creates a binding <code>(val, val)</code> and then prepends it to the front of the list: <a href='' id='Comment:Repr10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">bindL ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">EnvL</span> <span class="ot">-&gt;</span> <span class="dt">EnvL</span>
bindL var val env <span class="fu">=</span> (var, val) <span class="fu">:</span> env
<span class="co">-- <a href='' id='Comment:Repr11' ></a></span></code></pre><p>Since <code>lookup</code> searches lists from the front, this new binding can shadow existing bindings. <a href='' id='Comment:Repr12' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">envL2 <span class="fu">=</span> bindL <span class="st">&quot;z&quot;</span> (<span class="dt">IntV</span> <span class="dv">5</span>) envL1
   <span class="co">-- [(&quot;z&quot;, IntV 5), (&quot;x&quot;, IntV 3), (&quot;y&quot;, IntV 4), (&quot;size&quot;, IntV 10)]</span>
envL3 <span class="fu">=</span> bindL <span class="st">&quot;x&quot;</span> (<span class="dt">IntV</span> <span class="dv">9</span>) envL1
   <span class="co">-- [(&quot;x&quot;, IntV 9), (&quot;x&quot;, IntV 3), (&quot;y&quot;, IntV 4), (&quot;size&quot;, IntV 10)]</span>
<span class="co">-- <a href='' id='Comment:Repr13' ></a></span></code></pre><p>To extend an environment expressed as a partial function, we need to write a <em>higher-order</em> function. A higher-order function is one that takes a function as input or returns a function as an result. The function <code>bindF</code> takes an <code>EnvF</code> as an input and returns a new <code>EnvF</code>. <a href='' id='Comment:Repr14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- bindF :: String -&gt; Value -&gt; EnvF -&gt; EnvF</span>
<span class="co">-- <a href='' id='Comment:Repr15' ></a></span></code></pre><p>Expanding the definition of <code>EnvF</code> makes the higher-order nature of <code>bindF</code> clear: <a href='' id='Comment:Repr16' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">bindF ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>)
<span class="co">-- <a href='' id='Comment:Repr17' ></a></span></code></pre><p>The definition of <code>bindF</code> is quite different from <code>bindL</code>: <a href='' id='Comment:Repr18' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">bindF var val env <span class="fu">=</span> \testVar <span class="ot">-&gt;</span> <span class="kw">if</span> testVar <span class="fu">==</span> var
                                <span class="kw">then</span> <span class="dt">Just</span> val
                                <span class="kw">else</span> env testVar
<span class="co">-- <a href='' id='Comment:Repr19' ></a></span></code></pre><p>Understanding how this function works takes a little time. The first thing to keep in mind is that <code>env</code> is a function. It is a function representing an environment, thus it has type <code>EnvF = String -&gt; Maybe Int</code>. The other arguments, <code>var</code> and <code>val</code> are the same as for <code>bindL</code>: a string and an integer. <a href='' id='Comment:Repr20' ></a></p><p>The second thing to notice is that the return value (the expression on the right side of the <code>=</code> sign) is a function expression <code>\testVar -&gt; ...</code>. That means the return value is a function. The argument of this function is named <code>testVar</code> and the body of the function is a conditional expression. The conditional expression checks if <code>testVar</code> is equal to <code>var</code>. It returns <code>val</code> if they are equal, and otherwise it calls the function <code>env</code> with <code>testVar</code> as an argument. <a href='' id='Comment:Repr21' ></a></p><p>The key to understanding how this works is to keep in mind that there are two very different <em>times</em> or <em>contexts</em> involved in <code>bindF</code>. The first time is when an environment is being extended with a new binding. At this time the arguments <code>var</code>, <code>val</code>, and <code>env</code> are determined. The second important time is when the newly extended environment is searched for a particular variable. This is when <code>testVar</code> is bound. Since the environment can be searched many times, <code>testVar</code> will be bound many times. Consider a specific example: <a href='' id='Comment:Repr22' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- version A</span>
envF2 <span class="fu">=</span> bindF <span class="st">&quot;z&quot;</span> (<span class="dt">IntV</span> <span class="dv">5</span>) envF1
<span class="co">-- <a href='' id='Comment:Repr23' ></a></span></code></pre><p>Let’s execute this program manually. The call to <code>bindF</code> has three arguments, creating these bindings: <code>var</code> <span class="math">\(\mapsto\)</span> <code>&quot;z&quot;</code>, <code>val</code> <span class="math">\(\mapsto\)</span> <code>5</code>, <code>env</code> <span class="math">\(\mapsto\)</span> <code>envF1</code>. Substituting these bindings into the definition of <code>bindF</code> gives <a href='' id='Comment:Repr24' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- version B</span>
envF2 <span class="fu">=</span> \testVar <span class="ot">-&gt;</span> <span class="kw">if</span> testVar <span class="fu">==</span> <span class="st">&quot;z&quot;</span>
                    <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">IntV</span> <span class="dv">5</span>)
                    <span class="kw">else</span> envF1 testVar
<span class="co">-- <a href='' id='Comment:Repr25' ></a></span></code></pre><p>This makes more sense! It says that <code>envF2</code> is a function that takes a variable name as an argument. It first tests if the variable is named <code>z</code> and if so it returns 5. Otherwise it returns what <code>envF1</code> returns for that variable. Another way to write this function is <a href='' id='Comment:Repr26' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- version C</span>
envF2 <span class="st">&quot;z&quot;</span> <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">IntV</span> <span class="dv">5</span>)
envF2 testVar <span class="fu">=</span> envF1 testVar
<span class="co">-- <a href='' id='Comment:Repr27' ></a></span></code></pre><p>These two versions are the same because of the way Haskell deals with functions defined by cases: it tries the first case (argument == <code>&quot;z&quot;</code>), else it tries the second case. Since <code>bindF</code> tests for the most recently bound variable first, before calling the base environment, variables are properly shadowed when redefined. <a href='' id='Comment:Repr28' ></a></p><p>It is also useful to consider the <em>empty</em> environment for both list and function environments. <a href='' id='Comment:Repr29' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">emptyEnvL ::</span> <span class="dt">EnvL</span>
emptyEnvL <span class="fu">=</span> []
<span class="co">-- <a href='' id='Comment:Repr30' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">emptyEnvF ::</span> <span class="dt">EnvF</span>
emptyEnvF <span class="fu">=</span> \var <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="co">-- <a href='' id='Comment:Repr31' ></a></span></code></pre><p>The empty function environment <code>emptyEnvF</code> is interesting: it maps every variable name to <code>Nothing</code>. <a href='' id='Comment:Repr32' ></a></p><p>In conclusion, functions can be used to represent environments. This example illustrates passing a function as an argument as well as returning a function as a value. The environment-based evaluators for <a href="#BasicEvalEnv">expressions</a> and <a href="#EvalTopLevel">top-level functions</a> could be easily modified to use functional environments rather than lists of bindings. For example, the environment-based evaluation function becomes: <a href='' id='Comment:Repr33' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Evaluate an expression in a (functional) environment</span>
<span class="ot">evaluateF ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">EnvF</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evaluateF (<span class="dt">Literal</span> v) env      <span class="fu">=</span> v
evaluateF (<span class="dt">Unary</span> op a) env     <span class="fu">=</span> unary op (evaluateF a env)
evaluateF (<span class="dt">Binary</span> op a b) env  <span class="fu">=</span> binary op (evaluateF a env) (evaluateF b env)
evaluateF (<span class="dt">Variable</span> x) env     <span class="fu">=</span> fromJust (env x)        <span class="co">-- changed</span>
evaluateF (<span class="dt">Let</span> x exp body) env <span class="fu">=</span> evaluateF body newEnv
  <span class="kw">where</span> newEnv <span class="fu">=</span> bindF x (evaluateF exp env) env             <span class="co">-- changed</span>
<span class="co">-- <a href='' id='Comment:Repr34' ></a></span></code></pre><p>The result looks better than the previous version, because it does not have spurious references to list functions <code>lookup</code> and <code>:</code>, which are a distraction from the fundamental nature of environments as maps from names to values. It is still OK to think of environments as ‘data’, because functions are data and this function is being used to represent an environment. In this case it is a functional representation of data. In the end, the line between data and behavior and data is quite blurry. <a href='' id='Comment:Repr35' ></a></p><p>TODO: define “shadow” and use it in the right places. <a href='' id='Comment:Repr36' ></a></p><h3 id="Curry"><a href="#Curry"><span class="header-section-number">4.4.4</span> Multiple Arguments and Currying</a></h3><p>Functions in the lambda calculus always have exactly <em>one</em> argument. If Haskell is based on Lambda calculus, how should we understand all the functions we’ve defined with multiple arguments? The answer is surprisingly subtle. Let’s consider a very simple Haskell function that appears to have two arguments: <a href='' id='Comment:Mult1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">add a b <span class="fu">=</span> b <span class="fu">+</span> a
<span class="co">-- <a href='' id='Comment:Mult29' ></a></span></code></pre><p>The <a href="#LambdaDefinition">Rule of Function Arguments</a> for Haskell says that arguments on the left of a definition are short-hand for lambdas. The <code>b</code> argument can be moved to the right hand side to get an equivalent definition: <a href='' id='Comment:Mult30' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">add a <span class="fu">=</span> \b <span class="ot">-&gt;</span> b <span class="fu">+</span> a
<span class="co">-- <a href='' id='Comment:Mult31' ></a></span></code></pre><p>Now the <code>a</code> argument can also be moved. We have now “solved” for <code>add</code>: <a href='' id='Comment:Mult32' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">add <span class="fu">=</span> \a <span class="ot">-&gt;</span> \b <span class="ot">-&gt;</span> b <span class="fu">+</span> a
<span class="co">-- <a href='' id='Comment:Mult33' ></a></span></code></pre><p>It’s useful to add parentheses to make the grouping explicit: <a href='' id='Comment:Mult34' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">add <span class="fu">=</span> \a <span class="ot">-&gt;</span> (\b <span class="ot">-&gt;</span> b <span class="fu">+</span> a)
<span class="co">-- <a href='' id='Comment:Mult35' ></a></span></code></pre><p>What this means is that <code>add</code> is a function of one argument <code>a</code> whose return value is the function <code>\b -&gt; b + a</code>. The function that is returned also takes one argument, named <code>b</code>, and finally returns the value of <code>b + a</code>. In other words, a function of two arguments is actually a function that takes the first argument and returns a new function that takes the second argument. Even for this simplest case Haskell uses a function returning a function! <a href='' id='Comment:Mult36' ></a></p><p>One consequence of this arrangement is that it is possible to apply the <code>add</code> function to the arguments one at a time. For example applying <code>add</code> to just one argument returns a new function: <a href='' id='Comment:Mult37' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">inc <span class="fu">=</span> add <span class="dv">1</span>      <span class="co">-- \b. b + 1</span>
dec <span class="fu">=</span> add (<span class="fu">-</span><span class="dv">1</span>)   <span class="co">-- \b. b + (-1)</span>
<span class="co">-- <a href='' id='Comment:Mult12' ></a></span></code></pre><p>These two functions each take a single argument. The first adds one to its argument. The second subtracts one. Here are two examples that use the resulting functions: <a href='' id='Comment:Mult38' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">eleven <span class="fu">=</span> inc <span class="dv">10</span>
nine   <span class="fu">=</span> dec <span class="dv">10</span>
<span class="co">-- <a href='' id='Comment:Mult39' ></a></span></code></pre><p>To see how the definition of <code>inc</code> works, we can analyze the function call <code>add 1</code> in more detail. Replacing <code>add</code> by its definition yields: <a href='' id='Comment:Mult40' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">inc <span class="fu">=</span> (\a <span class="ot">-&gt;</span> (\b <span class="ot">-&gt;</span> b <span class="fu">+</span> a)) <span class="dv">1</span>
<span class="co">-- <a href='' id='Comment:Mult41' ></a></span></code></pre><p>The Rule of Function Invocation says that in this situation, <code>a</code> is substituted for <code>1</code> in the body <code>\b -&gt; b + a</code> to yield: <a href='' id='Comment:Mult17' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">inc <span class="fu">=</span> \b <span class="ot">-&gt;</span> b <span class="fu">+</span> <span class="dv">1</span>
<span class="co">-- <a href='' id='Comment:Mult18' ></a></span></code></pre><p>Which is the same (by the <a href="#LambdaDefinition">Rule of Function Arguments</a>) as: <a href='' id='Comment:Mult19' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">inc b <span class="fu">=</span> b <span class="fu">+</span> <span class="dv">1</span>
<span class="co">-- <a href='' id='Comment:Mult20' ></a></span></code></pre><p>One way to look at what is going on here is that the two arguments are split into stages. Normally both arguments are supplied at the same time, so the two stages happen simultaneously. However, it is legal to perform the stages at different times. After completing the first stage to create an increment/decrement function, the new increment/decrement function can be used many times. <a href='' id='Comment:Mult21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">inc <span class="dv">5</span> <span class="fu">+</span> inc <span class="dv">10</span> <span class="fu">+</span> dec <span class="dv">20</span> <span class="fu">+</span> dec <span class="dv">100</span>
<span class="co">-- <a href='' id='Comment:Mult22' ></a></span></code></pre><p>(remember that this means <code>(inc 5) + (inc 10) + (dec 20) + (dec 100)</code>) <a href='' id='Comment:Mult23' ></a></p><p>Separation of arguments into different stages is exactly the same technique used in the <a href="#EnvAsFun">section on representing environments as functions</a>. The <code>bindF</code> function takes three arguments in the first stage, and then returns a function of one argument that is invoked in a second stage. To make it look nice, the first three arguments were listed to the left of the <code>=</code> sign, while the last argument was placed to the right as an explicit lambda. However, this choice of staging is just the intended use of the function. The function could also have been defined as follows: <a href='' id='Comment:Mult24' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">bindF var val env testVar <span class="fu">=</span> <span class="kw">if</span> testVar <span class="fu">==</span> var
                            <span class="kw">then</span> <span class="dt">Just</span> val
                            <span class="kw">else</span> env testVar
<span class="co">-- <a href='' id='Comment:Mult25' ></a></span></code></pre><p>The ability to selectively stage functions suggests a design principle for Haskell that is not found in most other languages: <em>place arguments that change most frequently at the end of the argument list</em>. Conversely, arguments that change rarely should be placed early in the argument list. <a href='' id='Comment:Mult26' ></a></p><p>TODO: talk about pairs and define curry/uncurry <a href='' id='Comment:Mult27' ></a></p><h3 id="church-encodings"><a href="#church-encodings"><span class="header-section-number">4.4.5</span> Church Encodings</a></h3><p>Other kinds of data besides environments can be represented as functions. These examples are known as Church encodings. <a href='' id='Comment:Chur2' ></a></p><h4 id="booleans"><a href="#booleans"><span class="header-section-number">4.4.5.1</span> Booleans</a></h4><p>Booleans represent a choice between two alternatives. Viewing the boolean itself as a behavior leads to a view of a boolean as a function that chooses between two options. One way to represent a choice is by a function with two arguments that returns one or the other of the inputs: <a href='' id='Comment:Bool2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">true  x y <span class="fu">=</span> x
false x y <span class="fu">=</span> y
<span class="co">-- <a href='' id='Comment:Bool3' ></a></span></code></pre><p>The <code>true</code> function returns its first argument. The <code>false</code> function returns its second argument. For example <code>true 0 1</code> returns <code>0</code> while <code>false &quot;yes&quot; &quot;no&quot;</code> returns <code>&quot;no&quot;</code>. One way to write the type for booleans is a generic type: <a href='' id='Comment:Bool4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">BooleanF</span> <span class="fu">=</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">true ::</span> <span class="dt">BooleanF</span>
<span class="ot">false ::</span> <span class="dt">BooleanF</span>
<span class="co">-- <a href='' id='Comment:Bool5' ></a></span></code></pre><p>Things get more interesting when performing operations on booleans. Negation of a boolean <code>b</code> returns the result of applying <code>b</code> to <code>false</code> and <code>true</code>. If <code>b</code> is true then it will return the first argument, <code>false</code>. If <code>b</code> is false then it will return the second argument, <code>true</code>. <a href='' id='Comment:Bool6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">notF ::</span> <span class="dt">BooleanF</span> <span class="ot">-&gt;</span> <span class="dt">BooleanF</span>
notF b <span class="fu">=</span> b false true
<span class="co">-- <a href='' id='Comment:Bool7' ></a></span></code></pre><p>The unary function <code>not</code> is a higher-order function: it takes a functional boolean as an input and returns a functional boolean as a result. We can also define binary operations on booleans: <a href='' id='Comment:Bool8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">orF ::</span> <span class="dt">BooleanF</span> <span class="ot">-&gt;</span> <span class="dt">BooleanF</span> <span class="ot">-&gt;</span> <span class="dt">BooleanF</span>
orF a b  <span class="fu">=</span> a true b
<span class="co">-- <a href='' id='Comment:Bool9' ></a></span></code></pre><p>The behavior of “or” is to return true if <code>a</code> is true, and return <code>b</code> if <code>a</code> is false. It works by calling <code>a</code> as a function, passing true and <code>b</code> as arguments. <a href='' id='Comment:Bool10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">andF ::</span> <span class="dt">BooleanF</span> <span class="ot">-&gt;</span> <span class="dt">BooleanF</span> <span class="ot">-&gt;</span> <span class="dt">BooleanF</span>
andF a b <span class="fu">=</span> a b false
<span class="co">-- <a href='' id='Comment:Bool11' ></a></span></code></pre><p>You get the idea. Calling <code>a</code> with <code>b</code> and false as arguments will return <code>b</code> if <code>a</code> is true and false otherwise. <a href='' id='Comment:Bool12' ></a></p><p>To use a Church boolean, the normal syntax for <code>if</code> expressions is completely unnecessary. For example, <a href='' id='Comment:Bool13' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">if</span> not <span class="dt">True</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">2</span>
<span class="co">-- <a href='' id='Comment:Bool14' ></a></span></code></pre><p>is replaced by <a href='' id='Comment:Bool15' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">(notF true) <span class="dv">1</span> <span class="dv">2</span>
<span class="co">-- <a href='' id='Comment:Bool16' ></a></span></code></pre><p>This code is not necessarily more readable, but it is concise. In effect a Church boolean <em>is</em> an <code>if</code> expression: it is a function that chooses one of two alternatives. <a href='' id='Comment:Bool17' ></a></p><h4 id="natural-numbers"><a href="#natural-numbers"><span class="header-section-number">4.4.5.2</span> Natural Numbers</a></h4><p>Natural numbers can also be represented functionally. The Church encoding of natural numbers is known as . The idea behind Church Numerals is related to the Peano axioms of arithmetic. The Peano axioms define a constant <span class="math">\(0\)</span> as the  natural number and a  function, <span class="math">\(succ\)</span>. <span class="math">\(succ\)</span> takes a natural number and returns the  natural number. For example, <a href='' id='Comment:Natu2' ></a></p><p><span class="math">\(1 = succ(0)\)</span> <a href='' id='Comment:Natu3' ></a></p><p><span class="math">\(2 = succ(1) = succ(succ(0))\)</span> <a href='' id='Comment:Natu4' ></a></p><p><span class="math">\(3 = succ(2) = succ(succ(succ(0)))\)</span> <a href='' id='Comment:Natu5' ></a></p><p><span class="math">\(n = succ^n(0)\)</span> <a href='' id='Comment:Natu6' ></a></p><p>The last equation uses the notation <span class="math">\(succ^n\)</span>, which means to apply the successor function <span class="math">\(n\)</span> times. Basic arithmetic can be carried out by applying the following relations. <a href='' id='Comment:Natu7' ></a></p><p><span class="math">\(f^{n + m}(x) = f^n(f^m(x))\)</span> <a href='' id='Comment:Natu8' ></a></p><p><span class="math">\(f^{n * m}(x) = (f^n)^m(x)\)</span> <a href='' id='Comment:Natu9' ></a></p><p>Functionally, we can represent the Church numerals as functions of two arguments, <code>f</code> and <code>x</code>. Thus, a Church numeral is a function, not a simple value like <code>0</code> or <code>1</code>. The Church numeral <code>0</code> applies <code>f</code> zero times to <code>x</code>. Similarly, <code>1</code> applies <code>f</code> once to <code>x</code>. <a href='' id='Comment:Natu10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">zero <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> x
one <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> f x
two <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> f (f x)
three <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> f (f (f x))
<span class="co">-- <a href='' id='Comment:Natu11' ></a></span></code></pre><p>Note that <code>f</code> and <code>x</code> have no restrictions. To demonstrate Church numerals, let us evaluate <code>three</code> by setting <code>f</code> to the successor function <code>(+1)</code> and <code>x</code> to <code>0</code>. <a href='' id='Comment:Natu12' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">three (<span class="fu">+</span><span class="dv">1</span>) <span class="dv">0</span>   <span class="fu">==&gt;</span>   <span class="dv">3</span>
<span class="co">-- <a href='' id='Comment:Natu13' ></a></span></code></pre><p>To further demonstrate the flexibility, suppose we want our Church numerals to start with <code>[]</code> as the base value, and our successor function to append the character <code>'A'</code> to the beginning of the list. <a href='' id='Comment:Natu14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">three (<span class="ch">&#39;A&#39;</span><span class="fu">:</span>) []    <span class="fu">===&gt;</span>    <span class="st">&quot;AAA&quot;</span>
<span class="co">-- <a href='' id='Comment:Natu15' ></a></span></code></pre><p>In Haskell we can write the generic type for Church numerals as <a href='' id='Comment:Natu16' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ChurchN</span> <span class="fu">=</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="co">-- <a href='' id='Comment:Natu17' ></a></span></code></pre><p>If we are given a Haskell <code>Integer</code>, we can represent the equivalent Church numeral with the following Haskell definition. <a href='' id='Comment:Natu18' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">church ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">ChurchN</span>
church <span class="dv">0</span> <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> x
church n <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> f (church (n<span class="fu">-</span><span class="dv">1</span>) f x)
<span class="co">-- <a href='' id='Comment:Natu19' ></a></span></code></pre><p>To retrieve the <code>Integer</code> value of a Church numeral, we can evaluate the lambda using the usual successor and base value. <a href='' id='Comment:Natu20' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">unchurch ::</span> <span class="dt">ChurchN</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
unchurch n <span class="fu">=</span> n (<span class="fu">+</span><span class="dv">1</span>) <span class="dv">0</span>
<span class="co">-- 5 == (unchurch (church 5)) -- this evaluates to True</span>
<span class="co">-- <a href='' id='Comment:Natu21' ></a></span></code></pre><p>We define addition and multiplication in Haskell by using the above arithmetic relations. <a href='' id='Comment:Natu22' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">plus ::</span> <span class="dt">ChurchN</span> <span class="ot">-&gt;</span> <span class="dt">ChurchN</span> <span class="ot">-&gt;</span> <span class="dt">ChurchN</span>
plus n m <span class="fu">=</span> \f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> n f (m f x)
<span class="ot">mul ::</span> <span class="dt">ChurchN</span> <span class="ot">-&gt;</span> <span class="dt">ChurchN</span> <span class="ot">-&gt;</span> <span class="dt">ChurchN</span>
mul n m <span class="fu">=</span> \f <span class="ot">-&gt;</span> n (m f)
<span class="co">-- <a href='' id='Comment:Natu23' ></a></span></code></pre><p>We can use these functions to produce simple arithmetic equations. <a href='' id='Comment:Natu24' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">x <span class="fu">=</span> church <span class="dv">10</span>
y <span class="fu">=</span> church <span class="dv">5</span>
z <span class="fu">=</span> church <span class="dv">2</span>
a <span class="fu">=</span> plus x (mul y z) <span class="co">-- is equivalent to church 20</span>
<span class="co">-- <a href='' id='Comment:Natu25' ></a></span></code></pre><h3 id="relationship-between-let-and-functions"><a href="#relationship-between-let-and-functions"><span class="header-section-number">4.4.6</span> Relationship between Let and Functions</a></h3><p>TODO: prove that <code>let x =</code> <span class="math">\(e\)</span> <code>in</code> <span class="math">\(b\)</span> is equivalent to (<span class="math">\(\lambda\)</span><code>x.</code><span class="math">\(b\)</span>)<span class="math">\(e\)</span> <a href='' id='Comment:Rela2' ></a></p><p>The <code>let</code> expression in our language is not necessary, because a <code>let</code> can be simulated using a function. In particular, any expression <code>let x =</code> <span class="math">\(e\)</span> <code>in</code> <span class="math">\(b\)</span> is equivalent to (<span class="math">\(\lambda\)</span><code>x.</code><span class="math">\(b\)</span>)<span class="math">\(e\)</span>. <a href='' id='Comment:Rela1' ></a></p><p>The expression <code>let x =</code> <span class="math">\(e\)</span> <code>in</code> <span class="math">\(b\)</span> binds value of <span class="math">\(e\)</span> to the variable <code>x</code> for use in the body, <span class="math">\(b\)</span>. The creation of bindings in a <code>let</code> statement is equivalent to the bindings created from arguments provided to a lambda function. So, if a function was defined as: <code>foo = \x -&gt;</code> <span class="math">\(b\)</span> Calling <code>foo</code> <span class="math">\(e\)</span> is equivalent to <code>let x =</code> <span class="math">\(e\)</span> <code>in</code> <span class="math">\(b\)</span> So, a <code>let</code> statement is another rewording of a lambda function that takes a certain argument binding before interpretting the body. <a href='' id='Comment:Rela3' ></a></p><h4 id="others"><a href="#others"><span class="header-section-number">4.4.6.1</span> Others</a></h4><p>There are many other uses of first-class functions, including callbacks, event handlers, thunks, continuations, etc. <a href='' id='Comment:Othe2' ></a></p><h2 id="evaluating-first-class-functions-using-environments"><a href="#evaluating-first-class-functions-using-environments"><span class="header-section-number">4.5</span> Evaluating First-Class Functions using Environments</a></h2><p>Its now time to define the syntax and semantics of a language with first-class functions. Based on the examples in the <a href="#FirstClassExamples">previous section</a>, some features are no longer needed. For example, <code>let</code> expressions are not needed because they can be expressed using functions. Functions only need one argument, because multi-argument functions can be expressed by returning functions from functions. <a href='' id='Comment:Eval58' ></a></p><p>Evaluation of first-class functions (lambdas) is complicated by the need to properly enforce <em>lexical scoping</em> rules. Lexical scope means that a variable refers to the closest enclosing definition of that variable. TODO: move this discussion earlier! <a href='' id='Comment:Eval9' ></a></p><p></p><h3 id="a-non-solution-function-expressions-as-values"><a href="#a-non-solution-function-expressions-as-values"><span class="header-section-number">4.5.1</span> A Non-Solution: Function Expressions as Values</a></h3><p>The first idea for achieving “functions are values” is to make function expressions be values. It turns out that this “solution” does not really work. The reason I spend so much time discussing an incorrect solution is that understanding why the obvious and simple solution is wrong helps to motivate and explain the correct solution. This section is colored red to remind you that the solution it presents is <em>incorrect</em>. The correct solution is given in the <a href="#Closures">next section, on closures</a>. The code for the incorrect soluiton mentioned here is in the <a href="./code/IncorrectFunctions.hs.htm">Incorrect Functions</a> file. <a href='' id='Comment:A2' ></a></p><p>To try this approach, function expressions are included in the <code>Value</code> data type, which allows functions appears a literal values in a program: <a href='' id='Comment:A3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="fu">...</span>
           <span class="fu">|</span> <span class="dt">Function</span> <span class="dt">String</span> <span class="dt">Exp</span>  <span class="co">-- new</span>
  <span class="kw">deriving</span> <span class="dt">Eq</span>
<span class="co">-- <a href='' id='Comment:A31' ></a></span></code></pre><p>The two components of a function expression <code>Function</code> are the <em>bound variable</em> <code>String</code> and the <em>body expression</em> <code>Exp</code>. This new kind of value for functions looks a little strange. Its not like the others. <a href='' id='Comment:A5' ></a></p><p>We normally think of values as things that a simple data, like integers, strings, booleans, and dates. Up until now, this is what values have been. Up until now, values have not contained <em>expressions</em> in them. On the other hand, we are committed to making functions be values, and the body of a function is necessarily an expression, so one way or the other values are going to contain expressions. <a href='' id='Comment:A6' ></a></p><p>TODO: the call expression discussion is really not part of this <em>incorrect</em> solution, so it could be moved out? The only problem is that the code assumes that functions are literals, which is not the code in the correct version. Sigh. <a href='' id='Comment:A7' ></a></p><p>The call expression changes slightly from the version with top-level functions. Instead of the <em>name</em> of the function to be called, the <code>Call</code> expression now contains an expression <code>Exp</code> for both the function and the argument: <a href='' id='Comment:A8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">IntV</span>  <span class="dt">Int</span>
           <span class="fu">|</span> <span class="dt">BoolV</span> <span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">Function</span> <span class="dt">String</span> <span class="dt">Exp</span>  <span class="co">-- new</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="co">-- <a href='' id='Comment:A32' ></a></span></code></pre><p>To clarify the effect of this change, consider these two versions of a simple program, written using top-level functions or first-class functions: <a href='' id='Comment:A10' ></a></p><table><thead><tr class="header"><th align="left">Top-Level Functions (A)</th><th align="left">First-Class Functions (B)</th></tr></thead><tbody><tr class="odd"><td align="left"><code>function f(x) OPENB x * x CLOSEB</code></td><td align="left"><code>let f = function(x) OPENB x * x CLOSEB in</code></td></tr><tr class="even"><td align="left"><code>f(10)</code></td><td align="left">    <code>f(10)</code> <a href='' id='Comment:A11' ></a></td></tr></tbody></table><p>The explicit abstract syntax for example (A) is: <a href='' id='Comment:A12' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Program</span>
  [(<span class="st">&quot;f&quot;</span>, <span class="dt">Function</span> [<span class="st">&quot;x&quot;</span>]
           (<span class="dt">Binary</span> <span class="dt">Mul</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)
                       (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)))]
  (<span class="dt">Call</span> <span class="st">&quot;f&quot;</span> [<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">10</span>)])
<span class="co">-- <a href='' id='Comment:A13' ></a></span></code></pre><p>The explicit abstract syntax for example (B) is: <a href='' id='Comment:A14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
 <span class="dt">Let</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Literal</span> (<span class="dt">Function</span> <span class="st">&quot;x&quot;</span>
                      (<span class="dt">Binary</span> <span class="dt">Mul</span> (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>)
                                  (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>))))
   (<span class="dt">Call</span> (<span class="dt">Variable</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">10</span>)))
<span class="co">-- <a href='' id='Comment:A15' ></a></span></code></pre><p>Note that the function in the <code>Call</code> is string <code>&quot;f&quot;</code> in the first version, but is an expression <code>Variable &quot;f&quot;</code> in the second version. <a href='' id='Comment:A16' ></a></p><p>In many cases the first expression (the function) will be <em>variable</em> that names the function to be called. Since there is no longer any special function environment, the names of functions are looked up in the normal variable environment. (TODO: should this come earlier?) TODO: example where function to be called is not a variable. <a href='' id='Comment:A17' ></a></p><p>The first few cases for evaluation are exactly the same as before. In particular, evaluating a literal value is the same, although now the literal value might be a function. <a href='' id='Comment:A18' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env      <span class="fu">=</span> v
<span class="co">-- <a href='' id='Comment:A34' ></a></span></code></pre><p>Calling a function works almost the same as the case for function calls in the <a href="#TopLevel">language with top-level functions</a>. Here is the code: <a href='' id='Comment:A20' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Call</span> fun arg) env <span class="fu">=</span> evaluate body newEnv
  <span class="kw">where</span> <span class="dt">Function</span> x body <span class="fu">=</span> evaluate fun env
        newEnv <span class="fu">=</span> bindF x (evaluate arg env) env
<span class="co">-- <a href='' id='Comment:A35' ></a></span></code></pre><p>To evaluate a function call <code>Call fun arg</code>, <a href='' id='Comment:A22' ></a></p><ol style="list-style-type: decimal"><li>First evaluate the function <code>fun</code> of the call: <code>evaluate fun env</code> <a href='' id='Comment:A1' ></a></li><li>Use pattern matching to ensure that the result of step 1 is a <code>Function</code> value, binding <code>x</code> and <code>body</code> to the argument name and body of the function. <a href='' id='Comment:A37' ></a></li><li><p>Evaluate the actual argument (<code>evaluate arg env</code>) and then extend the environment <code>env</code> with a binding between the function parameter <code>x</code> and the argument value: <a href='' id='Comment:A23' ></a></p><code>bindF x (evaluate arg env) env</code> <a href='' id='Comment:A38' ></a></li><li><p>Evaluate the <code>body</code> of the function in the extended environment <code>newEnv</code>: <a href='' id='Comment:A24' ></a></p><p><code>evaluate newEnv body</code> <a href='' id='Comment:A25' ></a></p></li></ol><p>Note that this explanation jumps around in the source code. The explanation follows the sequence of data dependencies in the code: what logically needs to be evaluated first, rather than the order in which expressions are written. Since Haskell is a lazy language, it will actually evaluate the expressions in a completely different order! <a href='' id='Comment:A26' ></a></p><p>The main difference from the case of <a href="#TopLevel">top-level functions</a> is that the function is computed by calling <code>evaluate fun env</code> rather than <code>lookup fun funEnv</code>. The other difference is that functions now only have one argument, while we allowed multiple arguments in the previous case. <a href='' id='Comment:A27' ></a></p><p>The key question is: <strong>why doesn’t the code given above work?</strong> There are two problems. One has to do with returning functions as values, and the other with passing functions as arguments. They both involve the handling of free variables in the function expression. <a href='' id='Comment:A30' ></a></p><h4 id="problems-with-returning-functions-as-values"><a href="#problems-with-returning-functions-as-values"><span class="header-section-number">4.5.1.1</span> Problems with Returning Functions as Values</a></h4><p>Let’s look at the problem of returning functions as values first. The section on <a href="#Curry">Multiple Arguments</a> showed how a two-argument function could be implemented by writing a function that takes one argument, but then returns a function that takes the second argument. Here is a small program that illustrates this technique: <a href='' id='Comment:Prob2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> add <span class="fu">=</span> \a <span class="ot">-&gt;</span> (\b <span class="ot">-&gt;</span> b <span class="fu">+</span> a) <span class="kw">in</span> add <span class="dv">3</span> <span class="dv">2</span>
<span class="co">-- <a href='' id='Comment:Prob3' ></a></span></code></pre><p>This program is encoded in our language as follows: <a href='' id='Comment:Prob4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
 <span class="dt">Let</span> <span class="st">&quot;add&quot;</span> (<span class="dt">Literal</span> (<span class="dt">Function</span> <span class="st">&quot;a&quot;</span>
             (<span class="dt">Literal</span> (<span class="dt">Function</span> <span class="st">&quot;b&quot;</span>
                (<span class="dt">Binary</span> <span class="dt">Add</span> (<span class="dt">Variable</span> <span class="st">&quot;b&quot;</span>)
                            (<span class="dt">Variable</span> <span class="st">&quot;a&quot;</span>))))))
             (<span class="dt">Call</span> (<span class="dt">Call</span> (<span class="dt">Variable</span> <span class="st">&quot;add&quot;</span>)
                             (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)))
                   (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">2</span>)))
<span class="co">-- <a href='' id='Comment:Prob5' ></a></span></code></pre><p>Rather than work with the ugly constructor syntax in Haskell, we will continue to use the convention of writing <code>b + a</code> to mean <code>(Binary Add (Variable &quot;b&quot;) (Variable &quot;a&quot;))</code>. <a href='' id='Comment:Prob6' ></a></p><p>Here is how evaluation of this sample program proceeds: <a href='' id='Comment:Prob7' ></a></p><ol style="list-style-type: decimal"><li>Evaluate <code>let add = \a -&gt; (\b -&gt; b + a) in add 3 2</code> <a href='' id='Comment:Prob1' ></a></li><li>Bind <code>add</code> <span class="math">\(\mapsto\)</span> <code>\a -&gt; (\b -&gt; b + a)</code> <a href='' id='Comment:Prob11' ></a></li><li>Call <code>(add 3) 2</code> <a href='' id='Comment:Prob12' ></a><ol style="list-style-type: lower-alpha"><li>Call <code>add 3</code> <a href='' id='Comment:Prob13' ></a></li><li>Evaluate the variable <code>add</code>, which looks it up in the environment to get <code>\a -&gt; (\b -&gt; b + a)</code> <a href='' id='Comment:Prob14' ></a></li><li>Bind <code>a</code> <span class="math">\(\mapsto\)</span> <code>3</code> <a href='' id='Comment:Prob15' ></a></li><li>Return <code>\b -&gt; b + a</code> as result of <code>add 3</code> <a href='' id='Comment:Prob16' ></a></li></ol></li><li>Call <code>\b -&gt; b + a</code> on argument <code>2</code> <a href='' id='Comment:Prob17' ></a><ol style="list-style-type: lower-alpha"><li>Bind <code>b</code> <span class="math">\(\mapsto\)</span> <code>2</code> <a href='' id='Comment:Prob18' ></a></li><li>Evaluate <code>b + a</code> <a href='' id='Comment:Prob19' ></a></li><li>Look up <code>b</code> to get <code>2</code> <a href='' id='Comment:Prob20' ></a></li><li>Look up <code>a</code> to get… <strong>unbound variable!</strong> <a href='' id='Comment:Prob8' ></a></li></ol></li></ol><p>To put this more concisely, the problem arises because the call to <code>add 3</code> returns <code>\b -&gt; b + a</code>. But this function expression is not well defined because it has a free variable <code>a</code>. What happened to the binding for <code>a</code>? It had a value in Steps 12 through 14 of the explanation above. But this binding is lost when returning the literal <code>\b -&gt; b + a</code>. The problem doesn’t exhibit itself until the function is called. <a href='' id='Comment:Prob9' ></a></p><p>The problems with returning literal function expressions as values is that bindings for free variables that occur in the function are lost, leading to later unbound variable errors. Again, this problem arises because we are trying to treat function expressions as <em>literals</em>, as if they were number or booleans. But function expressions are different because they contain variables, so care must be taken to avoid losing the bindings for the variables. <a href='' id='Comment:Prob10' ></a></p><h4 id="problems-with-rebinding-variables"><a href="#problems-with-rebinding-variables"><span class="header-section-number">4.5.1.2</span> Problems with Rebinding Variables</a></h4><p>A second problem can arise when passing functions as values. This problem can occur, for example, when <a href="#Compose">composing two functions</a>, <a href="#Map">mapping a function over a list</a>, or many other situations. Here is a program that illustrates the problem. <a href='' id='Comment:Prob21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> k <span class="fu">=</span> <span class="dv">2</span> <span class="kw">in</span>
  <span class="kw">let</span> double <span class="fu">=</span> \n <span class="ot">-&gt;</span> k <span class="fu">*</span> n <span class="kw">in</span>
    <span class="kw">let</span> k <span class="fu">=</span> <span class="dv">9</span> <span class="kw">in</span>
      double k
<span class="co">-- <a href='' id='Comment:Prob22' ></a></span></code></pre><p>The correct answer, which is produced if you run this program in Haskell, is 18. The key point is that <code>k</code> is equal to <code>2</code> in the body of <code>double</code>, because that occurrence of <code>k</code> is within the scope of the first <code>let</code>. Evaluating this function with the evaluator given above produces <code>81</code>, which is not correct. In summary, the evaluation of this expression proceeds as follows: <a href='' id='Comment:Prob23' ></a></p><ol style="list-style-type: decimal"><li>Bind <code>k</code> <span class="math">\(\mapsto\)</span> <code>2</code> <a href='' id='Comment:Prob24' ></a></li><li>Bind <code>double</code> <span class="math">\(\mapsto\)</span> <code>\n -&gt; k * n</code> <a href='' id='Comment:Prob25' ></a></li><li>Bind <code>k</code> <span class="math">\(\mapsto\)</span> <code>9</code> <a href='' id='Comment:Prob26' ></a></li><li>Call <code>double k</code> <a href='' id='Comment:Prob27' ></a><ol style="list-style-type: lower-alpha"><li>Bind <code>n</code> <span class="math">\(\mapsto\)</span> <code>9</code> <a href='' id='Comment:Prob28' ></a></li><li>Evaluate body <code>k * n</code> <a href='' id='Comment:Prob29' ></a></li><li>Result is <code>81</code> given <code>k=9</code> and <code>n=9</code> <a href='' id='Comment:Prob31' ></a></li></ol></li></ol><p>The problem is that when <code>k</code> is looked up in step 4b, the most recent binding for <code>k</code> is <code>9</code>. This binding is based on the <em>control flow</em> of the program, not on the <em>lexical</em> structure. Looking up variables based on control flow is called <em>dynamic binding</em>. <a href='' id='Comment:Prob30' ></a></p><p></p><h3 id="Closures"><a href="#Closures"><span class="header-section-number">4.5.2</span> A Correct Solution: Closures</a></h3><p>As we saw in the previous section, the problem with using a function expression as a value is that the bindings of the free variables in the function expression are either lost or may be overwritten. The solution is to <em>preserve the bindings that existed at the point when the function was defined</em>. The mechanism for doing this is called a <em>closure</em>. A closure is a combination of a function expression and an environment. Rather than think of a function expression as a function value, instead think of it as a part of the program that <em>creates</em> a function. The actual function value is represented by a closure, which captures the current environment at the point when the function expression is executed. The code for this section is given in the <a href="./code/FirstClassFunctions.hs.htm">First-Class Functions</a> file. <a href='' id='Comment:A40' ></a></p><p>To implement this idea, we revise the definition of <code>Exp</code> and <code>Value</code>. First we add function expressions as a new kind of expression: <a href='' id='Comment:A41' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">....</span>
         <span class="fu">|</span> <span class="dt">Function</span> <span class="dt">String</span> <span class="dt">Exp</span>      <span class="co">-- new</span>
<span class="co">-- <a href='' id='Comment:A39' ></a></span></code></pre><p>As before, the two components of a function expression are the <em>bound variable</em> <code>String</code> and the <em>body expression</em> <code>Exp</code>. Function expressions resemble <code>let</code> expressions, so they fit in well with the other kinds of expressions. <a href='' id='Comment:A43' ></a></p><p>The next step is to introduce <em>closures</em> as a new kind of value. Closures have all the same information as a function expressions (which we previously tried to add as values), but they have one important difference: closures also contain an environment. <a href='' id='Comment:A46' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">IntV</span>  <span class="dt">Int</span>
           <span class="fu">|</span> <span class="dt">BoolV</span> <span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">ClosureV</span> <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Env</span>  <span class="co">-- new</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="co">-- <a href='' id='Comment:A42' ></a></span></code></pre><p>The three parts of a closure are the <em>bound variable</em> <code>String</code>, the <em>function body</em> <code>Exp</code>, and <em>the closure environment</em> <code>Env</code>. The bound variable and function body are the same as the components of a function expression. <a href='' id='Comment:A48' ></a></p><p>With these data types, we can now define a correct evaluator for first-class functions using environments. The first step is to <em>create a closure</em> when evaluating a function expression. <a href='' id='Comment:A9' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Function</span> x body) env <span class="fu">=</span> <span class="dt">ClosureV</span> x body env     <span class="co">-- new</span>
<span class="co">-- <a href='' id='Comment:A44' ></a></span></code></pre><p>The resulting closure is the value that represents a function. The function expression <code>Function x body</code> is not actually a function itself, it is an expression that <em>creates</em> a function when executed. Once a closure value has been created, it can be bound to a variable just like any other value, or passed to a function or returned as the result of a function. Closures are values. <a href='' id='Comment:A49' ></a></p><p>Since closures represent functions, the only thing you can <em>do</em> with a closure is <em>call</em> it. The case for evaluating a function call starts by analyzing the function call expression, <code>evaluate (Call fun arg) env</code>. This pattern says that a call expression has two components: a function <code>fun</code> and an argument <code>arg</code>. Here is the code for this case: <a href='' id='Comment:A51' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Call</span> fun arg) env <span class="fu">=</span> evaluate body newEnv    <span class="co">-- changed</span>
  <span class="kw">where</span> <span class="dt">ClosureV</span> x body closeEnv <span class="fu">=</span> evaluate fun env
        newEnv <span class="fu">=</span> (x, evaluate arg env) <span class="fu">:</span> closeEnv
<span class="co">-- <a href='' id='Comment:A47' ></a></span></code></pre><p>The code starts by evaluating both the function part <code>fun</code> to produce a value. The <code>where</code> clause <code>Closure x body newEnv = evaluate fun env</code> says that the result of evaluating <code>fun</code> must be a closure, and the variables <code>x</code>, <code>body</code>, and <code>newEnv</code> are bound to the parts of the closure. If the result is not a closure, Haskell throws a runtime error. <a href='' id='Comment:A52' ></a></p><p>Next the environment from the closure <code>newEnv</code> is extended to include a new binding <code>(x, evaluate arg env)</code> of the function parameter to the value of the argument expression. The new environment is called <code>newEnv</code>. At a high level, the environment is the same environment that existed when the function was created, together with a binding for the function parameter. <a href='' id='Comment:A54' ></a></p><p>Finally, the <code>body</code> of the function is evaluated in this new environment, <code>evaluate body newEnv</code>. <a href='' id='Comment:A55' ></a></p><p>TODO: give an example of how this runs? <a href='' id='Comment:A56' ></a></p><h4 id="exercise-3.2-multiple-arguments"><a href="#exercise-3.2-multiple-arguments"><span class="header-section-number">4.5.2.1</span> Exercise 3.2: Multiple Arguments</a></h4><p>Modify the definition of <code>Function</code> and <code>Call</code> to allow multiple arguments. Modify the <code>evaluate</code> function to correctly handle the extra arguments. <a href='' id='Comment:Exer4' ></a></p><h2 id="environmentclosure-diagrams"><a href="#environmentclosure-diagrams"><span class="header-section-number">4.6</span> Environment/Closure Diagrams</a></h2><p>The behavior of this evaluator is quite complex, but its operation on specific programs can be illustrated by showing all the environments and closures created during its execution, together with the relationships between these structures. <a href='' id='Comment:Envi2' ></a></p><p>An Environment/Closure Diagram is a picture that shows the closures and environments created during execution of an expression. <a href='' id='Comment:Envi3' ></a></p><ul><li><p>Start State <a href='' id='Comment:Envi4' ></a></p><p>Set current environment to empty environment <span class="math">\(\emptyset\)</span> <a href='' id='Comment:Envi5' ></a></p></li><li>Case <code>Let x e body</code> <a href='' id='Comment:Envi1' ></a><ol style="list-style-type: decimal"><li><p>Draw binding box for <code>x</code> with unknown value <a href='' id='Comment:Envi6' ></a></p>Set parent of new binding to be the current environment <a href='' id='Comment:Envi16' ></a></li><li><p>Create the diagram for bound expression <code>e</code> <a href='' id='Comment:Envi7' ></a></p>Put the value of <code>e</code> into the binding as the value of <code>x</code> <a href='' id='Comment:Envi17' ></a></li><li>Set current environment to be the new binding <a href='' id='Comment:Envi18' ></a></li><li>Draw diagram for <code>body</code> and remember value <a href='' id='Comment:Envi19' ></a></li><li><p>Set current environment back to what it was before <a href='' id='Comment:Envi8' ></a></p></li></ol></li><li>Case <code>Call fun arg</code> <a href='' id='Comment:Envi20' ></a><ol style="list-style-type: decimal"><li><p>Draw diagram for <code>fun</code> <a href='' id='Comment:Envi9' ></a></p>Result must be a closure with variable <code>x</code>, <code>body</code> and <code>env</code> <a href='' id='Comment:Envi21' ></a></li><li><p>Make binding for argument using name <code>x</code> from closure <a href='' id='Comment:Envi10' ></a></p>Set parent of new binding to be the environment of the closure <code>env</code> <a href='' id='Comment:Envi22' ></a></li><li><p>Draw diagram for <code>arg</code> <a href='' id='Comment:Envi11' ></a></p>Put the value into the new binding as the value of <code>x</code> <a href='' id='Comment:Envi23' ></a></li><li>Set current environment to be the new binding <a href='' id='Comment:Envi24' ></a></li><li>Draw diagram for <code>body</code> and remember value <a href='' id='Comment:Envi25' ></a></li><li><p>Set current environment back to what it was before <a href='' id='Comment:Envi12' ></a></p></li></ol></li><li>Case <code>Var x</code> <a href='' id='Comment:Envi26' ></a><ol style="list-style-type: decimal"><li>Look up the variable in the current environment <a href='' id='Comment:Envi13' ></a></li></ol></li><li>Case <code>Function x e</code> <a href='' id='Comment:Envi27' ></a><ol style="list-style-type: decimal"><li><p>Make a closure with variable <code>x</code>, body <code>e</code> <a href='' id='Comment:Envi14' ></a></p><p>Set the environment of the closure to be the current environment <a href='' id='Comment:Envi15' ></a></p></li></ol></li></ul><h3 id="example-1"><a href="#example-1"><span class="header-section-number">4.6.1</span> Example 1</a></h3><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> k <span class="fu">=</span> <span class="dv">2</span> <span class="kw">in</span>
  <span class="kw">let</span> double <span class="fu">=</span> \n <span class="ot">-&gt;</span> k <span class="fu">*</span> n <span class="kw">in</span>
    <span class="kw">let</span> k <span class="fu">=</span> <span class="dv">9</span> <span class="kw">in</span>
      double k
<span class="co">-- <a href='' id='Comment:Exam5' ></a></span></code></pre><p><embed src="figures/env1.png" /> <a href='' id='Comment:Exam3' ></a></p><h3 id="example-2"><a href="#example-2"><span class="header-section-number">4.6.2</span> Example 2</a></h3><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> add <span class="fu">=</span> \a <span class="ot">-&gt;</span> (\b <span class="ot">-&gt;</span> b <span class="fu">+</span> a) <span class="kw">in</span> (add <span class="dv">3</span>) <span class="dv">2</span>
<span class="co">-- <a href='' id='Comment:Exam6' ></a></span></code></pre><p><embed src="figures/env2.png" /> <a href='' id='Comment:Exam1' ></a></p><h3 id="example-3"><a href="#example-3"><span class="header-section-number">4.6.3</span> Example 3</a></h3><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> m <span class="fu">=</span> <span class="dv">2</span> <span class="kw">in</span>
  <span class="kw">let</span> proc <span class="fu">=</span> \n <span class="ot">-&gt;</span> m <span class="fu">+</span> n
      part <span class="fu">=</span> \(g,n) <span class="ot">-&gt;</span> \m <span class="ot">-&gt;</span> n <span class="fu">*</span> g(m)
  <span class="kw">in</span> <span class="kw">let</span> inc <span class="fu">=</span> part(proc, <span class="dv">3</span>) <span class="kw">in</span>
      inc <span class="dv">7</span>
<span class="co">-- <a href='' id='Comment:Exam7' ></a></span></code></pre><p><img src="figures/env3.png" alt="Environment Diagram 3" /> <a href='' id='Comment:Exam4' ></a></p><h2 id="summary-of-first-class-functions"><a href="#summary-of-first-class-functions"><span class="header-section-number">4.7</span> Summary of First-Class Functions</a></h2><p>Here is the full code for first-class functions with non-recursive definitions: <a href='' id='Comment:Summ13' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Literal</span>   <span class="dt">Value</span>
         <span class="fu">|</span> <span class="dt">Unary</span>     <span class="dt">UnaryOp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Binary</span>    <span class="dt">BinaryOp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">If</span>        <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Variable</span>  <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">Let</span>       <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Function</span>  <span class="dt">String</span> <span class="dt">Exp</span>      <span class="co">-- new</span>
         <span class="fu">|</span> <span class="dt">Call</span>      <span class="dt">Exp</span> <span class="dt">Exp</span>         <span class="co">-- changed</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
  
<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Value</span>)]

<span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env <span class="fu">=</span> v

evaluate (<span class="dt">Unary</span> op a) env <span class="fu">=</span> 
  unary op (evaluate a env)

evaluate (<span class="dt">Binary</span> op a b) env <span class="fu">=</span> 
  binary op (evaluate a env) (evaluate b env)

evaluate (<span class="dt">If</span> a b c) env <span class="fu">=</span> 
  <span class="kw">let</span> <span class="dt">BoolV</span> test <span class="fu">=</span> evaluate a env <span class="kw">in</span>
    <span class="kw">if</span> test <span class="kw">then</span> evaluate b env
            <span class="kw">else</span> evaluate c env

evaluate (<span class="dt">Variable</span> x) env <span class="fu">=</span> fromJust (lookup x env)

evaluate (<span class="dt">Let</span> x exp body) env <span class="fu">=</span> evaluate body newEnv
  <span class="kw">where</span> newEnv <span class="fu">=</span> (x, evaluate exp env) <span class="fu">:</span> env

evaluate (<span class="dt">Function</span> x body) env <span class="fu">=</span> <span class="dt">ClosureV</span> x body env     <span class="co">-- new</span>

evaluate (<span class="dt">Call</span> fun arg) env <span class="fu">=</span> evaluate body newEnv    <span class="co">-- changed</span>
  <span class="kw">where</span> <span class="dt">ClosureV</span> x body closeEnv <span class="fu">=</span> evaluate fun env
        newEnv <span class="fu">=</span> (x, evaluate arg env) <span class="fu">:</span> closeEnv
<span class="co">-- <a href='' id='Comment:Summ14' ></a></span></code></pre><h1 id="recursive-definitions"><a href="#recursive-definitions"><span class="header-section-number">5</span> Recursive Definitions</a></h1><p>One consequence of using a simple <code>let</code> expression to define functions is that it is no longer possible to define <em>recursive functions</em>, which were supported in the <a href="#TopLevel">Section on Top-Level Functions</a>. A recursive function is a function that calls itself within its own definition. For example, consider this definition of the factorial function: <a href='' id='Comment:Recu2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
  <span class="kw">let</span> fact <span class="fu">=</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="fu">*</span> fact(n<span class="fu">-</span><span class="dv">1</span>)
  <span class="kw">in</span> fact(<span class="dv">10</span>)
<span class="co">-- <a href='' id='Comment:Recu3' ></a></span></code></pre><p>The <code>fact</code> function is recursive because it calls <code>fact</code> within its definition. <a href='' id='Comment:Recu4' ></a></p><p>The problem with our existing language implementation is that the scope of the variable <code>fact</code> is the body of the <code>let</code> expression, which is <code>fact(10)</code>, so while the use of <code>fact</code> in <code>fact(10)</code> is in scope, the other use in <code>fact(n-1)</code> is <em>not</em> in scope. (TODO: wordy) <a href='' id='Comment:Recu5' ></a></p><p>To solve this problem, we need to change how we understand the <code>let</code> expression: the scope of the bound variable must be both the body of the let, and the bound expression that provides a definition for the variable. This means that the variable can be defined in terms of itself. This is exactly what we want for recursive functions, but it can cause problems. For example, <a href='' id='Comment:Recu6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span> <span class="kw">in</span> x
<span class="co">-- <a href='' id='Comment:Recu7' ></a></span></code></pre><p>This is now syntactically correct, as the bound variable <code>x</code> is in scope for the expression <code>x + 1</code>. However, such a program is either meaningless, or it can be understood to mean “infinite loop”. There are similar cases that are meaningful. For example, this program is meaningful: <a href='' id='Comment:Recu8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
  <span class="kw">let</span> x <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>
      y <span class="fu">=</span> <span class="dv">99</span>
  <span class="kw">in</span> x <span class="fu">*</span> y
<span class="co">-- <a href='' id='Comment:Recu9' ></a></span></code></pre><p>This example includes two bindings at the same time (which we do not currently support. TODO: see homework?). In this case the result is <code>9900</code> because <code>x = 100</code> and <code>y = 99</code>. It works because the binding expression for <code>x</code>, namely <code>y + 1</code>, is in the scope of <code>y</code>. <a href='' id='Comment:Recu10' ></a></p><h2 id="semantics-of-recursion"><a href="#semantics-of-recursion"><span class="header-section-number">5.1</span> Semantics of Recursion</a></h2><p>A more fundamental question is <em>what does a recursive definition</em> <strong>mean</strong>? In grade school we get used to dealing with equations that have the same variable on both sides of an equal sign. For example, consider this simple equation: <a href='' id='Comment:Sema2' ></a></p><p><span class="math">\(a = 1 + 3a\)</span> <a href='' id='Comment:Sema3' ></a></p><p>Our instinct, honed over many years of practice, is to “solve for <em>a</em>”. <a href='' id='Comment:Sema4' ></a></p><ul><li><span class="math">\(a = 1 + 3a\)</span> <a href='' id='Comment:Sema5' ></a></li><li><em>{ subtract <span class="math">\(3a\)</span> from both sides }</em> <a href='' id='Comment:Sema6' ></a></li><li><span class="math">\(-2a = 1\)</span> <a href='' id='Comment:Sema7' ></a></li><li><em>{ divide both sides by <span class="math">\(-2\)</span> }</em> <a href='' id='Comment:Sema8' ></a></li><li><span class="math">\(a = -1/2\)</span> <a href='' id='Comment:Sema9' ></a></li></ul><p>I feel a little silly going through this in detail (although I have spent a lot of time recently practicing algebra with my son, so I know how hard it is to master). The point is that the definition of <code>fact</code> has exactly the same form: <a href='' id='Comment:Sema10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">fact <span class="fu">=</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="fu">*</span> fact(n<span class="fu">-</span><span class="dv">1</span>)
<span class="co">-- <a href='' id='Comment:Sema11' ></a></span></code></pre><p>This is an equation where <code>fact</code> appears on both sides, just as <span class="math">\(a\)</span> appears on both sides in <span class="math">\(a = 1 + 3a\)</span>. The question is: <em>how do we solve for <code>fact</code></em>? It’s not so easy, because we don’t have algebraic rules to divide by lambda and subtract conditionals, to get both occurrences of <code>fact</code> onto the same side of the equation. We are going to have to take another approach. <a href='' id='Comment:Sema12' ></a></p><p>The first thing to notice is that <code>fact</code> is a function, and like most functions it is an <em>infinite</em> structure. This makes sense in several ways. It is infinite in the sense that it defines the factorial for every natural number, and there is an infinity of natural numbers. If you consider the grade-school definition of a function as a set of pairs, then the set of pairs in the factorial function is infinite. <a href='' id='Comment:Sema13' ></a></p><p>Finally, and most importantly for us, if you consider <code>fact</code> as a computational method or rule, then the computational rule has an unbounded number of steps that it can perform. We can count the steps: first it performs an equality comparison <code>n == 0</code>, then it either stops or it performs a subtraction <code>n-1</code> and then <em>performs the steps recursively</em>, then when it is done with that it performs a multiplication <code>n * ...</code>. In other words, given a natural number <span class="math">\(n\)</span> the computation will perform <span class="math">\(3n + 1\)</span> steps. Since it will handle any natural number, there is no bound on the number of steps it performs. If you tried to write out the steps that might be performed, then the list of steps would be infinite. <a href='' id='Comment:Sema14' ></a></p><h3 id="three-analyses-of-recursion"><a href="#three-analyses-of-recursion"><span class="header-section-number">5.1.1</span> Three Analyses of Recursion</a></h3><p>In what follows we will explore three ways to understand recursion. The first explanation just allows us to define recursive <code>let</code> expression by using the capabilities for recursion that are built into Haskell. This explanation is elegant and concise, but not very satisfying (like pure sugar!). The problem is that we have just relied on recursion in Haskell, so we don’t really have an explanation of recursion. The second explanation is a practical introduction to the concept of fixed points. This solution can also be implemented elegantly in Haskell, and has the benefit of providing a mathematically sound explanation of recursive definitions. While fixed points can be implemented directly, they are not the most efficient approach, especially in conventional languages. As a result, we will consider a third implementation, based on self application. This explanation is messy but practical. In fact, it is the basis for real-world implementations of C++ and Java. A forth explanation A fourth explanation, languages in traditional imperative languages. <a href='' id='Comment:Thre2' ></a></p><h2 id="Cyclic"><a href="#Cyclic"><span class="header-section-number">5.2</span> Understanding Recursion using Haskell Recursion</a></h2><p>Haskell makes it easy to create infinite structures and functions. Understanding how this works can help us in implementing our language. We’ve already seen many examples of recursive functions in Haskell: for example, every version of <code>evaluate</code> has been recursive. However, Haskell also allows creation of recursive data structures. For example, this line creates an infinite list of 2’s: <a href='' id='Comment:Unde1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">twos <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> twos
<span class="co">-- <a href='' id='Comment:Unde3' ></a></span></code></pre><p>Remember that the <code>:</code> operator adds an item to the front of a list. This means that <code>twos</code> is a list with <code>2</code> concatenated onto the front of the list <code>twos</code>. In other words, <code>twos</code> is an infinite list of 2’s: <a href='' id='Comment:Unde20' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">twos  <span class="fu">==&gt;</span>  [<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="fu">...</span> ]
<span class="co">-- <a href='' id='Comment:Unde22' ></a></span></code></pre><p>It’s also possible to make infinite lists that change: <a href='' id='Comment:Unde23' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">numbers <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> [ n <span class="fu">+</span> <span class="dv">1</span> <span class="fu">|</span> n <span class="ot">&lt;-</span> numbers ]
<span class="co">-- <a href='' id='Comment:Unde7' ></a></span></code></pre><p>This creates an infinite list of the natural numbers: <a href='' id='Comment:Unde8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>, <span class="dv">18</span>, <span class="fu">...</span>]
<span class="co">-- <a href='' id='Comment:Unde24' ></a></span></code></pre><p>All these definitions work in Haskell because of <em>laziness</em>. Haskell creates an internal representation of a potentially infinite value, but it only creates as much of the value as the program actually needs. If you try to use all of <code>two</code> or <code>numbers</code> then the result will be an infinite loop that never stops. However, if the program only needs the first 10 items of <code>twos</code> or <code>numbers</code> then only the first 10 elements of the infinite value will be created. <a href='' id='Comment:Unde10' ></a></p><p>Interestingly, Haskell also accepts the algebraic expression discussed earlier: <a href='' id='Comment:Unde11' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">a <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">*</span> a
<span class="co">-- <a href='' id='Comment:Unde12' ></a></span></code></pre><p>Haskell considers this a valid program, but it does <em>not</em> solve for <code>a</code>. Instead it treats the definition as a computational rule: to evaluate <code>a</code>, add one to three times the value of <code>a</code>, which requires evaluating <code>a</code>, and so on, again, and again, and again. The result is an infinite loop. The quickest way to write an infinite loop is: <a href='' id='Comment:Unde13' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">inf <span class="fu">=</span> inf
<span class="co">-- <a href='' id='Comment:Unde14' ></a></span></code></pre><p>TODO: make pictures to illustrate the cyclic values in this section. <a href='' id='Comment:Unde15' ></a></p><p>Attempting to use this value leads to an immediate infinite loop<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup>. If the value is not used, then it has no effect on the program results. <a href='' id='Comment:Unde16' ></a></p><p>It is not always easy to determine if a value will loop infinitely or not. One rule of thumb is that if the recursive variable is used <em>within</em> a data constructor (e.g. <code>:</code>) or inside a function (in the body of a lambda), then it will probably not loop infinitely. This is because both data constructors and functions are lazy in Haskell. <a href='' id='Comment:Unde18' ></a></p><h3 id="using-results-of-functions-as-arguments"><a href="#using-results-of-functions-as-arguments"><span class="header-section-number">5.2.1</span> Using Results of Functions as Arguments</a></h3><p>Another interesting use of recursion and laziness is the ability to use the result of a calling a function as one of the arguments to the function call itself. <a href='' id='Comment:Usin1' ></a></p><p>A type for trees: <a href='' id='Comment:Usin26' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Branch</span> <span class="dt">Tree</span> <span class="dt">Tree</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="co">-- <a href='' id='Comment:Usin27' ></a></span></code></pre><p>An example tree: <a href='' id='Comment:Usin28' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="dt">Branch</span> (<span class="dt">Branch</span> (<span class="dt">Leaf</span> <span class="dv">5</span>) (<span class="dt">Leaf</span> <span class="dv">3</span>))
            (<span class="dt">Leaf</span> (<span class="fu">-</span><span class="dv">99</span>))
<span class="co">-- <a href='' id='Comment:Usin29' ></a></span></code></pre><p>Computing the minimum and maximum of a tree: <a href='' id='Comment:Usin30' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">minTree (<span class="dt">Leaf</span> n) <span class="fu">=</span> n
minTree (<span class="dt">Branch</span> a b) <span class="fu">=</span> min (minTree a) (minTree b)
<span class="co">-- <a href='' id='Comment:Usin8' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell">maxTree (<span class="dt">Leaf</span> n) <span class="fu">=</span> n
maxTree (<span class="dt">Branch</span> a b) <span class="fu">=</span> max (maxTree a) (maxTree b)
<span class="co">-- <a href='' id='Comment:Usin9' ></a></span></code></pre><p>Point out that computing both requires two traversals. <a href='' id='Comment:Usin10' ></a></p><p>Computing minimum and maximum at the same time. <a href='' id='Comment:Usin11' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">minMax (<span class="dt">Leaf</span> n) <span class="fu">=</span> (n, n)
minMax (<span class="dt">Branch</span> a b) <span class="fu">=</span> (min min1 min2, max max1 max2)
  <span class="kw">where</span> (min1, max1) <span class="fu">=</span> minMax a
        (min2, max2) <span class="fu">=</span> minMax b
<span class="co">-- <a href='' id='Comment:Usin12' ></a></span></code></pre><p><code>minMax</code> is an example of <em>fusing</em> two functions together. <a href='' id='Comment:Usin13' ></a></p><p>Another operation: copying a tree and replacing all the leaves with a specific integer value: <a href='' id='Comment:Usin14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">repTree x (<span class="dt">Leaf</span> n) <span class="fu">=</span> <span class="dt">Leaf</span> x
repTree x (<span class="dt">Branch</span> a b) <span class="fu">=</span> <span class="dt">Branch</span> (repTree x a) (repTree x b)
<span class="co">-- <a href='' id='Comment:Usin15' ></a></span></code></pre><p>Now for our key puzzle: replacing every leaf in a tree with the minimum value of the tree: <a href='' id='Comment:Usin16' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">repMinA tree <span class="fu">=</span> repTree (minTree tree) tree
<span class="co">-- <a href='' id='Comment:Usin17' ></a></span></code></pre><p>This requires two traversals. It seems to truly <em>require</em> two traversals the minimum must be identified before the process of replacement can begin. <a href='' id='Comment:Usin18' ></a></p><p>But lets fuze them anyway: TODO: need to develop this in a few more steps! Here is a helper function: <a href='' id='Comment:Usin19' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">repMin&#39; (<span class="dt">Leaf</span> n, r) <span class="fu">=</span> (n, <span class="dt">Leaf</span> r)
repMin&#39; (<span class="dt">Branch</span> a b, r) <span class="fu">=</span> (min min1 min2, <span class="dt">Branch</span> newTree1 newTree2)
  <span class="kw">where</span> (min1, newTree1) <span class="fu">=</span> repMin&#39; (a, r)
        (min2, newTree2) <span class="fu">=</span> repMin&#39; (b, r)
<span class="co">-- <a href='' id='Comment:Usin20' ></a></span></code></pre><p>Finally to do the replacement with the minimum: <a href='' id='Comment:Usin21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">repMin tree <span class="fu">=</span> newTree
   <span class="kw">where</span> (min, newTree) <span class="fu">=</span> repMin&#39;(tree, min)
<span class="co">-- <a href='' id='Comment:Usin22' ></a></span></code></pre><p>Note how one of the results of the function call, the <code>min</code> value, is passed as an argument to the function call itself! <a href='' id='Comment:Usin23' ></a></p><p>TODO: Explain how this works, and give a picture. <a href='' id='Comment:Usin24' ></a></p><h3 id="implementing-recursive-let-with-haskell"><a href="#implementing-recursive-let-with-haskell"><span class="header-section-number">5.2.2</span> Implementing Recursive <code>Let</code> with Haskell</a></h3><p>The powerful techniques for recursive definition illustrated in the previous section are sufficient to implement recursive <code>let</code> expressions. In the Section on <a href="#BasicEvalEnv">Evaluation using Environments</a>, <code>let</code> was defined as follows: <a href='' id='Comment:Impl2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Let</span> x exp body) env <span class="fu">=</span> evaluate body newEnv
  <span class="kw">where</span> newEnv <span class="fu">=</span> (x, evaluate exp env) <span class="fu">:</span> env
<span class="co">-- <a href='' id='Comment:Impl3' ></a></span></code></pre><p>The problem here is that the bound expression <code>exp</code> is evaluated in the parent environment <code>env</code>. To allow the bound variable <code>x</code> to be used within the expression <code>exp</code>, the expression must be evaluated in the new environment. Fortunately this is easy to implement in Haskell: <a href='' id='Comment:Impl4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Let</span> x exp body) env <span class="fu">=</span> evaluate body newEnv
  <span class="kw">where</span> newEnv <span class="fu">=</span> (x, evaluate exp newEnv) <span class="fu">:</span> env
<span class="co">-- <a href='' id='Comment:Impl5' ></a></span></code></pre><p>The only change is the replace <code>env</code> with <code>newEnv</code> in the call to <code>evaluate</code> on <code>exp</code>. The new environment being created is passed as an argument to the evaluation function that is used during the creation of the new environment! It may see odd to use the result of a function as one of its arguments. However, as we have seen, Haskell allows such definitions. <a href='' id='Comment:Impl6' ></a></p><p>The explanation of recursion in Haskell is almost too simple. In fact, it is too simple: it involved changing 6 characters in the code for the non-recursive program. The problem is that we haven’t really explained recursion in a detailed way, because we have simply used Haskell’s recursion mechanism to implement recursive <code>let</code> expressions in our language. The question remains: how does recursion work? <a href='' id='Comment:Impl7' ></a></p><p>TODO: come up with a <em>name</em> for the little language we are defining and exploring. PLAI uses names like ArithC and ExprC. <a href='' id='Comment:Impl8' ></a></p><h4 id="recursive-definitions-in-environmentclosure-diagrams"><a href="#recursive-definitions-in-environmentclosure-diagrams"><span class="header-section-number">5.2.2.1</span> Recursive Definitions in Environment/Closure Diagrams</a></h4><p>For the case of recursive bindings, the only difference is that the order of step 2 and 3 is swapped: <a href='' id='Comment:Recu1' ></a></p><ul><li>Case <strong>Recursive</strong> <code>Let x e body</code> <a href='' id='Comment:Recu13' ></a><ol style="list-style-type: decimal"><li><p>Draw binding box for <code>x</code> with unknown value <a href='' id='Comment:Recu14' ></a></p>Set parent of new binding to be the current environment <a href='' id='Comment:Recu16' ></a></li><li>Set current environment to be the new binding <a href='' id='Comment:Recu17' ></a></li><li><p>Create the diagram for bound expression <code>e</code> <a href='' id='Comment:Recu15' ></a></p>Put the value of <code>e</code> into the binding as the value of <code>x</code> <a href='' id='Comment:Recu18' ></a></li><li>Draw diagram for <code>body</code> and remember value <a href='' id='Comment:Recu19' ></a></li><li><p>Set current environment back to what it was before <a href='' id='Comment:Recu12' ></a></p></li></ol></li></ul><p>Note that in this case the binding in Step 3 becomes the current environment <em>before</em> it is fully defined. <a href='' id='Comment:Recu20' ></a></p><p>TODO: examples here <a href='' id='Comment:Recu21' ></a></p><h2 id="understanding-recursion-with-fixed-points"><a href="#understanding-recursion-with-fixed-points"><span class="header-section-number">5.3</span> Understanding Recursion with Fixed Points</a></h2><p>Another way to explain recursion is by using the mathematical concept of a fixed point. A <em>fixed point</em> of a function <span class="math">\(f\)</span> if a value <span class="math">\(x\)</span> where <span class="math">\(x = f(x)\)</span>. If you think of a function as a transformation on values, then fixed points are values that are unchanged by the function. For example, if the function represents a rotation (imagine simple rotation of a book on a table) then the fixed point is the center of the rotation… that is the point on the book that is unchanged by rotating it. If you really did rotate a book, you’d probably push your finger down in the middle, then rotate the book around your finger. The spot under your finger is the fixed point of the rotation function. <a href='' id='Comment:Unde26' ></a></p><p>There is a large body of theory about fixed points, including applications in mathematics and fundamental theorems (see the Knaster Tarski theorem), but I’m going to avoid the math and give a practical discussion of fixed-points with examples. TODO: give citations to appropriate books. <a href='' id='Comment:Unde28' ></a></p><p>TODO: nice picture of the book and the fixed point? Use a fun book, like “Theory of Lambda Conversion”. <a href='' id='Comment:Unde29' ></a></p><h3 id="fixed-points-of-numeric-functions"><a href="#fixed-points-of-numeric-functions"><span class="header-section-number">5.3.1</span> Fixed Points of Numeric Functions</a></h3><p>Fixed-points can also be identified for simple mathematical functions: <a href='' id='Comment:Fixe2' ></a></p><table><thead><tr class="header"><th align="left"><em>function</em>              </th><th align="left"><em>fixed point(s)</em></th></tr></thead><tbody><tr class="odd"><td align="left"><span class="math">\(i_{10}(x) = 10 - x\)</span></td><td align="left"><span class="math">\(5\)</span></td></tr><tr class="even"><td align="left"><span class="math">\(square(x) = x^2\)</span></td><td align="left"><span class="math">\(0, 1\)</span></td></tr><tr class="odd"><td align="left"><span class="math">\(g_\phi(x) = 1 + \cfrac{1}{x}\)</span></td><td align="left"><span class="math">\(1.6180339887...\)</span></td></tr><tr class="even"><td align="left"><span class="math">\(k_4(x) = 4\)</span></td><td align="left"><span class="math">\(4\)</span></td></tr><tr class="odd"><td align="left"><span class="math">\(id(x) = x\)</span></td><td align="left">all values are fixed points</td></tr><tr class="even"><td align="left"><span class="math">\(inc(x) = x + 1\)</span></td><td align="left">no fixed points <a href='' id='Comment:Fixe3' ></a></td></tr></tbody></table><p>As you can see, some functions have one fixed point. Some functions have multiple fixed points. Others have an infinite number of fixed points, while some don’t have any at all. The fixed point of <span class="math">\(g_\phi\)</span> is the <em>golden ratio</em>, also known as <span class="math">\(\phi\)</span>. <a href='' id='Comment:Fixe4' ></a></p><p>Fixed points are useful because they can provide a general approach to solving equations where a variable appears on both sides of an equation. Consider this simple equation: <a href='' id='Comment:Fixe5' ></a></p><p><span class="math">\(x = 10 - x\)</span> <a href='' id='Comment:Fixe6' ></a></p><p>Rather than performing the normal algebraic manipulation to solve it, consider expressing the right side of the equation using a new helper function, <span class="math">\(g\)</span>: <a href='' id='Comment:Fixe7' ></a></p><p><span class="math">\(g(x) = 10 - x\)</span> <a href='' id='Comment:Fixe8' ></a></p><p>Functions created in this way are called <em>generators</em> for recursive equations. Given the generator <span class="math">\(g\)</span>, the original equation can be rewritten as: <a href='' id='Comment:Fixe9' ></a></p><p><span class="math">\(x = g(x)\)</span> <a href='' id='Comment:Fixe10' ></a></p><p>Any value <span class="math">\(x\)</span> that satisfies <span class="math">\(x = g(x)\)</span> is a fixed point of <span class="math">\(g\)</span>. Conversely, any fixed point of <span class="math">\(g\)</span> is a solution to the original equation. This means that finding a solution to the original equation is equivalent to finding a fixed point for <span class="math">\(g\)</span>. Imagine that there was a magic function <code>fix</code> that could automatically find a fixed point for any function<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup>. Then one way to find a fixed point of <span class="math">\(g\)</span> would be to use <code>fix</code>, by calling <code>fix</code><span class="math">\((g)\)</span>. Then the solution to the equation above could be rewritten using <code>fix</code>: <a href='' id='Comment:Fixe11' ></a></p><p><span class="math">\(x =\)</span> <code>fix</code><span class="math">\((g)\)</span> <a href='' id='Comment:Fixe12' ></a></p><p>This result looks like a <em>solution</em> for <span class="math">\(x\)</span>, in the sense that it is an equation where <span class="math">\(x\)</span> appears only by itself on the left of the equation. Any equation where a variable appears by itself on the left and anywhere on the right side of the equation, can be rewritten as a fixed point equation. <a href='' id='Comment:Fixe14' ></a></p><p>Note that <code>fix</code> is a higher-order function: it takes a function as an input, and returns a value as a result. <a href='' id='Comment:Fixe15' ></a></p><p>The problem is that the solution relies on <code>fix</code>, a function that hasn’t been defined yet, and maybe cannot be defined. Is it possible to automatically find a fixed point of any function? Does the function <code>fix</code> exist? Can it be defined? <a href='' id='Comment:Fixe16' ></a></p><h3 id="fixed-points-by-iterative-application"><a href="#fixed-points-by-iterative-application"><span class="header-section-number">5.3.2</span> Fixed Points by Iterative Application</a></h3><p>It turns out that there is no way to find fixed points for <em>any</em> arbitrary function <span class="math">\(f\)</span>, but for a certain class of well behaved functions, it <em>is</em> possible to compute fixed points automatically. In this case, “well behaved” means that the function converges on the solution when applied repeatedly. For example, consider function <span class="math">\(g_\phi\)</span> defined above: <a href='' id='Comment:Fixe1' ></a></p><p><span class="math">\(g_\phi(x) = 1 + \cfrac{1}{x}\)</span> <a href='' id='Comment:Fixe17' ></a></p><p>Consider multiple invocations of <span class="math">\(g_\phi\)</span> starting with <span class="math">\(g_\phi(1)\)</span>. The following table summarizes this process. The first column represents the iteration number, which starts at one and increases with each iteration. The second column is a representation of the computation as an explicit <em>power</em> of a function. The power of a function <span class="math">\(f^n(x)\)</span> means to apply <span class="math">\(f\)</span> repeatedly until it has been performed <span class="math">\(n\)</span> times, passing the result of one call as the input of the next call. For example, <span class="math">\(f^3(x)\)</span> means <span class="math">\(f(f(f(x)))\)</span>. The next column shows just the application of <span class="math">\(g_\phi\)</span> to the previous result. The final column gives the result for that iteration. <a href='' id='Comment:Fixe19' ></a></p><table><thead><tr class="header"><th align="left">#</th><th align="left">power</th><th align="left">previous</th><th align="left"></th><th align="left">result</th></tr></thead><tbody><tr class="odd"><td align="left">1</td><td align="left"><span class="math">\(g_\phi^{1}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1)               \)</span></td><td align="left">=</td><td align="left">2</td></tr><tr class="even"><td align="left">2</td><td align="left"><span class="math">\(g_\phi^{2}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(2)               \)</span></td><td align="left">=</td><td align="left">1.5</td></tr><tr class="odd"><td align="left">3</td><td align="left"><span class="math">\(g_\phi^{3}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1.5)             \)</span></td><td align="left">=</td><td align="left">1.6666666667</td></tr><tr class="even"><td align="left">4</td><td align="left"><span class="math">\(g_\phi^{4}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1.66666666666667)\)</span></td><td align="left">=</td><td align="left">1.6</td></tr><tr class="odd"><td align="left">5</td><td align="left"><span class="math">\(g_\phi^{5}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1.6)             \)</span></td><td align="left">=</td><td align="left">1.625</td></tr><tr class="even"><td align="left">6</td><td align="left"><span class="math">\(g_\phi^{6}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1.625)           \)</span></td><td align="left">=</td><td align="left">1.6153846154</td></tr><tr class="odd"><td align="left">7</td><td align="left"><span class="math">\(g_\phi^{7}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1.61538461538462)\)</span></td><td align="left">=</td><td align="left">1.619047619</td></tr><tr class="even"><td align="left">8</td><td align="left"><span class="math">\(g_\phi^{8}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1.61904761904762)\)</span></td><td align="left">=</td><td align="left">1.6176470588</td></tr><tr class="odd"><td align="left">9</td><td align="left"><span class="math">\(g_\phi^{9}(1) \)</span></td><td align="left"><span class="math">\(g_\phi(1.61764705882353)\)</span></td><td align="left">=</td><td align="left">1.6181818182</td></tr><tr class="even"><td align="left">10</td><td align="left"><span class="math">\(g_\phi^{10}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61818181818182)\)</span></td><td align="left">=</td><td align="left">1.6179775281</td></tr><tr class="odd"><td align="left">11</td><td align="left"><span class="math">\(g_\phi^{11}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61797752808989)\)</span></td><td align="left">=</td><td align="left">1.6180555556</td></tr><tr class="even"><td align="left">12</td><td align="left"><span class="math">\(g_\phi^{12}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61805555555556)\)</span></td><td align="left">=</td><td align="left">1.6180257511</td></tr><tr class="odd"><td align="left">13</td><td align="left"><span class="math">\(g_\phi^{13}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61802575107296)\)</span></td><td align="left">=</td><td align="left">1.6180371353</td></tr><tr class="even"><td align="left">14</td><td align="left"><span class="math">\(g_\phi^{14}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61803713527851)\)</span></td><td align="left">=</td><td align="left">1.6180327869</td></tr><tr class="odd"><td align="left">15</td><td align="left"><span class="math">\(g_\phi^{15}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61803278688525)\)</span></td><td align="left">=</td><td align="left">1.6180344478</td></tr><tr class="even"><td align="left">16</td><td align="left"><span class="math">\(g_\phi^{16}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61803444782168)\)</span></td><td align="left">=</td><td align="left">1.6180338134</td></tr><tr class="odd"><td align="left">17</td><td align="left"><span class="math">\(g_\phi^{17}(1)\)</span></td><td align="left"><span class="math">\(g_\phi(1.61803381340013)\)</span></td><td align="left">=</td><td align="left">1.6180340557 <a href='' id='Comment:Fixe20' ></a></td></tr></tbody></table><p>Here is a plot of how the function converges: <a href='' id='Comment:Fixe48' ></a></p><p><embed src="figures/converge.png" /> <a href='' id='Comment:Fixe21' ></a></p><p>The result converges on <span class="math">\(1.6180339887...\)</span> which is the value of <span class="math">\(\phi\)</span>. It turns out that iterating <span class="math">\(g_\phi\)</span> converges on <span class="math">\(\phi\)</span> for any starting number. The fixed point is the <em>limit</em> of applying the transformation function <span class="math">\(g_\phi\)</span> infinitely many times. One way to express the fixed point is <a href='' id='Comment:Fixe22' ></a></p><p><code>fix</code><span class="math">\((f) = f^\infty(start)\)</span> <a href='' id='Comment:Fixe24' ></a></p><p>This means the application of <span class="math">\(f\)</span> an infinite number of times to some starting value. Finding the right starting value can be difficult. In some cases any starting value will work, but in other cases it’s important to use a particular value. In the theory of fixed points, (TODO: discuss the theory somewhere), the initial value is the bottom of an appropriate lattice. <a href='' id='Comment:Fixe25' ></a></p><p>The fixed point of some, but not all, functions can be computed by repeated function application. Here are the results for this technique, when applied to the examples given above: <a href='' id='Comment:Fixe26' ></a></p><table><thead><tr class="header"><th align="left"><em>function</em>              </th><th align="left">result for repeated invocation</th></tr></thead><tbody><tr class="odd"><td align="left"><span class="math">\(inv_{10}(x) = 10 - x\)</span></td><td align="left">infinite loop</td></tr><tr class="even"><td align="left"><span class="math">\(square(x) = x^2\)</span></td><td align="left">infinite loop</td></tr><tr class="odd"><td align="left"><span class="math">\(g_\phi(x) = 1 + \cfrac{1}{x}\)</span></td><td align="left"><span class="math">\(1.6180339887...\)</span></td></tr><tr class="even"><td align="left"><span class="math">\(const_4(x) = 4\)</span></td><td align="left"><span class="math">\(4\)</span></td></tr><tr class="odd"><td align="left"><span class="math">\(id(x) = x\)</span></td><td align="left">infinite loop</td></tr><tr class="even"><td align="left"><span class="math">\(inc(x) = x + 1\)</span></td><td align="left">infinite loop <a href='' id='Comment:Fixe27' ></a></td></tr></tbody></table><p>Only two of the six examples worked. Fixed points are not a general method for solving numeric equations. <a href='' id='Comment:Fixe28' ></a></p><h3 id="fixed-points-for-recursive-structures"><a href="#fixed-points-for-recursive-structures"><span class="header-section-number">5.3.3</span> Fixed Points for Recursive Structures</a></h3><p>The infinite recursive structures discussed in <a href="#Cyclic">Section on Haskell Recursion</a> can also be defined using fixed points: <a href='' id='Comment:Fixe29' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">g_twos l <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> l
<span class="co">-- <a href='' id='Comment:Fixe30' ></a></span></code></pre><p>The function <code>g_twos</code> is a non-recursive function that adds a 2 to the front of a list. Here are some test cases for applying <code>g_twos</code> to various lists: <a href='' id='Comment:Fixe31' ></a></p><table><thead><tr class="header"><th align="left">input</th><th align="left">output</th><th align="left">input = output</th></tr></thead><tbody><tr class="odd"><td align="left"><code>[]</code></td><td align="left"><code>[2]</code></td><td align="left">no</td></tr><tr class="even"><td align="left"><code>[1]</code></td><td align="left"><code>[2,1]</code></td><td align="left">no</td></tr><tr class="odd"><td align="left"><code>[3,4,5]</code></td><td align="left"><code>[2,3,4,5]</code></td><td align="left">no</td></tr><tr class="even"><td align="left"><code>[2,2,2,2,2]</code></td><td align="left"><code>[2,2,2,2,2,2]</code></td><td align="left">no</td></tr><tr class="odd"><td align="left"><code>[2,2,2,...]</code></td><td align="left"><code>[2,2,2,...]</code></td><td align="left"><em>yes</em> <a href='' id='Comment:Fixe32' ></a></td></tr></tbody></table><p>The function <code>g_twos</code> can be applied to any list. If it is applied to any finite list, then the input and output lists cannot be the same because the output is one element longer then the input. This is not a problem for infinite lists, because adding an item to the front of an infinite list is still an infinite list. Adding a 2 onto the front of an infinite list of 2s will return an infinite list of 2s. Thus an infinite list of 2s is a fixed point of <code>g_twos</code>. <a href='' id='Comment:Fixe34' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">fix(g_twos)  <span class="fu">==&gt;</span>  [<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="fu">...</span>]
<span class="co">-- <a href='' id='Comment:Fixe23' ></a></span></code></pre><p>Functions used in this way are called generators because they generate recursive structures. One way to think about them is that the function performs <em>one step</em> in the creation of a infinite structure, and then the <code>fix</code> function repeats that step over and over until the full infinite structure is created. Consider what happens when the output of the function is applied to the input of the previous iteration. The results are <code>[]</code>, <code>[2]</code>, <code>[2,2]</code>, <code>[2,2,2]</code>, <code>[2,2,2,2]</code>, … At each step the result is a better approximation of the final solution. <a href='' id='Comment:Fixe35' ></a></p><p>The second example, a recursive definition that creates a list containing the natural numbers, is more interesting: <a href='' id='Comment:Fixe36' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">g_numbers ns <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> [ n <span class="fu">+</span> <span class="dv">1</span> <span class="fu">|</span> n <span class="ot">&lt;-</span> ns ]
<span class="co">-- <a href='' id='Comment:Fixe37' ></a></span></code></pre><p>This function takes a list as an input, it adds one to each item in the list and then puts a <code>0</code> on the front of the list. <a href='' id='Comment:Fixe38' ></a></p><p>Here are the result when applied to the same test cases listed above: <a href='' id='Comment:Fixe39' ></a></p><table><thead><tr class="header"><th align="left">input</th><th align="left">output</th><th align="left">input = output</th></tr></thead><tbody><tr class="odd"><td align="left"><code>[]</code></td><td align="left"><code>[0]</code></td><td align="left">no</td></tr><tr class="even"><td align="left"><code>[1]</code></td><td align="left"><code>[0,2]</code></td><td align="left">no</td></tr><tr class="odd"><td align="left"><code>[3,4,5]</code></td><td align="left"><code>[0,4,5,6]</code></td><td align="left">no</td></tr><tr class="even"><td align="left"><code>[2,2,2,2,2]</code></td><td align="left"><code>[0,3,3,3,3,3]</code></td><td align="left">no</td></tr><tr class="odd"><td align="left"><code>[2,2,2,...]</code></td><td align="left"><code>[0,3,3,3,...]</code></td><td align="left">no <a href='' id='Comment:Fixe40' ></a></td></tr></tbody></table><p>A more interesting set of test cases involves starting with the empty list, then using each function result as the next test case: <a href='' id='Comment:Fixe41' ></a></p><table><thead><tr class="header"><th align="left">input</th><th align="left">output</th><th align="left">input = output</th></tr></thead><tbody><tr class="odd"><td align="left"><code>[]</code></td><td align="left"><code>[0]</code></td><td align="left">no</td></tr><tr class="even"><td align="left"><code>[0]</code></td><td align="left"><code>[0,1]</code></td><td align="left">no</td></tr><tr class="odd"><td align="left"><code>[0,1]</code></td><td align="left"><code>[0,1,2]</code></td><td align="left">no</td></tr><tr class="even"><td align="left"><code>[0,1,2]</code></td><td align="left"><code>[0,1,2,3]</code></td><td align="left">no</td></tr><tr class="odd"><td align="left"><code>[0,1,2,3]</code></td><td align="left"><code>[0,1,2,3,4]</code></td><td align="left">no</td></tr><tr class="even"><td align="left"><code>[0,1,2,3,4]</code></td><td align="left"><code>[0,1,2,3,4,5]</code></td><td align="left">no</td></tr><tr class="odd"><td align="left"><code>[0,1,2,3,4,5,...]</code></td><td align="left"><code>[0,1,2,3,4,5,6,...]</code></td><td align="left"><em>yes</em> <a href='' id='Comment:Fixe42' ></a></td></tr></tbody></table><p>The only list that is unchanged after applying <code>g_numbers</code> is the list of natural numbers: <a href='' id='Comment:Fixe43' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">fix(g_numbers)  <span class="fu">==&gt;</span>  [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="fu">...</span>]
<span class="co">-- <a href='' id='Comment:Fixe33' ></a></span></code></pre><p>By staring with the empty list and then applying <code>g_numbers</code> repeatedly, the result eventually converges on the fixed point. Each step is a better approximation of the final answer. <a href='' id='Comment:Fixe18' ></a></p><h3 id="fixed-points-of-higher-order-functions"><a href="#fixed-points-of-higher-order-functions"><span class="header-section-number">5.3.4</span> Fixed Points of Higher-Order Functions</a></h3><p>TODO: text explaining how to implement <code>fact</code> using fix. <a href='' id='Comment:Fixe44' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">g_fact <span class="fu">=</span> \f <span class="ot">-&gt;</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="fu">*</span> f(n<span class="fu">-</span><span class="dv">1</span>)
<span class="co">-- <a href='' id='Comment:Fixe45' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell">fact <span class="fu">=</span> fix g_fact
<span class="co">-- <a href='' id='Comment:Fixe46' ></a></span></code></pre><p>more… <a href='' id='Comment:Fixe47' ></a></p><h3 id="a-recursive-definition-of-fix"><a href="#a-recursive-definition-of-fix"><span class="header-section-number">5.3.5</span> A Recursive Definition of <code>fix</code></a></h3><p>Haskell allows an elegant definition of <code>fix</code> using recursion, which avoids the issue of selecting a starting value for the iteration. <a href='' id='Comment:A57' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">fix g <span class="fu">=</span> g (fix g)
<span class="co">-- <a href='' id='Comment:A58' ></a></span></code></pre><p>This definition is beautiful because it is a direct translation of the original mathematic definition of a fixed point: <code>fix</code><span class="math">\((f)\)</span> is a value <span class="math">\(x\)</span> such that <span class="math">\(x = f(x)\)</span>. Substituting <code>fix</code><span class="math">\((f)\)</span> for <span class="math">\(x\)</span> gives the definition above. <a href='' id='Comment:A4' ></a></p><p>From an algorithmic viewpoint, the definition of only works because of lazy evaluation in Haskell. To compute <code>fix g</code> Haskell evaluates <code>g (fix g)</code> but does not immediately evaluate the argument <code>fix g</code>. Remember that arguments in Haskell are only evaluated if they are <em>needed</em>. Instead it begins evaluating the body of <code>g</code>, which may or may not use its argument. <a href='' id='Comment:A59' ></a></p><h3 id="a-non-recursive-definition-of-fix"><a href="#a-non-recursive-definition-of-fix"><span class="header-section-number">5.3.6</span> A Non-Recursive Definition of <code>fix</code></a></h3><p>It is also possible to define <code>fix</code> non-recursively, by using <em>self application</em>. Self application is when a function is applied to itself. This works because functions are values, so a function can be passed as an argument to itself. For example, consider the identity function, which simply returns its argument: <a href='' id='Comment:A60' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">id x <span class="fu">=</span> x
<span class="co">-- <a href='' id='Comment:A61' ></a></span></code></pre><p>The identity function can be applied to <em>any</em> value, because it doesn’t do anything with the argument other than return it. Since it can be applied to any value, it can be applied to itself: <a href='' id='Comment:A62' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">id(id)   
<span class="co">-- returns id</span>
<span class="co">-- <a href='' id='Comment:A63' ></a></span></code></pre><p>Self application is not a very common technique, but it is certainly interesting. Here is a higher-order function that takes a function as an argument and immediately applies the function to itself: <a href='' id='Comment:A64' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">stamp f <span class="fu">=</span> f(f)
<span class="co">-- <a href='' id='Comment:A45' ></a></span></code></pre><p>Unfortunately, the <code>stamp</code> function cannot be coded in Haskell, because it is rejected by Haskell’s type system. When a function of type <span class="math">\(a \rightarrow b\)</span> is applied to itself, the argument type <span class="math">\(a\)</span> must be equivalent to <span class="math">\(a \rightarrow b\)</span>. There are no types in the Haskell type system that can express a solution to type equation <span class="math">\(a = a \rightarrow b\)</span>. Attempting to define <code>stamp</code> results in a Haskell compile-time error: <a href='' id='Comment:A65' ></a></p><pre><code>Occurs check: cannot construct the infinite type: t1 = t1 -&gt; t0  <a href='' id='Comment:A66' ></a></code></pre><p>Many other languages allow <code>stamp</code> to be defined, either using more complex or weaker type systems. Dynamic languages do not have any problem defining <code>stamp</code>. For example, here is a definition of <code>stamp</code> in JavaScript: <a href='' id='Comment:A67' ></a></p><pre class="sourceCode Java"><code class="sourceCode java">stamp = <span class="fu">function</span>(f) { <span class="kw">return</span> <span class="fu">f</span>(f); }
<a href='' id='Comment:A50' ></a></code></pre><p>The interesting question is what happens when <code>stamp</code> is applied to itself: <code>stamp(stamp)</code>. This call binds <code>f</code> to <code>stamp</code> and then executes <code>f(f)</code> which is <code>stamp(stamp)</code>. The effect is an immediate infinite loop, where stamp is applied to itself over and over again. What is interesting is that <code>stamp</code> is not recursive, and it does not have a while loop. But it manages to generate an infinite loop anyway. <a href='' id='Comment:A68' ></a></p><p>Given the ability to loop infinitely, it is also possible to execute a function infinitely many times. <a href='' id='Comment:A69' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">fix g <span class="fu">=</span> stamp (g <span class="fu">.</span> stamp)
<span class="co">-- <a href='' id='Comment:A53' ></a></span></code></pre><p>TODO: explain composition (<code>.</code>) operator <a href='' id='Comment:A70' ></a></p><p>Here are the steps in executing <code>fix</code> for a function <code>g</code>: <a href='' id='Comment:A71' ></a></p><ul><li><p><code>fix g</code> <a href='' id='Comment:A72' ></a></p>{ definition of <code>fix</code>} <a href='' id='Comment:A73' ></a></li><li><p>= <code>stamp (g . stamp)</code> <a href='' id='Comment:A19' ></a></p>{ definition of <code>stamp</code>} <a href='' id='Comment:A74' ></a></li><li><p>= <code>(g . stamp)(g . stamp)</code> <a href='' id='Comment:A21' ></a></p>{ definition of <code>.</code>} <a href='' id='Comment:A75' ></a></li><li><p>= <code>g(stamp(g . stamp))</code> <a href='' id='Comment:A36' ></a></p>{ definition of <code>fix</code>} <a href='' id='Comment:A76' ></a></li><li><p>= <code>g(fix g)</code> <a href='' id='Comment:A80' ></a></p></li></ul><p>This version of <code>fix</code> uses self-application to create a self-replicating program, which is then harnessed as an engine to invoke a function infinitely many times. This version of <code>fix</code> is traditionally written as <span class="math">\(\lambda g. (\lambda x. g(x x)) (\lambda x. g(x x))\)</span>, but this is the same as the version given above with the definition of <code>stamp</code> expanded. <a href='' id='Comment:A77' ></a></p><p>A second problem with this definition of <code>fix</code> is that it <em>diverges</em>, or creates an infinite loop, when executed in non-lazy languages. Thus it cannot be used in Haskell because of self-application, and it cannot be used in most other languages because of strict evaluation. A non-strict version can be defined: <a href='' id='Comment:A78' ></a></p><p>Y = <code>stamp</code>(<span class="math">\(\lambda\)</span>f.(<span class="math">\(\lambda\)</span>x.f(<span class="math">\(\lambda\)</span>v.(<code>stamp</code> x v)))) <a href='' id='Comment:A28' ></a></p><p>Finally, explicit fixed points involve creation of many closures. <a href='' id='Comment:A79' ></a></p><h2 id="understanding-recursion-with-self-application"><a href="#understanding-recursion-with-self-application"><span class="header-section-number">5.4</span> Understanding Recursion with Self-Application</a></h2><p>Another way to implement recursion is by writing self-application directly into a function. For example, here is a non-recursive version of fact based on integrated self-application, defined in JavaScript. <a href='' id='Comment:Unde30' ></a></p><pre class="sourceCode Java"><code class="sourceCode java">fact_s = <span class="fu">function</span>(f, n) {
  <span class="kw">if</span> (n == <span class="dv">0</span>)
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">else</span>
    <span class="kw">return</span> n * <span class="fu">f</span>(f, n - <span class="dv">1</span>);
}
<a href='' id='Comment:Unde21' ></a></code></pre><p>To call <code>fact_s</code> to compute a factorial, it is necessary to pass <code>fact_s</code> as an argument to itself: <a href='' id='Comment:Unde31' ></a></p><pre class="sourceCode Java"><code class="sourceCode java"><span class="fu">fact_s</span>(fact_s, <span class="dv">10</span>);
<a href='' id='Comment:Unde25' ></a></code></pre><p>This definition builds the self-application into the <code>fact_s</code> function, rather than separating it into a generator and a fixed point function. One way to derive <code>fact_s</code> is from the self-applicative <code>fix</code> function. Remember that <a href='' id='Comment:Unde32' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">fact <span class="fu">=</span> stamp (g_fact <span class="fu">.</span> stamp)
<span class="co">-- <a href='' id='Comment:Unde27' ></a></span></code></pre><p><code>fact_s</code> is created by <em>merging</em> <code>g_fact</code> with <code>stamp</code>. The other use of <code>stamp</code> indicates that <code>fact_s</code> must be applied to itself to compute a factorial. <a href='' id='Comment:Unde33' ></a></p><p>One interesting thing about this final implementation strategy is that it is <em>exactly</em> the strategy used in the actual implementation of languages, including C++ and Java. <a href='' id='Comment:Unde9' ></a></p><h1 id="Monads"><a href="#Monads"><span class="header-section-number">6</span> Computational Strategies</a></h1><p>In previous sections the Exp language was extended with specific kinds of expressions and values, for example the <code>let</code> and <code>functions</code>. In addition to augmenting the language with new expression types, it is also possible to consider extensions that have a general impact on every part of the language. Some examples are error handling, tracing of code, and mutable state. <a href='' id='Comment:Comp2' ></a></p><h2 id="error-checking"><a href="#error-checking"><span class="header-section-number">6.1</span> Error Checking</a></h2><p>Errors are an important aspect of computation. They are typically a pervasive feature of a language, beause they affect the way that every expression is evaluated. For example, the expression <code>a+b</code> may not cause any errors, but if evaluating <code>a</code> or <code>b</code> can cause an error, then the evaluation of <code>a+b</code> will have to deal with the possibility that <code>a</code> or <code>b</code> is an error. The full code is given in the <a href="./code/ErrorChecking.hs.htm">Error Checking</a> file. <a href='' id='Comment:Hand2' ></a></p><p>Error checking is a notorious problem in programming languages. When coding in C, everyone agrees that the return codes of all system calls should be checked to make sure that an error did not occur. However, most C programs don’t check the return codes, leading to serious problems when things start to go wrong. <a href='' id='Comment:Hand3' ></a></p><p>Errors are pervasive because any expression can either return a value or it can signal an error. One way to represent this possibility is by defining a new data type that has two possibilities: either a <em>good</em> value or an error. <a href='' id='Comment:Hand4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Checked</span> a <span class="fu">=</span> <span class="dt">Good</span> a <span class="fu">|</span> <span class="dt">Error</span> <span class="dt">String</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="co">-- <a href='' id='Comment:Hand5' ></a></span></code></pre><p>The declaration defines a generic <code>Checked</code> type that has a parameter <code>a</code> representing the type of the good value. The <code>Checked</code> type has two constructors, <code>Good</code> and <code>Error</code>. The <code>Good</code> constructor takes a value of type <code>a</code> and labels it as good. The <code>Error</code> constructor has an error message. The following figure is an abstraction illustration of a <code>Checked</code> value, which represents a computation that may either be a good value or an error. <a href='' id='Comment:Hand6' ></a></p><p><embed src="figures/ErrroShape.png" /> <a href='' id='Comment:Err9' ></a></p><h3 id="error-checking-in-basic-expressions"><a href="#error-checking-in-basic-expressions"><span class="header-section-number">6.1.1</span> Error Checking in Basic Expressions</a></h3><p>To keep things simple and focused on errors, this section will only consider expressions with literals, variables, binary operators. This smaller language is similar to the one that was introduced at the beginning of the book. More features will be added later. Although the syntax of expressions does not have to change, but the type of the <code>evaluate</code> function must be changed to return an <code>Error</code> value: <a href='' id='Comment:Hand7' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Checked</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env <span class="fu">=</span> <span class="dt">Good</span> v
<span class="co">-- <a href='' id='Comment:Hand8' ></a></span></code></pre><p>Evaluation of a literal can never cause an error. The value is marked as a <code>Good</code> value and returned. <a href='' id='Comment:Hand9' ></a></p><p>A variable can be undefined, so it evaluating a variable may return an error: <a href='' id='Comment:Hand10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Variable</span> x) env <span class="fu">=</span>
  <span class="kw">case</span> lookup x env <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="st">&quot;Variable &quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot; undefined&quot;</span>)
    <span class="dt">Just</span> v  <span class="ot">-&gt;</span> <span class="dt">Good</span> v
<span class="co">-- <a href='' id='Comment:Hand11' ></a></span></code></pre><h3 id="error-checking-in-multiple-sub-expressions"><a href="#error-checking-in-multiple-sub-expressions"><span class="header-section-number">6.1.2</span> Error Checking in Multiple Sub-expressions</a></h3><p>The case for binary operations is more interesting. Here is the original rule for evaluating binary expressions: <a href='' id='Comment:Hand12' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Binary</span> op a b) env  <span class="fu">=</span> binary op (evaluate a env) (evaluate b env)
<span class="co">-- <a href='' id='Comment:Hand13' ></a></span></code></pre><p>The problem is that either <code>evaluate a env</code> or <code>evaluate b env</code> could return an <code>Error</code> value. The actual binary operation is only performed if they both return <code>Good</code> values. Finally, the binary operation itself might cause a new error. Thus there are three places where errors can arise: in <code>evaluate a env</code>, in <code>evaluate b env</code>, or in <code>binary</code>. This definition for <code>evaluate</code> of a binary operator handles the first two situations: <a href='' id='Comment:Hand14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Binary</span> op a b) env <span class="fu">=</span>
  <span class="kw">case</span> evaluate a env <span class="kw">of</span>
    <span class="dt">Error</span> msg <span class="ot">-&gt;</span> <span class="dt">Error</span> msg
    <span class="dt">Good</span> av <span class="ot">-&gt;</span>
      <span class="kw">case</span> evaluate b env <span class="kw">of</span>
        <span class="dt">Error</span> msg <span class="ot">-&gt;</span> <span class="dt">Error</span> msg
        <span class="dt">Good</span> bv <span class="ot">-&gt;</span>
          checked_binary op av bv
<span class="co">-- <a href='' id='Comment:Hand15' ></a></span></code></pre><p>Now it should be clear why programmers do not always check all error return codes: because it is tedious and requires lots of code! What was originally a one-line program is now 8 lines and uses additional temporary variables. When multiple sub-expressions can generate errors, it is necessary to <em>compose</em> multiple error checks together. The situation in the case of <code>Binary</code> operations is illustrated in the following figure: <a href='' id='Comment:Hand16' ></a></p><p><embed src="figures/ErrorBind.png" /> <a href='' id='Comment:Err10' ></a></p><p>This figure illustrates the composition of two sub-expressions <code>A</code> and <code>B</code> which represent computations of checked values. The composition of the two computations is a new computation that also has the shape of a checked value. If either <code>A</code> or <code>B</code> outputs an error, then the resulting computation signals an errors. The arrow from <code>A</code> to the top of <code>B</code> represents passing the good value from <code>A</code> into <code>B</code> as an extra input. This means that <code>B</code> can depend upon the good value of <code>A</code>. But <code>B</code> is never invoked if <code>A</code> signals an error. <a href='' id='Comment:Erro1' ></a></p><p>The <code>binary</code> helper function must be updated to signal divide by zero: <a href='' id='Comment:Hand22' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">checked_unary ::</span> <span class="dt">UnaryOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Checked</span> <span class="dt">Value</span>
checked_unary <span class="dt">Not</span> (<span class="dt">BoolV</span> b) <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (not b))
checked_unary <span class="dt">Neg</span> (<span class="dt">IntV</span> i)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">IntV</span> (<span class="fu">-</span>i))
checked_unary _   _         <span class="fu">=</span> <span class="dt">Error</span> <span class="st">&quot;Type error&quot;</span>

<span class="ot">checked_binary ::</span> <span class="dt">BinaryOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Checked</span> <span class="dt">Value</span>
checked_binary <span class="dt">Add</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">IntV</span> (a <span class="fu">+</span> b))
checked_binary <span class="dt">Sub</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">IntV</span> (a <span class="fu">-</span> b))
checked_binary <span class="dt">Mul</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">IntV</span> (a <span class="fu">*</span> b))
checked_binary <span class="dt">Div</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> <span class="dv">0</span>)  <span class="fu">=</span> <span class="dt">Error</span> <span class="st">&quot;Divide by zero&quot;</span>
checked_binary <span class="dt">Div</span> (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">IntV</span> (a <span class="ot">`div`</span> b))
checked_binary <span class="dt">And</span> (<span class="dt">BoolV</span> a) (<span class="dt">BoolV</span> b) <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (a <span class="fu">&amp;&amp;</span> b))
checked_binary <span class="dt">Or</span>  (<span class="dt">BoolV</span> a) (<span class="dt">BoolV</span> b) <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (a <span class="fu">||</span> b))
checked_binary <span class="dt">LT</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (a <span class="fu">&lt;</span> b))
checked_binary <span class="dt">LE</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (a <span class="fu">&lt;=</span> b))
checked_binary <span class="dt">GE</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (a <span class="fu">&gt;=</span> b))
checked_binary <span class="dt">GT</span>  (<span class="dt">IntV</span> a)  (<span class="dt">IntV</span> b)  <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (a <span class="fu">&gt;</span> b))
checked_binary <span class="dt">EQ</span>  a         b         <span class="fu">=</span> <span class="dt">Good</span> (<span class="dt">BoolV</span> (a <span class="fu">==</span> b))
checked_binary _   _         _         <span class="fu">=</span> <span class="dt">Error</span> <span class="st">&quot;Type error&quot;</span>
<span class="co">-- <a href='' id='Comment:Hand17' ></a></span></code></pre><p>All the other cases are the same as before, so <code>checked_binary</code> calls <code>binary</code> and then tags the resulting value as <code>Good</code>. <a href='' id='Comment:Hand18' ></a></p><h3 id="examples-of-errors"><a href="#examples-of-errors"><span class="header-section-number">6.1.3</span> Examples of Errors</a></h3><p>Evaluating an expression may now return an error for unbound variables: <a href='' id='Comment:Hand27' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Variable</span> <span class="st">&quot;x&quot;</span>) []
<span class="co">-- <a href='' id='Comment:Hand28' ></a></span></code></pre><p>The result of evaluation is: <a href='' id='Comment:Hand29' ></a></p><pre><code>Error &quot;Variable x undefined&quot; <a href='' id='Comment:Hand30' ></a></code></pre><p>Or for divide by zero: <a href='' id='Comment:Hand31' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Binary</span> <span class="dt">Div</span> (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">3</span>)) (<span class="dt">Literal</span> (<span class="dt">IntV</span> <span class="dv">0</span>)) ) []
<span class="co">-- <a href='' id='Comment:Hand32' ></a></span></code></pre><p>The result of evaluation is: <a href='' id='Comment:Hand33' ></a></p><pre><code>Error &quot;Divide by zero&quot; <a href='' id='Comment:Hand34' ></a></code></pre><p>Your take-away from this section should be that checking error everywhere is messy and tedious. The code for binary operators has to deal with errors, even though most binary operators don’t have anything to do with error handling. <a href='' id='Comment:Hand35' ></a></p><h4 id="exercise-5.1-complete-error-checking-was-5.1.1"><a href="#exercise-5.1-complete-error-checking-was-5.1.1"><span class="header-section-number">6.1.3.1</span> Exercise 5.1: Complete Error Checking (was 5.1.1)</a></h4><p>Extend the evaluator with error checking for the remaining expression cases, including <code>if</code>, non-recursive <code>let</code>, and function definition/calls. Ensure that all errors, including pattern match failures, are captured by your code and converted to <code>Error</code> values, rather than causing Haskell execution errors. <a href='' id='Comment:Exer8' ></a></p><p>As a bonus, implement error checking for recursive <code>let</code> expressions. <a href='' id='Comment:Exer5' ></a></p><h4 id="exercise-5.2-error-handling-was-5.1.2"><a href="#exercise-5.2-error-handling-was-5.1.2"><span class="header-section-number">6.1.3.2</span> Exercise 5.2: Error Handling (was 5.1.2)</a></h4><p>In the code given above, all errors cause the program to terminate execution. Extend the language with a <code>try</code>/<code>catch</code> expression that allows errors to be caught and handled within a program. <a href='' id='Comment:Exer6' ></a></p><h4 id="exercise-5.3-multiple-bindings-and-arguments"><a href="#exercise-5.3-multiple-bindings-and-arguments"><span class="header-section-number">6.1.3.3</span> Exercise 5.3: Multiple Bindings and Arguments</a></h4><p>If you really want to experience how messy it is to explicitly program error handling, implement error checking where <code>let</code> expressions can have multiple bindings, and functions can have multiple arguments. <a href='' id='Comment:Exer1' ></a></p><h2 id="mutable-state"><a href="#mutable-state"><span class="header-section-number">6.2</span> Mutable State</a></h2><p>A second common pervasive computational strategy, besides error handling, is the use of <em>mutable state</em>. Mutable state means means that the state of a program changes or mutates: that a variable can be assigned a new value or a part of a data structure can be modified. Mutable state is a pervasive feature because it is something that happens in addition to the normal computation of a value or result from a function. <a href='' id='Comment:Muta2' ></a></p><p>Here is one typical example of a program that uses mutable variables. The code is valid in C, Java or JavaScript: <a href='' id='Comment:Muta3' ></a></p><pre class="sourceCode Java"><code class="sourceCode java">x = <span class="dv">1</span>;
<span class="kw">for</span> (i = <span class="dv">2</span>; i &lt;= <span class="dv">5</span>; i = i + <span class="dv">1</span>) {
  x = x * i;
}
<a href='' id='Comment:Muta4' ></a></code></pre><p>It declares a local variable named <code>x</code> with initial value <code>1</code> and then performs an iteration where the variable <code>i</code> changes from 1 to 10. On each iteration of the loop the variable <code>x</code> is multiplied by <code>i</code>. The result of <code>x</code> a the end is the factorial of 5, namely 120. <a href='' id='Comment:Muta5' ></a></p><p>Another typical example of mutable state is modification of data structures. The following code, written in JavaScript, creates a circular data structure <a href='' id='Comment:Muta6' ></a></p><pre class="sourceCode Java"><code class="sourceCode java">record = { first: <span class="dv">2</span>, next: <span class="kw">null</span> };
record.<span class="fu">next</span> = record;
<a href='' id='Comment:Muta7' ></a></code></pre><p>Roughly equivalent code could be implemented in C or Java (or any other imperative language), although the resulting code is usually somewhat longer. <a href='' id='Comment:Muta8' ></a></p><p>It would be easy to recode the factorial example above as a pure functional program. With more work it may be possible to encoding the circular data structure as well. But the point of this book is not to teach you how to do functional programming. The point is to explain programming languages, and to code the explanation explicitly as an evaluator. Since many programming languages allow mutable values, it is important to be able to explain mutation. But we cannot <em>use</em> mutation to provide the explanation, because we have chosen to write the evaluator in Haskell, a pure functional language. The hope is that detailed and explicit analysis of how mutation works in programming languages will lead to insights about the costs and benefits of using mutation. The code for this section is in the <a href="./code/Stateful.hs.htm">Mutable State</a> file. <a href='' id='Comment:Muta9' ></a></p><h3 id="addresses"><a href="#addresses"><span class="header-section-number">6.2.1</span> Addresses</a></h3><p>Imperative languages typically allow everything to be mutable by default: all variables and mutable and all data structures are mutable. While this is often convenient, it has the disadvantage that there is no way to turn off mutation. Many variables and data structures, even in imperative languages, are logically immutable. Even when the programmer <em>intends</em> for the variables or data structure to be constant and unchanging, there is no way in most imperative languages for the programmer to make this intention explicit. <a href='' id='Comment:Addr2' ></a></p><p>To rectify this situation, at the cost of being somewhat unconventional, this book takes a different approach to mutable state, where mutability must be explicitly declared. Variables are not mutable by default. Instead a new kind of value, an <em>address</em>, is introduced to support mutation. An address identifies a mutable container that stores a single value, but whose contents can change over time. The storage identified by an address is sometimes called a <em>cell</em>. You can think of it as a <em>box</em> that contains a value. Addresses are sometimes called <em>locations</em>. (Note that the concept of an address of a mutable container is also used in ML and BLISS for mutable values, where they are known as <code>ref</code> values. This is also closely related to the concept of an address of a memory cell, as it appears in assembly language or C). <a href='' id='Comment:Addr3' ></a></p><p>There are three fundamental operations involving addresses: creating a new cell with an initial value and a new address, accessing the current value at a address, and changing the value stored at an address. The following table gives the concrete syntax of these operations. <a href='' id='Comment:Addr4' ></a></p><table><thead><tr class="header"><th align="left">Operation</th><th align="left">Meaning</th></tr></thead><tbody><tr class="odd"><td align="left"><code>Mutable(e)</code></td><td align="left">Creates a mutable cell with initial value given by <code>e</code></td></tr><tr class="even"><td align="left"><code>@a</code></td><td align="left">Accesses the contents stored at address <code>a</code></td></tr><tr class="odd"><td align="left"><code>a := e</code></td><td align="left">Updates the contents at address <code>a</code> to be value of expression <code>e</code> <a href='' id='Comment:Addr5' ></a></td></tr></tbody></table><p>Using these operations, the factorial program given above can be expressed as follows, using mutable cells: <a href='' id='Comment:Addr6' ></a></p><pre class="sourceCode Java"><code class="sourceCode java">x = <span class="fu">Mutable</span>(<span class="dv">1</span>);
<span class="kw">for</span> (i = <span class="fu">Mutable</span>(<span class="dv">2</span>); <span class="fu">@i</span> &lt;= <span class="dv">5</span>; i := <span class="fu">@i</span> + <span class="dv">1</span>) {
  x := <span class="fu">@x</span> * <span class="fu">@i</span>;
}
<a href='' id='Comment:Addr7' ></a></code></pre><p>In this model a variable always denotes the address to which it is bound. If the variable <code>x</code> appears on the right side of an assignment, it must be <em>dereferenced</em> as <code>@x</code>. If the variable appears on the left side of an assignment, it denotes an address that is updated. <a href='' id='Comment:Addr8' ></a></p><p>It should be clear that the <em>variables</em> don’t actually change in this model. The variables are bound to an address, and this binding does not change. What changes is the value stored at an address. This interpretation resembles the computational model underlying C, where address identify memory cells. (TODO: make more careful comparison to C, with attention to <em>l-values</em> and <em>r-values</em>) <a href='' id='Comment:Addr9' ></a></p><p>An address is a new kind of value. Although addresses can be represented by any unique set of labels, one convenient representation for addresses is as integers. Using integers as addresses is also similar to the use of integers for addresses in a computer memory. <a href='' id='Comment:Addr10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">IntV</span>  <span class="dt">Int</span>
           <span class="fu">|</span> <span class="dt">BoolV</span> <span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">ClosureV</span> <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Env</span>
           <span class="fu">|</span> <span class="dt">AddressV</span> <span class="dt">Int</span>        <span class="co">-- new</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="co">-- <a href='' id='Comment:Addr11' ></a></span></code></pre><p>When writing programs and values, it is useful to distinguish addresses from ordinary integer values. As a convention, addresses will be tagged with a “pound sign”, so that <code>Address 3</code> will be written #3. <a href='' id='Comment:Addr12' ></a></p><p>Another advantage of explicit cells for mutability is that the treatment of local variables given in previous chapters is still valid. Variables are still immutably bound to values. By introducing a new kind of value, namely addresses, it is possible to bind a variable to an address. It is the content stored at an address that changes, not the variable. (reminds me of the line of The Matrix: “it is not the spoon that bends…”) Introducing cells and addresses does not fundamentally change the nature or capabilities of imperative languages, it just modifies how the imperative features are expressed. <a href='' id='Comment:Addr13' ></a></p><h4 id="memory"><a href="#memory"><span class="header-section-number">6.2.1.1</span> Memory</a></h4><p>The current value of all mutable cells used in a program is called <em>memory</em>. Logically, a memory is a map or association of addresses to values. The same techniques used for environments could be used for memories, as a list of pairs or a function. Memory can also be represented as a function mapping integers to values, similar to the <a href="#EnvAsFun">representation of environments as functions</a>. <a href='' id='Comment:Memo2' ></a> Note that a memory is also sometimes called a <em>store</em>, based on the idea that is provides a form of <em>storage</em>. <a href='' id='Comment:Memo12' ></a></p><p>Since addresses are integers, one natural representation is as a list or array of values, where the address is the position or index of the value. Such an array is directly analogous to the memory of a computer system, which can be thought of as an array of 8 bit values. In this chapter memory will be implemented as a list of values, although many other representations are certainly possible. <a href='' id='Comment:Memo3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Memory</span> <span class="fu">=</span> [<span class="dt">Value</span>]
<span class="co">-- <a href='' id='Comment:Memo4' ></a></span></code></pre><p>One complication is that the memory must be able to <em>grow</em> by adding new addresses. The initial empty memory is the empty list <code>[]</code>. The first address added is zero [#0]. The next address is one to create a memory [#0, #1]. In general a memory with <span class="math">\(n\)</span> cells will have addresses [#0, #1, …, #<span class="math">\(n-1\)</span>]. Here is an example memory, with two addresses: <a href='' id='Comment:Memo5' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">[<span class="dt">IntV</span> <span class="dv">120</span>, <span class="dt">IntV</span> <span class="dv">6</span>]
<span class="co">-- <a href='' id='Comment:Memo6' ></a></span></code></pre><p>This memory has value 120 at address #0 and value 6 at address #1. More concisely, this memory can be written as <a href='' id='Comment:Memo7' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">[<span class="dv">120</span>, <span class="dv">6</span>]
<span class="co">-- <a href='' id='Comment:Memo8' ></a></span></code></pre><p>This memory could be the result of executing the factorial program given above, under the assumption that <code>x</code> is bound to address 0 and <code>i</code> is bound to address #1. An appropriate environment is: <a href='' id='Comment:Memo9' ></a></p><p>[<code>x</code> <span class="math">\(\mapsto\)</span> #0, <code>i</code> <span class="math">\(\mapsto\)</span> #1] <a href='' id='Comment:Memo10' ></a></p><p>During the execution of the program that computes the factorial of 5, there are 10 different memory configurations that are created: <a href='' id='Comment:Memo11' ></a></p><table><thead><tr class="header"><th align="left">Step</th><th align="left">Memory</th></tr></thead><tbody><tr class="odd"><td align="left"><em>start</em></td><td align="left"><span class="math">\([]\)</span></td></tr><tr class="even"><td align="left"><code>x = Mutable(1);</code></td><td align="left"><span class="math">\([1]\)</span></td></tr><tr class="odd"><td align="left"><code>i = Mutable(2);</code></td><td align="left"><span class="math">\([1, 2]\)</span></td></tr><tr class="even"><td align="left"><code>x = @x * @i;</code></td><td align="left"><span class="math">\([2, 2]\)</span></td></tr><tr class="odd"><td align="left"><code>i = @i + 1;</code></td><td align="left"><span class="math">\([2, 3]\)</span></td></tr><tr class="even"><td align="left"><code>x = @x * @i;</code></td><td align="left"><span class="math">\([6, 3]\)</span></td></tr><tr class="odd"><td align="left"><code>i = @i + 1;</code></td><td align="left"><span class="math">\([6, 4]\)</span></td></tr><tr class="even"><td align="left"><code>x = @x * @i;</code></td><td align="left"><span class="math">\([24, 4]\)</span></td></tr><tr class="odd"><td align="left"><code>i = @i + 1;</code></td><td align="left"><span class="math">\([24, 5]\)</span></td></tr><tr class="even"><td align="left"><code>x = @x * @i;</code></td><td align="left"><span class="math">\([120, 5]\)</span></td></tr><tr class="odd"><td align="left"><code>i = @i + 1;</code></td><td align="left"><span class="math">\([120, 6]\)</span> <a href='' id='Comment:Memo1' ></a></td></tr></tbody></table><h3 id="pure-functional-operations-on-memory"><a href="#pure-functional-operations-on-memory"><span class="header-section-number">6.2.2</span> Pure Functional Operations on Memory</a></h3><p>The two fundamental operations on memory are memory <em>access</em>, which looks up the contents of a memory cell, and <em>update</em>, which modifies the contents of a memory cell. <a href='' id='Comment:Pure2' ></a></p><h4 id="access"><a href="#access"><span class="header-section-number">6.2.2.1</span> Access</a></h4><p>The memory <code>access</code> function takes a memory address <span class="math">\(i\)</span> and a memory (list) and returns the item of the list at position <span class="math">\(i\)</span> counting from the left and starting at 0. The Haskell function <code>!!</code> returns the <span class="math">\(n\)</span>th item of a list, so it is exactly what we need: <a href='' id='Comment:Acce2' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">access i mem <span class="fu">=</span> mem <span class="fu">!!</span> i
<span class="co">-- <a href='' id='Comment:Acce3' ></a></span></code></pre><p>TODO: rename “access” to be “contents”? <a href='' id='Comment:Acce1' ></a></p><h4 id="update"><a href="#update"><span class="header-section-number">6.2.2.2</span> Update</a></h4><p>It is not possible to actually <em>change</em> memory in pure functional languages, including Haskell, because there is no way to modify a data structure after is has been constructed. But it is possible to compute a new data structure that is based on an existing one. This is the notion of <em>functional update</em> or <em>functional change</em>: a function can act as a transformation of a value into a new value. A functional update to memory is a function of type <code>Memory -&gt; Memory</code> Such functions take a memory as input and create a <em>new</em> memory as an output. The new memory is typically nearly identical to the input memory, but with a small change. <a href='' id='Comment:Upda2' ></a></p><p>For example, the <code>update</code> operator on memory replaces the contents of a single address with a new value. <a href='' id='Comment:Upda3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">update ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Memory</span> <span class="ot">-&gt;</span> <span class="dt">Memory</span>
update addr val mem <span class="fu">=</span>
  <span class="kw">let</span> (before, _<span class="fu">:</span>after) <span class="fu">=</span> splitAt addr mem <span class="kw">in</span>
    before <span class="fu">++</span> [val] <span class="fu">++</span> after
<span class="co">-- <a href='' id='Comment:Upda4' ></a></span></code></pre><p>The <code>update</code> function works by splitting the memory into the part before the address and the part starting with the address <code>addr</code>. The pattern <span class="math">\(_:after\)</span> binds <span class="math">\(after\)</span> to be the memory after the address. The <code>update</code> function then recreates a new memory containing the before part, the updated memory cell, and the after part. The function is inefficient because it has to copy all the memory cells it has scanned up to that point! We are not worried about efficiency, however, so just relax. It is fast enough. <a href='' id='Comment:Upda5' ></a></p><p>Using <code>access</code> and <code>update</code> it is possible to define interesting <em>transformations</em> on memory. For example, the function <code>mul10</code> multiplies the contents of a memory address by 10: <a href='' id='Comment:Upda6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">mul10 addr mem <span class="fu">=</span>
  <span class="kw">let</span> <span class="dt">IntV</span> n <span class="fu">=</span> access addr mem <span class="kw">in</span>
    update addr (<span class="dt">IntV</span> (<span class="dv">10</span> <span class="fu">*</span> n)) mem
<span class="co">-- <a href='' id='Comment:Upda7' ></a></span></code></pre><p>Here is an example calling <code>mul10</code> on a memory with 4 cells: <a href='' id='Comment:Upda8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">mul10 <span class="dv">1</span> [<span class="dt">IntV</span> <span class="dv">3</span>, <span class="dt">IntV</span> <span class="dv">4</span>, <span class="dt">IntV</span> <span class="dv">5</span>, <span class="dt">IntV</span> <span class="dv">6</span>]
<span class="co">-- <a href='' id='Comment:Upda9' ></a></span></code></pre><p>The result is <a href='' id='Comment:Upda10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">[<span class="dt">IntV</span> <span class="dv">3</span>,<span class="dt">IntV</span> <span class="dv">40</span>,<span class="dt">IntV</span> <span class="dv">5</span>,<span class="dt">IntV</span> <span class="dv">6</span>]
<span class="co">-- <a href='' id='Comment:Upda11' ></a></span></code></pre><p>The fact that <code>mul10</code> is a transformation on memory is evident from its type: <a href='' id='Comment:Upda12' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">mul10 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Memory</span> <span class="ot">-&gt;</span> <span class="dt">Memory</span>
<span class="co">-- <a href='' id='Comment:Upda13' ></a></span></code></pre><p>This means that <code>mul10</code> takes an memory address as an input and returns a function that transforms an input memory into an output memory. <a href='' id='Comment:Upda14' ></a></p><h3 id="Stateful"><a href="#Stateful"><span class="header-section-number">6.2.3</span> Stateful Computations</a></h3><p>A stateful computation is one that produces a value and <em>also</em> accesses and potentially updates memory. In changing <code>evaluate</code> to be a stateful computation, the type must change. Currently <code>evaluate</code> takes an expression and an environment and returns a value: <a href='' id='Comment:Stat1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
<span class="co">-- <a href='' id='Comment:Stat2' ></a></span></code></pre><p>Now that an expression can access memory, the current memory must be an input to the evaluation process: <a href='' id='Comment:Stat3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Memory</span> <span class="ot">-&gt;</span> <span class="fu">...</span>
<span class="co">-- <a href='' id='Comment:Stat4' ></a></span></code></pre><p>The evaluator still produces a value, but it may also return a new modified memory. These two requirements, to return a value and a memory, can be achieved by returning a <em>pair</em> of a value and a new memory: <a href='' id='Comment:Stat5' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Memory</span> <span class="ot">-&gt;</span> (<span class="dt">Value</span>, <span class="dt">Memory</span>)
<span class="co">-- <a href='' id='Comment:Stat6' ></a></span></code></pre><p>This final type is the type of a <em>stateful</em> computation. Since it is useful to talk about, we will give it a name: <a href='' id='Comment:Stat7' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Stateful</span> t <span class="fu">=</span> <span class="dt">Memory</span> <span class="ot">-&gt;</span> (<span class="dt">Value</span>, <span class="dt">Memory</span>)
<span class="co">-- <a href='' id='Comment:Stat8' ></a></span></code></pre><p>This is a <em>generic</em> type for a memory-based computation which returns a value of type <code>t</code>. Just as in the case of errors, it is useful to give a visual form to the shape of a stateful computation: <a href='' id='Comment:Stat9' ></a></p><p><embed src="figures/StatefulShape.png" /> <a href='' id='Comment:Err11' ></a></p><p>Thus the final type for <code>evaluate</code> is written concisely as: <a href='' id='Comment:Stat10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Stateful</span> <span class="dt">Value</span>
<span class="co">-- <a href='' id='Comment:Stat11' ></a></span></code></pre><p>This type is very similar to the type given for <code>evaluate</code> in the error section, where <code>Checked</code> was used in place of <code>Stateful</code>. This similarity is not an accident, as we will see in a later chapter. <a href='' id='Comment:Stat12' ></a></p><h3 id="semantics-of-a-language-with-mutation"><a href="#semantics-of-a-language-with-mutation"><span class="header-section-number">6.2.4</span> Semantics of a Language with Mutation</a></h3><p>The first step in creating a function with mutable cells is to add abstract syntax for the three operations on mutable cells. The following table defines the abstract syntax: <a href='' id='Comment:Sema15' ></a></p><table><thead><tr class="header"><th align="left">Operation</th><th align="left">Abstract Syntax</th><th align="left">Meaning</th></tr></thead><tbody><tr class="odd"><td align="left"><code>Mutable(e)</code></td><td align="left"><code>Mutable e</code></td><td align="left">Allocate memory</td></tr><tr class="even"><td align="left"><code>@a</code></td><td align="left"><code>Access a</code></td><td align="left">Accesses memory</td></tr><tr class="odd"><td align="left"><code>a := e</code></td><td align="left"><code>Assign a e</code></td><td align="left">Updates memory <a href='' id='Comment:Sema16' ></a></td></tr></tbody></table><p>The abstract syntax is added to the data type representing expressions in our language: <a href='' id='Comment:Sema17' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">...</span>
         <span class="fu">|</span> <span class="dt">Mutable</span>   <span class="dt">Exp</span>         <span class="co">-- new</span>
         <span class="fu">|</span> <span class="dt">Access</span>    <span class="dt">Exp</span>         <span class="co">-- new</span>
         <span class="fu">|</span> <span class="dt">Assign</span>    <span class="dt">Exp</span> <span class="dt">Exp</span>   <span class="co">-- new</span>
<span class="co">-- <a href='' id='Comment:Sema18' ></a></span></code></pre><p>The <code>Mutable(e)</code> expression creates a new memory cell and returns its address. First the expression <code>e</code> is evaluated to get the initial value of the new memory cell. Evaluating <code>e</code> may modify memory, so care must be taken to allocate the new cell in the new memory. The address of the new memory cell is just the length of the memory. <a href='' id='Comment:Sema1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Mutable</span> e) env mem <span class="fu">=</span>
  <span class="kw">let</span> (ev, mem&#39;) <span class="fu">=</span> evaluate e env mem <span class="kw">in</span>
    (<span class="dt">AddressV</span> (length mem&#39;), mem&#39; <span class="fu">++</span> [ev])
<span class="co">-- <a href='' id='Comment:Sema20' ></a></span></code></pre><p>The access expression <code>@a</code> expression evaluates the address expression <code>a</code> to get an address, then returns the contents of the memory at that address. Note that if the <code>Address i</code> pattern fails, Haskell raises an error. This is another case where error handling, as in the previous section, could be used. <a href='' id='Comment:Sema19' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Access</span> a) env mem <span class="fu">=</span>
  <span class="kw">let</span> (<span class="dt">AddressV</span> i, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
      (access i mem&#39;, mem&#39;)
<span class="co">-- <a href='' id='Comment:Sema23' ></a></span></code></pre><p>An assignment statement <code>a := e</code> first evaluates the target expression <code>a</code> to get an address. It is an error if <code>a</code> does not evaluate to an address. Then the source expression <code>e</code> is evaluated. Evaluating <code>a</code> and <code>e</code> may update the memory, so <a href='' id='Comment:Sema21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Assign</span> a e) env mem <span class="fu">=</span>
  <span class="kw">let</span> (<span class="dt">AddressV</span> i, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
    <span class="kw">let</span> (ev, mem&#39;&#39;) <span class="fu">=</span> evaluate e env mem&#39; <span class="kw">in</span>
      (ev, update i ev mem&#39;&#39;)
<span class="co">-- <a href='' id='Comment:Sema25' ></a></span></code></pre><h4 id="mutable-state-with-multiple-sub-expressions"><a href="#mutable-state-with-multiple-sub-expressions"><span class="header-section-number">6.2.4.1</span> Mutable State with Multiple Sub-expressions</a></h4><p>The interesting thing is that even parts of the evaluator that have nothing to do with mutable cells have to be completely rewritten: <a href='' id='Comment:Sema26' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Binary</span> op a b) env mem <span class="fu">=</span>
  <span class="kw">let</span> (av, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
    <span class="kw">let</span> (bv, mem&#39;&#39;) <span class="fu">=</span> evaluate b env mem&#39; <span class="kw">in</span>
      (binary op av bv, mem&#39;&#39;)
<span class="co">-- <a href='' id='Comment:Sema27' ></a></span></code></pre><p>This form of composition is illustrated in the following diagram: <a href='' id='Comment:Muta1' ></a></p><p><embed src="figures/StatefulBind.png" /> <a href='' id='Comment:Muta10' ></a></p><p>The memory input of the combined expression is passed to <code>A</code>. The value out and the memory output of <code>A</code> are given as inputs to <code>B</code>. The final result of the composition is the value of <code>B</code> and the memory that results from <code>B</code>. Note that the shape of the overall composition (the thick box) is the same as the shape of the basic stateful computations. <a href='' id='Comment:Muta11' ></a></p><p>Similar transformations are needed for <code>Unary</code> operations and function definitions/calls. <a href='' id='Comment:Muta12' ></a></p><p>Most languages with mutable state also have <em>sequences</em> of expressions, of the form <code>e1; e2; ...; eN</code>. It would be relatively easy to add a semicolon operator to the binary operators. In fact, C has such an operator: the expression <code>e1, e2</code> evaluates <code>e1</code> and then evaluates <code>e2</code>. The result of the expression is the value of <code>e2</code>. The value of <code>e1</code> is discarded. Note that <code>let</code> can also be used to implement sequences of operations: <code>e1; e2</code> can be represented as <code>let dummy = e1 in e2</code> where <code>dummy</code> is a variable that is not used anywhere in the program. <a href='' id='Comment:Muta13' ></a></p><h3 id="summary-of-mutable-state"><a href="#summary-of-mutable-state"><span class="header-section-number">6.2.5</span> Summary of Mutable State</a></h3><p>Again, the take-away should be that mutation is messy when programmed in this way. Mutation affects every part of the evaluation process, even for parts that are not involved with creating or manipulating mutable cells. <a href='' id='Comment:Summ5' ></a></p><p>Here is the complete code for mutable cells. <a href='' id='Comment:Summ6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Literal</span>   <span class="dt">Value</span>
         <span class="fu">|</span> <span class="dt">Unary</span>     <span class="dt">UnaryOp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Binary</span>    <span class="dt">BinaryOp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">If</span>        <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Variable</span>  <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">Let</span>       <span class="dt">String</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Function</span>  <span class="dt">String</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Call</span>      <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Mutable</span>   <span class="dt">Exp</span>         <span class="co">-- new</span>
         <span class="fu">|</span> <span class="dt">Access</span>    <span class="dt">Exp</span>         <span class="co">-- new</span>
         <span class="fu">|</span> <span class="dt">Assign</span>    <span class="dt">Exp</span> <span class="dt">Exp</span>   <span class="co">-- new</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
  
<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Value</span>)]
<span class="co">-- <a href='' id='Comment:Summ7' ></a></span></code></pre><p>All the existing cases of the evaluator are modified: <a href='' id='Comment:Summ8' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Stateful</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env mem    <span class="fu">=</span> (v, mem)

evaluate (<span class="dt">Unary</span> op a) env mem   <span class="fu">=</span>
  <span class="kw">let</span> (av, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
    (unary op av, mem&#39;)

evaluate (<span class="dt">Binary</span> op a b) env mem <span class="fu">=</span>
  <span class="kw">let</span> (av, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
    <span class="kw">let</span> (bv, mem&#39;&#39;) <span class="fu">=</span> evaluate b env mem&#39; <span class="kw">in</span>
      (binary op av bv, mem&#39;&#39;)

evaluate (<span class="dt">If</span> a b c) env mem <span class="fu">=</span>
  <span class="kw">let</span> (<span class="dt">BoolV</span> test, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
    evaluate (<span class="kw">if</span> test <span class="kw">then</span> b <span class="kw">else</span> c) env mem&#39;

evaluate (<span class="dt">Variable</span> x) env mem <span class="fu">=</span> (fromJust (lookup x env), mem)

evaluate (<span class="dt">Let</span> x e body) env mem <span class="fu">=</span>
  <span class="kw">let</span> (ev, mem&#39;) <span class="fu">=</span> evaluate e env mem
      newEnv <span class="fu">=</span> (x, ev) <span class="fu">:</span> env
  <span class="kw">in</span>
    evaluate body newEnv mem&#39;

evaluate (<span class="dt">Function</span> x body) env mem <span class="fu">=</span> (<span class="dt">ClosureV</span> x body env, mem)

evaluate (<span class="dt">Call</span> f a) env mem  <span class="fu">=</span>
  <span class="kw">let</span> (<span class="dt">ClosureV</span> x body closeEnv, mem&#39;) <span class="fu">=</span> evaluate f env mem
      (av, mem&#39;&#39;) <span class="fu">=</span> evaluate a env mem&#39;
      newEnv <span class="fu">=</span> (x, av) <span class="fu">:</span> closeEnv
  <span class="kw">in</span>
      evaluate body newEnv mem&#39;&#39;
<span class="co">-- <a href='' id='Comment:Summ9' ></a></span></code></pre><p>Here are the mutation-specific parts of the evaluator: <a href='' id='Comment:Summ10' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Mutable</span> e) env mem <span class="fu">=</span>
  <span class="kw">let</span> (ev, mem&#39;) <span class="fu">=</span> evaluate e env mem <span class="kw">in</span>
    (<span class="dt">AddressV</span> (length mem&#39;), mem&#39; <span class="fu">++</span> [ev])

evaluate (<span class="dt">Access</span> a) env mem <span class="fu">=</span>
  <span class="kw">let</span> (<span class="dt">AddressV</span> i, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
      (access i mem&#39;, mem&#39;)

evaluate (<span class="dt">Assign</span> a e) env mem <span class="fu">=</span>
  <span class="kw">let</span> (<span class="dt">AddressV</span> i, mem&#39;) <span class="fu">=</span> evaluate a env mem <span class="kw">in</span>
    <span class="kw">let</span> (ev, mem&#39;&#39;) <span class="fu">=</span> evaluate e env mem&#39; <span class="kw">in</span>
      (ev, update i ev mem&#39;&#39;)
<span class="co">-- <a href='' id='Comment:Summ11' ></a></span></code></pre><h4 id="exercise-5.6-errors-and-mutable-state"><a href="#exercise-5.6-errors-and-mutable-state"><span class="header-section-number">6.2.5.1</span> Exercise 5.6: Errors and Mutable State</a></h4><p>Write a version of <code>evaluate</code> that supports both error checking and mutable state. <a href='' id='Comment:Exer7' ></a></p><h2 id="monads-abstract-computational-strategies"><a href="#monads-abstract-computational-strategies"><span class="header-section-number">6.3</span> Monads: Abstract Computational Strategies</a></h2><p>At first glance it does not seem there is anything that can be done about the messy coding involved in implementing errors and mutable state. These features are <em>aspects</em> of the evaluation process, because they effect all the code of the evaluator, not just the part that directly involves the new feature. <a href='' id='Comment:Abst11' ></a></p><p>What is worse is that combining the code for errors and mutable state is not possible without writing yet another completely different implementation. The <em>features</em> of our evaluator are not implemented in a modular way. <a href='' id='Comment:Abst12' ></a></p><p>The concept of a <em>monad</em> provides a framework that allows different computational strategies to be invoked in a uniform way. The rest of this section shows how to derive the monad structure from the examples of error handing and mutable state given above. The basic strategy is to compare the two examples and do whatever is necessary to force them into a common structure, by moving details into helper functions. By defining appropriate helper functions that have the same interface, the two examples can be expressed in a uniform format. <a href='' id='Comment:Mona1' ></a></p><p><img src="figures/23956strip.png" alt="Modified Dilbert Cartoon" /> <a href='' id='Comment:Mona2' ></a></p><h3 id="abstracting-simple-computations"><a href="#abstracting-simple-computations"><span class="header-section-number">6.3.1</span> Abstracting Simple Computations</a></h3><p>The first step is to examine how the two evaluators deal with simple computations that return values. Here are the cases for Consider the way that the <code>Literal</code> expression is evaluated for both the Checked and the Stateful evaluators. <a href='' id='Comment:Abst13' ></a></p><table><thead><tr class="header"><th align="left">Checked</th><th align="left">     </th><th align="left">Stateful</th></tr></thead><tbody><tr class="odd"><td align="left"><code>evaluate :: Exp -&gt; Env -&gt; Checked Value</code></td><td align="left"></td><td align="left"><code>evaluate :: Exp -&gt; Env -&gt; Stateful Value</code></td></tr><tr class="even"><td align="left"><code>evaluate (Literal v) env = Good v</code></td><td align="left"></td><td align="left"><code>evaluate (Literal v) env m = (v, m)</code> <a href='' id='Comment:Abst14' ></a></td></tr></tbody></table><p>One important point is that literal values never cause errors and they do not modify memory. They represent the simple good base case for a computation. In monad terminology, this operation is called <code>return</code> because it describes how to return a value from the computation. The return functions for checked and stateful computations are different, but they both have same interface: they take a value as input and output an appropriate checked or stateful value. <a href='' id='Comment:Abst18' ></a></p><table><thead><tr class="header"><th align="left">Checked</th><th align="left">     </th><th align="left">Stateful</th></tr></thead><tbody><tr class="odd"><td align="left"><code>return</code><span class="math">\(_C\)</span> <code>:: Value -&gt; Checked Value</code></td><td align="left"></td><td align="left"><code>return</code><span class="math">\(_S\)</span> <code>:: Value -&gt; Stateful Value</code></td></tr><tr class="even"><td align="left"><code>return</code><span class="math">\(_C\)</span> <code>v = Good v</code></td><td align="left"></td><td align="left"><code>return</code><span class="math">\(_S\)</span> <code>v =</code> <span class="math">\(\lambda\)</span> <code>m.(v, m)</code> <a href='' id='Comment:Abst19' ></a></td></tr></tbody></table><p>Using these return functions, the original <code>evaluate</code> code can be written so that the two cases are nearly identical. The details of how to deal with the checked or stateful values are hidden in the <code>return</code> helper functions. <a href='' id='Comment:Abst20' ></a></p><table><thead><tr class="header"><th align="left">Checked</th><th align="left">     </th><th align="left">Stateful</th></tr></thead><tbody><tr class="odd"><td align="left"><code>evaluate :: Exp -&gt; Env -&gt; Checked Value</code></td><td align="left"></td><td align="left"><code>evaluate :: Exp -&gt; Env -&gt; Stateful Value</code></td></tr><tr class="even"><td align="left"><code>evaluate (Literal v) env = return</code><span class="math">\(_C\)</span> <code>v</code></td><td align="left"></td><td align="left"><code>evaluate (Literal v) = return</code><span class="math">\(_S\)</span> <code>v</code> <a href='' id='Comment:Abst21' ></a></td></tr></tbody></table><h3 id="abstracting-computation-composition"><a href="#abstracting-computation-composition"><span class="header-section-number">6.3.2</span> Abstracting Computation Composition</a></h3><p>The next step is to unify the case when there are multiple sub-expressions that must be evaluated. The binary operator provides a good example of multiple sub-expressions. <a href='' id='Comment:Abst22' ></a></p><table><thead><tr class="header"><th align="left">Checked</th><th align="left">     </th><th align="left">Stateful</th></tr></thead><tbody><tr class="odd"><td align="left"><code>evaluate :: Exp -&gt; Env -&gt; Checked Value</code></td><td align="left"></td><td align="left"><code>evaluate :: Exp -&gt; Env -&gt; Stateful Value</code></td></tr><tr class="even"><td align="left"><code>evaluate (Binary op a b) env =</code></td><td align="left"></td><td align="left"><code>evaluate (Binary op a b) =</code></td></tr><tr class="odd"><td align="left">  <code>case evaluate a env of</code></td><td align="left"></td><td align="left">  <span class="math">\(\lambda\)</span><code>mem.let (av, mem') = evaluate a env mem in</code></td></tr><tr class="even"><td align="left">    <code>Error msg -&gt; Error msg</code></td><td align="left"></td><td align="left">             <code>let (bv, mem'') = evaluate b env mem' in</code></td></tr><tr class="odd"><td align="left">    <code>Good av -&gt;</code></td><td align="left"></td><td align="left">               <code>(Binary op av bv, mem'')</code></td></tr><tr class="even"><td align="left">      <code>case evaluate b env of</code></td><td align="left"></td><td align="left"></td></tr><tr class="odd"><td align="left">        <code>Error msg -&gt; Error msg</code></td><td align="left"></td><td align="left"></td></tr><tr class="even"><td align="left">        <code>Good bv -&gt;</code></td><td align="left"></td><td align="left"></td></tr><tr class="odd"><td align="left">          <code>checked_binary op av bv</code></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>TODO: note that the <code>mem</code> argument has become a lambda! <a href='' id='Comment:Abst36' ></a></p><p>In this case computation proceeds in steps: first evaluate one expression (checking errors and updating memory) and then evaluating the second expression (checking errors and updating memory as appropriate). They both have a similar pattern of code for dealing with the evaluation of <code>a</code> and <code>b</code>. Factoring out the common parts as <code>A</code> and <code>F</code>, the core of the pattern is: <a href='' id='Comment:Abst23' ></a></p><table><thead><tr class="header"><th align="left">Checked</th><th align="left">     </th><th align="left">Stateful</th></tr></thead><tbody><tr class="odd"><td align="left"><code>case</code> <em>first-part</em> <code>of</code></td><td align="left"></td><td align="left"><span class="math">\(\lambda\)</span><code>mem.let (v, mem') =</code> <em>first-part</em> <code>mem in</code></td></tr><tr class="even"><td align="left">  <code>Error msg -&gt; Error msg</code></td><td align="left"></td><td align="left">           <em>next-part</em> <code>v</code> <code>mem'</code></td></tr><tr class="odd"><td align="left">  <code>Good v -&gt;</code> <em>next-part</em> <code>v</code></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>This <em>first-part</em> corresponds to <code>evaluate a env</code> or <code>evaluate b env</code> in both the original versions. The <em>second-part</em> represents the remainder… just everything that appears after the main pattern, but with all the free variables made explicit. For the Checked case, the only variable needed in the <em>second-part</em> is the variable <code>v</code> that comes form the <code>Good</code> case. For the Stateful case, in addition to <code>v</code> the <em>second-part</em> also requires access to <code>mem'</code> <a href='' id='Comment:Abst24' ></a></p><p>These patterns can be made explicit as a special operator that combines the two parts, where the second part is a function with the appropriate arguments. To be more concrete, these parts are converted into explicit variables. The <em>first-part</em> is named <code>A</code> and the <em>second-part</em>, which is a function, is named <code>F</code>: <a href='' id='Comment:Abst25' ></a></p><table><thead><tr class="header"><th align="left">Checked</th><th align="left">     </th><th align="left">Stateful</th></tr></thead><tbody><tr class="odd"><td align="left"><code>A</code> <span class="math">\(\rhd_C\)</span> <code>F =</code></td><td align="left"></td><td align="left"><code>A</code> <span class="math">\(\rhd_S\)</span> <code>F =</code></td></tr><tr class="even"><td align="left">  <code>case A of</code></td><td align="left"></td><td align="left">  <span class="math">\(\lambda\)</span><code>mem.let (v, mem') = A mem in</code></td></tr><tr class="odd"><td align="left">    <code>Error msg -&gt; Error msg</code></td><td align="left"></td><td align="left">             <code>F v mem'</code></td></tr><tr class="even"><td align="left">    <code>Good v -&gt; F v</code></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>These generic operators for Checked <span class="math">\(\rhd_C\)</span> and Stateful <span class="math">\(\rhd_S\)</span> computations abstract away the core pattern composing two Checked or Stateful computations. The family of operators <span class="math">\(\rhd\)</span> are called <em>bind</em> operators, because they bind together computations. <a href='' id='Comment:Abst26' ></a></p><p>Using these operators, the <em>original</em> code can be written in simpler form: <a href='' id='Comment:Abst27' ></a></p><dl><dt>Checked: <a href='' id='Comment:Abst37' ></a></dt><dd><p>(<code>evaluate a env</code>) <span class="math">\(\rhd_C\)</span> (<span class="math">\(\lambda\)</span><code>va. (evaluate b env)</code> <span class="math">\(\rhd_C\)</span> (<span class="math">\(\lambda\)</span><code>vb. checked_binary op av bv</code>)) <a href='' id='Comment:Abst38' ></a></p></dd><dt>Stateful: <a href='' id='Comment:Abst39' ></a></dt><dd><p>(<code>evaluate a env</code>) <span class="math">\(\rhd_S\)</span> (<span class="math">\(\lambda\)</span><code>va. (evaluate b env)</code> <span class="math">\(\rhd_S\)</span> (<span class="math">\(\lambda\)</span><code>vb.</code> <span class="math">\(\lambda\)</span><code>mem.(Binary op av bv, mem)</code>)) <a href='' id='Comment:Abst28' ></a></p></dd></dl><p>All mention of <code>Error</code> and <code>Good</code> have been removed from the Checked version! The error <code>plumbing' has been hidden. Most of the memory plumbing has been removed from the Stateful version, but there is still a little at the end. But the pattern that has emerged is the same one that was identified in the previous section, where the</code>return<code>$_S$ function converts a value (the result of</code>Binary op av bv`) into a default stateful computation. To see how this works, consider that <a href='' id='Comment:Abst29' ></a></p><p><code>return</code><span class="math">\(_S\)</span> (<code>Binary op av bv</code>)     <span class="math">\(\equiv\)</span>     <span class="math">\(\lambda\)</span><code>mem. (Binary op av bv, mem)</code> <a href='' id='Comment:Abst30' ></a></p><p>Using <code>return</code><span class="math">\(_S\)</span> the result is: <a href='' id='Comment:Abst31' ></a></p><dl><dt>Checked: <a href='' id='Comment:Abst40' ></a></dt><dd><p>(<code>evaluate a env</code>) <span class="math">\(\rhd_C\)</span> (<span class="math">\(\lambda\)</span><code>va. (evaluate b env)</code> <span class="math">\(\rhd_C\)</span> (<span class="math">\(\lambda\)</span><code>vb. checked_binary op av bv</code>)) <a href='' id='Comment:Abst41' ></a></p></dd><dt>Stateful: <a href='' id='Comment:Abst42' ></a></dt><dd><p>(<code>evaluate a env</code>) <span class="math">\(\rhd_S\)</span> (<span class="math">\(\lambda\)</span><code>va. (evaluate b env)</code> <span class="math">\(\rhd_S\)</span> (<span class="math">\(\lambda\)</span><code>vb. return</code><span class="math">\(_S\)</span> (<code>Binary op av bv</code>))) <a href='' id='Comment:Abst32' ></a></p></dd></dl><p>Now all references to memory have been removed in these cases. Of course, in the evaluation rules for <code>Mutable</code>, assignment, and access there will be explicit references to memory. Similarly, in the cases where errors are generated, for example for undefined variables, the code will still have to create <code>Error</code> values. What we have done here is examine the parts of the program that <em>don’t</em> involve errors or memory, namely literals and binary operators, and figured out way to hide the complexity of error checking and mutable memory. This complexity has been hidden in two new operators, <code>return</code> and bind <span class="math">\(\rhd\)</span>. The type of the bind operators is also interesting: <a href='' id='Comment:Abst33' ></a></p><dl><dt>Checked: <a href='' id='Comment:Abst43' ></a></dt><dd><p><span class="math">\(\rhd_C\)</span> <code>:: Checked Value -&gt; (Value -&gt; Checked Value) -&gt; Checked Value</code> <a href='' id='Comment:Abst44' ></a></p></dd><dt>Stateful: <a href='' id='Comment:Abst45' ></a></dt><dd><p><span class="math">\(\rhd_S\)</span> <code>:: Stateful Value -&gt; (Value -&gt; Stateful Value) -&gt; Stateful Value</code> <a href='' id='Comment:Abst34' ></a></p></dd></dl><p>It should be clear that an consistent pattern has emerged. This is a <em>very</em> abstract pattern, which has to do with the structure of the underlying computation: is it a checked computation or a stateful computation? Other forms of computation are also possible. <a href='' id='Comment:Abst35' ></a></p><h3 id="monads-defined"><a href="#monads-defined"><span class="header-section-number">6.3.3</span> Monads Defined</a></h3><p>A <em>monad</em> <span class="math">\(m\)</span> is a computational structure that involves three parts: <a href='' id='Comment:Mona3' ></a></p><ul><li>A generic data type <span class="math">\(m\)</span> <a href='' id='Comment:Mona4' ></a></li><li>A <em>return</em> function <code>return</code><span class="math">\(_m :: t \rightarrow m\ t\)</span> <a href='' id='Comment:Mona5' ></a></li><li>A <em>bind</em> function <span class="math">\(\rhd_m :: m\ t \rightarrow (t \rightarrow m\ s) \rightarrow m\ s\)</span> <a href='' id='Comment:Mona6' ></a></li></ul><p>The symbol <span class="math">\(m\)</span> gives the name of the monad and also defines the <em>shape</em> of the computation. A program that uses the monad <span class="math">\(m\)</span> is called an <span class="math">\(m\)</span>-computation. Examples of <span class="math">\(m\)</span> in the previous section are <code>Checked</code> and <code>Stateful</code>. The instantiation of the generic type <span class="math">\(m\ t\)</span> at a particular type <span class="math">\(t\)</span> represents an <span class="math">\(m\)</span>-computation that produces a value of type <span class="math">\(t\)</span>. For example, the type <code>Checked Int</code> represents an error-checked computation that produces an <code>Int</code>. Saying that it is a “checked computation” implies that it might produce an error rather than an integer. As another example, the type <code>Stateful String</code> represents a stateful computation that produces a value of type <code>String</code>. The fact that it is a “stateful computation” implies that there is a memory which is required as input to the computation, and that it produces an updated memory in addition to the string result. <a href='' id='Comment:Mona7' ></a></p><p>The <code>return</code><span class="math">\(_m\)</span> function specifies how values are converted into <span class="math">\(m\)</span>-computations. The <code>return</code><span class="math">\(_m\)</span> function has type <span class="math">\(t \rightarrow m\ t\)</span> for any type <span class="math">\(t\)</span>. What this means is that it converts a value of type <span class="math">\(t\)</span> into an <span class="math">\(m\)</span>-computation that just returns the value. It is important that the computation <em>just</em> returns the value, so, for example, it is not legal for the stateful return function to modify memory. Examples of return were given in the previous section. <a href='' id='Comment:Mona8' ></a></p><p>The <em>bind</em> function <span class="math">\(\rhd_m\)</span> specifies how <span class="math">\(m\)</span>-computations are combined together. In general the behavior of <span class="math">\(A \rhd_m F\)</span> is to perform the <span class="math">\(m\)</span>-computation <span class="math">\(A\)</span> and then pass the value it produces to the function <span class="math">\(F\)</span> to create a second <span class="math">\(m\)</span>-computation, which is returned as the result of the bind operation. Note that the <span class="math">\(A\)</span> may not produce a value, in which case <span class="math">\(F\)</span> is not called. This happens, for example, in the <code>Checked</code> monad, if <span class="math">\(A\)</span> produces an error. At a high level, bind combines the computation <span class="math">\(A\)</span> with the (parameterized) computation <span class="math">\(F\)</span> to form a composite computation, which performs the effect of both <span class="math">\(A\)</span> and <span class="math">\(F\)</span>. <a href='' id='Comment:Mona9' ></a></p><p>The type of bind given here is slightly more general than the type of bind used in the previous examples. In the previous examples, the type was <span class="math">\(m\ t \rightarrow (t \rightarrow m\ t) \rightarrow m\ t\)</span>. However, it is possible for the return types of the two computations to differ. As long as the output of the first computation <span class="math">\(A\)</span> can be passed to <span class="math">\(F\)</span>, there is not problem. <a href='' id='Comment:Mona10' ></a></p><p>TODO: mention the monad laws. <a href='' id='Comment:Mona11' ></a></p><h2 id="monads-in-haskell"><a href="#monads-in-haskell"><span class="header-section-number">6.4</span> Monads in Haskell</a></h2><p>The concept of a monad allows pervasive computational features, e.g. error checking and mutable state, to be defined in using a high-level interface that allows hides the plumbing involved in managing errors or state. Unfortunately, the resulting programs are still somewhat cumbersome to work with. Haskell provides special support for working with monads that makes them easy to use. <a href='' id='Comment:Mona12' ></a></p><h3 id="the-monad-type-class"><a href="#the-monad-type-class"><span class="header-section-number">6.4.1</span> The Monad Type Class</a></h3><p>Haskell allow monads to be defined very cleanly using <em>type classes</em>. The <code>Monad</code> class has the following definition: <a href='' id='Comment:Monad1' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> m t <span class="ot">-&gt;</span> (t <span class="ot">-&gt;</span> m s) <span class="ot">-&gt;</span> m s
<span class="ot">  return ::</span> t <span class="ot">-&gt;</span> m t
<span class="co">-- <a href='' id='Comment:Monad2' ></a></span></code></pre><p>It say that for a generic type <code>m</code> to be a monad, it must have two functions, bind (<code>&gt;&gt;=</code>) and <code>return</code>, with the appropriate types. The only difference from the definition given above is that the bind operator is called <code>&gt;&gt;=</code> rather than <span class="math">\(\rhd\)</span>. <a href='' id='Comment:Monad3' ></a></p><p>The type <code>Checked</code> is an instance of the <code>Monad</code> class: <a href='' id='Comment:Monad4' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Checked</span> <span class="kw">where</span>
  return v <span class="fu">=</span> <span class="dt">Good</span> v
  a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span>
    <span class="kw">case</span> a <span class="kw">of</span>
      <span class="dt">Error</span> msg <span class="ot">-&gt;</span> <span class="dt">Error</span> msg
      <span class="dt">Good</span> v    <span class="ot">-&gt;</span> f v
<span class="co">-- <a href='' id='Comment:Monad5' ></a></span></code></pre><p>It turns out to be a little more complex to define the stateful monad instance, so this topic is delayed until the end of this section. The code for error checking using monads is give in the <a href="./code/CheckedMonad.hs.htm">Checked Monad</a> file. <a href='' id='Comment:Monad6' ></a></p><h3 id="haskell-do-notation"><a href="#haskell-do-notation"><span class="header-section-number">6.4.2</span> Haskell <code>do</code> Notation</a></h3><p>Haskell also supports special syntax for writing programs that use monads, which simplifies the use of the bind operator. The problem with the monadic version of the program is apparent in the code for evaluation of binary expressions. The code given above is ugly because of the nested use of lambda functions. Here an attempt to make the Checked case more readable: <a href='' id='Comment:Hask1' ></a></p><p><code>evaluate (Binary op a b) env =</code><br /> <code>(evaluate a env)</code> <span class="math">\(\rhd_C\)</span> (<span class="math">\(\lambda\)</span><code>va.</code><br />  <code>(evaluate b env)</code> <span class="math">\(\rhd_C\)</span> (<span class="math">\(\lambda\)</span><code>vb.</code><br />   <code>checked_binary op av bv</code>))</p><p>The effect here is for <code>av</code> to be bound to the value produced by the <code>evaluate a env</code>, and for <code>bv</code> to be bound to the result of <code>evaluate b env</code>. Unfortunately, the variables come <em>to the right</em> of the expression that produces the value, which is not the way we naturally think about binding. Also, the nested lambdas and parenthesis are distracting. <a href='' id='Comment:Hask2' ></a></p><p>Haskell has a special notation, the <code>do</code> notations, for the bind operator that allows the variables to be written in the right order. Using <code>do</code> the program above can be written as follows: <a href='' id='Comment:Hask3' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">evaluate (<span class="dt">Binary</span> op a b) env <span class="fu">=</span> <span class="kw">do</span>
  av <span class="ot">&lt;-</span> evaluate a env
  bv <span class="ot">&lt;-</span> evaluate b env
  checked_binary op av bv
<span class="co">-- <a href='' id='Comment:Hask4' ></a></span></code></pre><p>Here is the basic pattern for <code>do</code> notation: <a href='' id='Comment:Hask6' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">do</span>
  x <span class="ot">&lt;-</span> e1
  e2
<span class="co">-- <a href='' id='Comment:Hask7' ></a></span></code></pre><p>This is equivalent to this form, using bind: <a href='' id='Comment:Hask8' ></a></p><p><code>e1 &gt;&gt;=</code>(<span class="math">\(\lambda\)</span><code>x.e2)</code> <a href='' id='Comment:Hask9' ></a></p><p>The expressions <code>e1</code> and <code>e2</code> must be expressions that produce values in the same monad <code>m</code>. To be precise, if <code>e1</code> has type <code>m</code> <span class="math">\(t_1\)</span> where <code>m</code> is a data type declared as an instance of <code>Monad</code>, then the variable <code>x</code> will be assigned a value of type <span class="math">\(t_1\)</span>. Then <code>e2</code> must have type <code>m</code> <span class="math">\(t_2\)</span> for some type <span class="math">\(t_2\)</span>. Note that the <code>&lt;-</code> symbol must be understood differently from <code>=</code>. What is means is that <code>x</code> is bound to the simple value produced by the computation <code>e1</code>. The <code>&lt;-</code> is there to remind you that <code>x</code> is not bound directly to the monadic computation produced by <code>e1</code>, but is bound to the value that the computation generates. <a href='' id='Comment:Hask10' ></a></p><p>For a concrete example, if <code>m</code> is <code>Checked</code> then <code>e1</code> must have type <code>Checked t1</code> for some type <code>t1</code>. The value of expressions <code>e1</code>, which is a <code>Checked t1</code>, could be a good value or an error. If <code>e1</code> produces an error then the compututation stops, <code>x</code> is never bound to any value, and <code>e2</code> is not called. But if <code>e1</code> produces a good value <code>v</code>, then <code>x</code> will be bound to <code>v</code> (which is the value that was labeled <code>Good</code>) and the computation will proceed with <code>e2</code>. <a href='' id='Comment:Hask11' ></a></p><p>One benefit of the <code>do</code> notation is that the bind operator is implicit. Haskell type inference and the type class system arrange for the right bind operator to be selected automatically. <a href='' id='Comment:Hask5' ></a></p><p>TODO: mention <code>let</code> in <code>do</code>, and the case where no variable is used. <a href='' id='Comment:Hask12' ></a></p><h2 id="using-haskell-monads"><a href="#using-haskell-monads"><span class="header-section-number">6.5</span> Using Haskell Monads</a></h2><p>The messy evaluators for error checking and mutable state can be rewritten much more cleanly using monads. <a href='' id='Comment:Usin25' ></a></p><h3 id="monadic-error-checking"><a href="#monadic-error-checking"><span class="header-section-number">6.5.1</span> Monadic Error Checking</a></h3><p>Here is a version of error checking using the <code>Checked</code> monad defined above: <a href='' id='Comment:Mona14' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Checked</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env     <span class="fu">=</span> return v
evaluate (<span class="dt">Variable</span> x) env    <span class="fu">=</span>
  <span class="kw">case</span> lookup x env <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="st">&quot;Variable &quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot; undefined&quot;</span>)
    <span class="dt">Just</span> v  <span class="ot">-&gt;</span> return v
evaluate (<span class="dt">Unary</span> op a) env <span class="fu">=</span> <span class="kw">do</span>
  av <span class="ot">&lt;-</span> evaluate a env
  checked_unary op av
evaluate (<span class="dt">Binary</span> op a b) env <span class="fu">=</span> <span class="kw">do</span>
  av <span class="ot">&lt;-</span> evaluate a env
  bv <span class="ot">&lt;-</span> evaluate b env
  checked_binary op av bv
evaluate (<span class="dt">If</span> a b c) env <span class="fu">=</span> <span class="kw">do</span>
  av <span class="ot">&lt;-</span> evaluate a env
  <span class="kw">case</span> av <span class="kw">of</span>
    (<span class="dt">BoolV</span> cond) <span class="ot">-&gt;</span> evaluate (<span class="kw">if</span> cond <span class="kw">then</span> b <span class="kw">else</span> c) env
    _ <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="st">&quot;Expected boolean but found &quot;</span> <span class="fu">++</span> show av)
evaluate (<span class="dt">Let</span> x e body) env <span class="fu">=</span> <span class="kw">do</span>    <span class="co">-- non-recursive case</span>
  ev <span class="ot">&lt;-</span> evaluate e env
  <span class="kw">let</span> newEnv <span class="fu">=</span> (x, ev) <span class="fu">:</span> env
  evaluate body newEnv
evaluate (<span class="dt">Function</span> x body) env <span class="fu">=</span> return (<span class="dt">ClosureV</span> x body env)
evaluate (<span class="dt">Call</span> fun arg) env <span class="fu">=</span> <span class="kw">do</span>
  funv <span class="ot">&lt;-</span> evaluate fun env
  <span class="kw">case</span> funv <span class="kw">of</span>
    <span class="dt">ClosureV</span> x body closeEnv <span class="ot">-&gt;</span> <span class="kw">do</span>
      argv <span class="ot">&lt;-</span> evaluate arg env
      <span class="kw">let</span> newEnv <span class="fu">=</span> (x, argv) <span class="fu">:</span> closeEnv
      evaluate body newEnv
    _ <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="st">&quot;Expected function but found &quot;</span> <span class="fu">++</span> show funv)
<span class="co">-- <a href='' id='Comment:Mona13' ></a></span></code></pre><h3 id="monadic-mutable-state"><a href="#monadic-mutable-state"><span class="header-section-number">6.5.2</span> Monadic Mutable State</a></h3><p>The full code for the stateful evaluator using monads is give in the <a href="./code/StatefulMonad.hs.htm">Stateful Monad</a> file. <a href='' id='Comment:Mona15' ></a></p><p>The main complexity in defining a stateful monad is that monads in Haskell can only be defined for <code>data</code> types, which have explicit constructor labels. It is not possible to define a monad instance for the stateful type given in the <a href="#Stateful">Section on Stateful Computations</a>, since it is a pure function type: <a href='' id='Comment:Mona16' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Stateful</span> t <span class="fu">=</span> <span class="dt">Memory</span> <span class="ot">-&gt;</span> (<span class="dt">Value</span>, <span class="dt">Memory</span>)
<span class="co">-- <a href='' id='Comment:Stat8' ></a></span></code></pre><p>To define a monad, Haskell requires a <em>data</em> type that labels the function: <a href='' id='Comment:Mona18' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Stateful</span> t <span class="fu">=</span> <span class="dt">ST</span> (<span class="dt">Memory</span> <span class="ot">-&gt;</span> (t, <span class="dt">Memory</span>))
<span class="co">-- <a href='' id='Comment:StatefulMonad1' ></a></span></code></pre><p>The data type is isomorphic to the function type, because it is just a type with a label. <a href='' id='Comment:Mona19' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Stateful</span> <span class="kw">where</span>
  return val <span class="fu">=</span> <span class="dt">ST</span> (\m <span class="ot">-&gt;</span> (val, m))
  (<span class="dt">ST</span> c) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> 
    <span class="dt">ST</span> (\m <span class="ot">-&gt;</span> 
      <span class="kw">let</span> (val, m&#39;) <span class="fu">=</span> c m
          <span class="dt">ST</span> f&#39; <span class="fu">=</span> f val
      <span class="kw">in</span> f&#39; m&#39;)
<span class="co">-- <a href='' id='Comment:StatefulMonad2' ></a></span></code></pre><p>Here is a version of evaluator using the <code>Stateful</code> monad defined above: <a href='' id='Comment:Mona21' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Stateful</span> <span class="dt">Value</span>
evaluate (<span class="dt">Literal</span> v) env <span class="fu">=</span> return v
evaluate (<span class="dt">Unary</span> op a) env <span class="fu">=</span> <span class="kw">do</span>
  av <span class="ot">&lt;-</span> evaluate a env
  return (unary op av)
evaluate (<span class="dt">Binary</span> op a b) env <span class="fu">=</span> <span class="kw">do</span>
  av <span class="ot">&lt;-</span> evaluate a env
  bv <span class="ot">&lt;-</span> evaluate b env
  return (binary op av bv)
evaluate (<span class="dt">If</span> a b c) env <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">BoolV</span> cond <span class="ot">&lt;-</span> evaluate a env
  evaluate (<span class="kw">if</span> cond <span class="kw">then</span> b <span class="kw">else</span> c) env
evaluate (<span class="dt">Let</span> x e body) env <span class="fu">=</span> <span class="kw">do</span>    <span class="co">-- non-recursive case</span>
  ev <span class="ot">&lt;-</span> evaluate e env
  <span class="kw">let</span> newEnv <span class="fu">=</span> (x, ev) <span class="fu">:</span> env
  evaluate body newEnv
evaluate (<span class="dt">Variable</span> x) env <span class="fu">=</span> 
  return (fromJust (lookup x env))
evaluate (<span class="dt">Function</span> x body) env <span class="fu">=</span> 
  return (<span class="dt">ClosureV</span>  x body env)
evaluate (<span class="dt">Call</span> fun arg) env <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">ClosureV</span>  x body closeEnv <span class="ot">&lt;-</span> evaluate fun env
  argv <span class="ot">&lt;-</span> evaluate arg env
  <span class="kw">let</span> newEnv <span class="fu">=</span> (x, argv) <span class="fu">:</span> closeEnv
  evaluate body newEnv
evaluate (<span class="dt">Mutable</span> e) env <span class="fu">=</span> <span class="kw">do</span>
  ev <span class="ot">&lt;-</span> evaluate e env
  newMemory ev        
evaluate (<span class="dt">Access</span> a) env <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">AddressV</span> i <span class="ot">&lt;-</span> evaluate a env
  readMemory i
evaluate (<span class="dt">Assign</span> a e) env <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">AddressV</span> i <span class="ot">&lt;-</span> evaluate a env
  ev <span class="ot">&lt;-</span> evaluate e env
  updateMemory ev i
  return ev
<span class="co">-- <a href='' id='Comment:StatefulMonad3' ></a></span></code></pre><p>The evaluate function depends on three helper functions that provide basic stateful computations to create memory cells, read memory, and udpate memory. <a href='' id='Comment:Mona23' ></a></p><pre class="sourceCode literate haskell"><code class="sourceCode haskell">newMemory val <span class="fu">=</span> <span class="dt">ST</span> (\mem<span class="ot">-&gt;</span> (<span class="dt">AddressV</span> (length mem), mem <span class="fu">++</span> [val]))
<span class="co">-- <a href='' id='Comment:StatefulHelper1' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell">readMemory i <span class="fu">=</span> <span class="dt">ST</span> (\mem<span class="ot">-&gt;</span> (access i mem, mem))
<span class="co">-- <a href='' id='Comment:StatefulHelper2' ></a></span></code></pre><pre class="sourceCode literate haskell"><code class="sourceCode haskell">updateMemory val i <span class="fu">=</span> <span class="dt">ST</span> (\mem<span class="ot">-&gt;</span> ((), update i val mem))
<span class="co">-- <a href='' id='Comment:StatefulHelper3' ></a></span></code></pre><h1 id="more-chapters-on-the-way"><a href="#more-chapters-on-the-way"><span class="header-section-number">7</span> More Chapters on the way…</a></h1><h2 id="abstract-interpretation-and-types"><a href="#abstract-interpretation-and-types"><span class="header-section-number">7.1</span> Abstract Interpretation and Types</a></h2><h2 id="data-abstraction-objects-and-abstract-data-types"><a href="#data-abstraction-objects-and-abstract-data-types"><span class="header-section-number">7.2</span> Data Abstraction: Objects and Abstract Data Types</a></h2><h2 id="algebra-and-coalgebra"><a href="#algebra-and-coalgebra"><span class="header-section-number">7.3</span> Algebra and Coalgebra</a></h2><h2 id="partial-evaluation"><a href="#partial-evaluation"><span class="header-section-number">7.4</span> Partial Evaluation</a></h2><h2 id="memory-management"><a href="#memory-management"><span class="header-section-number">7.5</span> Memory Management</a></h2><div class="references"><h1><a href="#references"><span class="header-section-number">7.5</span> References</a></h1><p>Abelson, Harold, and Gerald J. Sussman. 1996. <em>Structure and Interpretation of Computer Programs</em>. 2nd ed. Cambridge, MA, USA: MIT Press.</p><p>Allen, John. 1978. <em>Anatomy of LISP</em>. New York, NY, USA: McGraw-Hill, Inc.</p><p>Friedman, Daniel P., and Mitchell Wand. 2008. <em>Essentials of Programming Languages, 3rd Edition</em>. 3rd ed. The MIT Press.</p><p>Gabriel, Richard P. 1988. “The Why of Y.” <em>SIGPLAN Lisp Pointers</em> 2 (2): 15–25.</p><p>Gunter, Carl A. 1993. <em>Semantics of Programming Languages - Structures and Techniques</em>. <em>Foundations of Computing</em>. MIT Press.</p><p>Krishnamurthi, Shriram. 2012. <em>Programming Languages: Application and Interpretation</em>.</p><p>Mitchell, John C., and Krzysztof Apt. 2001. <em>Concepts in Programming Languages</em>. New York, NY, USA: Cambridge University Press.</p><p>Scott, Dana. 1975. “Data Types as Lattices.” In <em>ISILC Logic Conference</em>, 499:579–651.</p><p>Thomas, Scarlett. 2006. <em>The End of Mr. Y</em>. Houghton Mifflin Harcourt.</p><p>Wadler, P. 1987. “A Critique of Abelson and Sussman or Why Calculating Is Better Than Scheming.” <em>SIGPLAN Not.</em> 22 (3) (mar): 83–94. doi:10.1145/24697.24706. <a href="http://doi.acm.org/10.1145/24697.24706" title="http://doi.acm.org/10.1145/24697.24706">http://doi.acm.org/10.1145/24697.24706</a>.</p></div><div class="footnotes"><hr /><ol><li id="fn1"><p>Church’s original presentation of the lambda calculus followed the mathematical convention that all variables were single characters. Thus <code>xy</code> means a function call, <code>x y</code>, just as <code>xy</code> is taken to mean <code>x * y</code> in arithmetic expressions. Normally in computer science we allow variables to have long names, so <code>xy</code> would be the name of a single variable. We don’t like it when <code>foo</code> means <code>f o o</code>, which in Haskell means <code>(f(o))(o)</code>. <a href='' id='Comment:Func13' ></a><a href="#fnref1">↩</a></p></li><li id="fn2"><p>This kind of behavioral representation will come again when we discuss object-oriented programming. <a href='' id='Comment:Repr9' ></a><a href="#fnref2">↩</a></p></li><li id="fn3"><p>Oddly enough, this kind of <code>inf</code> value is not useless! It has some legitimate uses in debugging Haskell programs (more on this later). <a href='' id='Comment:Unde17' ></a><a href="#fnref3">↩</a></p></li><li id="fn4"><p>The function <code>fix</code> is often called <span class="math">\(Y\)</span>. For further reading, see <span class="citation">Scott (1975)</span>, <span class="citation">Gunter (1993)</span>, <span class="citation">Gabriel (1988)</span> and <span class="citation">Thomas (2006)</span>. <a href='' id='Comment:Fixe13' ></a><a href="#fnref4">↩</a></p></li></ol></div>
</body>
</html>
